import {
  require_react_dom
} from "./chunk-ADFE3MZT.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  require_react
} from "./chunk-475KVKU7.js";

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL2 = "@@iterator";
        function getIteratorFn2(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL2];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values2, location, componentName, element) {
          {
            var has5 = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has5(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn2(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/@tanstack/query-core/build/lib/subscribable.js
var require_subscribable = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/subscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        const identity = {
          listener
        };
        this.listeners.add(identity);
        this.onSubscribe();
        return () => {
          this.listeners.delete(identity);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };
    exports.Subscribable = Subscribable;
  }
});

// node_modules/@tanstack/query-core/build/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isServer = typeof window === "undefined" || "Deno" in window;
    function noop() {
      return void 0;
    }
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function difference(array1, array2) {
      return array1.filter((x) => !array2.includes(x));
    }
    function replaceAt(array, index, value) {
      const copy = array.slice(0);
      copy[index] = value;
      return copy;
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function parseQueryArgs(arg1, arg2, arg3) {
      if (!isQueryKey(arg1)) {
        return arg1;
      }
      if (typeof arg2 === "function") {
        return {
          ...arg3,
          queryKey: arg1,
          queryFn: arg2
        };
      }
      return {
        ...arg2,
        queryKey: arg1
      };
    }
    function parseMutationArgs(arg1, arg2, arg3) {
      if (isQueryKey(arg1)) {
        if (typeof arg2 === "function") {
          return {
            ...arg3,
            mutationKey: arg1,
            mutationFn: arg2
          };
        }
        return {
          ...arg2,
          mutationKey: arg1
        };
      }
      if (typeof arg1 === "function") {
        return {
          ...arg2,
          mutationFn: arg1
        };
      }
      return {
        ...arg1
      };
    }
    function parseFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [{
        ...arg2,
        queryKey: arg1
      }, arg3] : [arg1 || {}, arg2];
    }
    function parseMutationFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [{
        ...arg2,
        mutationKey: arg1
      }, arg3] : [arg1 || {}, arg2];
    }
    function matchQuery(filters, query) {
      const {
        type = "all",
        exact,
        fetchStatus,
        predicate,
        queryKey,
        stale
      } = filters;
      if (isQueryKey(queryKey)) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      if (type !== "all") {
        const isActive = query.isActive();
        if (type === "active" && !isActive) {
          return false;
        }
        if (type === "inactive" && isActive) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      const {
        exact,
        fetching,
        predicate,
        mutationKey
      } = filters;
      if (isQueryKey(mutationKey)) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
      return hashFn(queryKey);
    }
    function hashQueryKey(queryKey) {
      return JSON.stringify(queryKey, (_, val) => isPlainObject2(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val);
    }
    function partialMatchKey(a, b) {
      return partialDeepEqual(a, b);
    }
    function partialDeepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (a && b && typeof a === "object" && typeof b === "object") {
        return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
      }
      return false;
    }
    function replaceEqualDeep(a, b) {
      if (a === b) {
        return a;
      }
      const array = isPlainArray(a) && isPlainArray(b);
      if (array || isPlainObject2(a) && isPlainObject2(b)) {
        const aSize = array ? a.length : Object.keys(a).length;
        const bItems = array ? b : Object.keys(b);
        const bSize = bItems.length;
        const copy = array ? [] : {};
        let equalItems = 0;
        for (let i = 0; i < bSize; i++) {
          const key = array ? i : bItems[i];
          copy[key] = replaceEqualDeep(a[key], b[key]);
          if (copy[key] === a[key]) {
            equalItems++;
          }
        }
        return aSize === bSize && equalItems === aSize ? a : copy;
      }
      return b;
    }
    function shallowEqualObjects(a, b) {
      if (a && !b || b && !a) {
        return false;
      }
      for (const key in a) {
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainArray(value) {
      return Array.isArray(value) && value.length === Object.keys(value).length;
    }
    function isPlainObject2(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }
      const ctor = o.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function isQueryKey(value) {
      return Array.isArray(value);
    }
    function isError(value) {
      return value instanceof Error;
    }
    function sleep(timeout) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeout);
      });
    }
    function scheduleMicrotask(callback) {
      sleep(0).then(callback);
    }
    function getAbortController() {
      if (typeof AbortController === "function") {
        return new AbortController();
      }
      return;
    }
    function replaceData(prevData, data, options) {
      if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
        return prevData;
      } else if (typeof options.structuralSharing === "function") {
        return options.structuralSharing(prevData, data);
      } else if (options.structuralSharing !== false) {
        return replaceEqualDeep(prevData, data);
      }
      return data;
    }
    exports.difference = difference;
    exports.functionalUpdate = functionalUpdate;
    exports.getAbortController = getAbortController;
    exports.hashQueryKey = hashQueryKey;
    exports.hashQueryKeyByOptions = hashQueryKeyByOptions;
    exports.isError = isError;
    exports.isPlainArray = isPlainArray;
    exports.isPlainObject = isPlainObject2;
    exports.isQueryKey = isQueryKey;
    exports.isServer = isServer;
    exports.isValidTimeout = isValidTimeout;
    exports.matchMutation = matchMutation;
    exports.matchQuery = matchQuery;
    exports.noop = noop;
    exports.parseFilterArgs = parseFilterArgs;
    exports.parseMutationArgs = parseMutationArgs;
    exports.parseMutationFilterArgs = parseMutationFilterArgs;
    exports.parseQueryArgs = parseQueryArgs;
    exports.partialDeepEqual = partialDeepEqual;
    exports.partialMatchKey = partialMatchKey;
    exports.replaceAt = replaceAt;
    exports.replaceData = replaceData;
    exports.replaceEqualDeep = replaceEqualDeep;
    exports.scheduleMicrotask = scheduleMicrotask;
    exports.shallowEqualObjects = shallowEqualObjects;
    exports.sleep = sleep;
    exports.timeUntilStale = timeUntilStale;
  }
});

// node_modules/@tanstack/query-core/build/lib/focusManager.js
var require_focusManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/focusManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscribable = require_subscribable();
    var utils = require_utils();
    var FocusManager = class extends subscribable.Subscribable {
      constructor() {
        super();
        this.setup = (onFocus) => {
          if (!utils.isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            window.addEventListener("focus", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
              window.removeEventListener("focus", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.focused !== focused;
        if (changed) {
          this.focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isFocused() {
        if (typeof this.focused === "boolean") {
          return this.focused;
        }
        if (typeof document === "undefined") {
          return true;
        }
        return [void 0, "visible", "prerender"].includes(document.visibilityState);
      }
    };
    var focusManager = new FocusManager();
    exports.FocusManager = FocusManager;
    exports.focusManager = focusManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/onlineManager.js
var require_onlineManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/onlineManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscribable = require_subscribable();
    var utils = require_utils();
    var onlineEvents = ["online", "offline"];
    var OnlineManager = class extends subscribable.Subscribable {
      constructor() {
        super();
        this.setup = (onOnline) => {
          if (!utils.isServer && window.addEventListener) {
            const listener = () => onOnline();
            onlineEvents.forEach((event) => {
              window.addEventListener(event, listener, false);
            });
            return () => {
              onlineEvents.forEach((event) => {
                window.removeEventListener(event, listener);
              });
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((online) => {
          if (typeof online === "boolean") {
            this.setOnline(online);
          } else {
            this.onOnline();
          }
        });
      }
      setOnline(online) {
        const changed = this.online !== online;
        if (changed) {
          this.online = online;
          this.onOnline();
        }
      }
      onOnline() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isOnline() {
        if (typeof this.online === "boolean") {
          return this.online;
        }
        if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
          return true;
        }
        return navigator.onLine;
      }
    };
    var onlineManager = new OnlineManager();
    exports.OnlineManager = OnlineManager;
    exports.onlineManager = onlineManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/retryer.js
var require_retryer = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/retryer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var utils = require_utils();
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * 2 ** failureCount, 3e4);
    }
    function canFetch(networkMode) {
      return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.onlineManager.isOnline() : true;
    }
    var CancelledError = class {
      constructor(options) {
        this.revert = options == null ? void 0 : options.revert;
        this.silent = options == null ? void 0 : options.silent;
      }
    };
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    function createRetryer(config) {
      let isRetryCancelled = false;
      let failureCount = 0;
      let isResolved = false;
      let continueFn;
      let promiseResolve;
      let promiseReject;
      const promise = new Promise((outerResolve, outerReject) => {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
      });
      const cancel = (cancelOptions) => {
        if (!isResolved) {
          reject(new CancelledError(cancelOptions));
          config.abort == null ? void 0 : config.abort();
        }
      };
      const cancelRetry = () => {
        isRetryCancelled = true;
      };
      const continueRetry = () => {
        isRetryCancelled = false;
      };
      const shouldPause = () => !focusManager.focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.onlineManager.isOnline();
      const resolve = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onSuccess == null ? void 0 : config.onSuccess(value);
          continueFn == null ? void 0 : continueFn();
          promiseResolve(value);
        }
      };
      const reject = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onError == null ? void 0 : config.onError(value);
          continueFn == null ? void 0 : continueFn();
          promiseReject(value);
        }
      };
      const pause = () => {
        return new Promise((continueResolve) => {
          continueFn = (value) => {
            const canContinue = isResolved || !shouldPause();
            if (canContinue) {
              continueResolve(value);
            }
            return canContinue;
          };
          config.onPause == null ? void 0 : config.onPause();
        }).then(() => {
          continueFn = void 0;
          if (!isResolved) {
            config.onContinue == null ? void 0 : config.onContinue();
          }
        });
      };
      const run = () => {
        if (isResolved) {
          return;
        }
        let promiseOrValue;
        try {
          promiseOrValue = config.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
          var _config$retry, _config$retryDelay;
          if (isResolved) {
            return;
          }
          const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
          const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
          const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
          const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
          if (isRetryCancelled || !shouldRetry) {
            reject(error);
            return;
          }
          failureCount++;
          config.onFail == null ? void 0 : config.onFail(failureCount, error);
          utils.sleep(delay).then(() => {
            if (shouldPause()) {
              return pause();
            }
            return;
          }).then(() => {
            if (isRetryCancelled) {
              reject(error);
            } else {
              run();
            }
          });
        });
      };
      if (canFetch(config.networkMode)) {
        run();
      } else {
        pause().then(run);
      }
      return {
        promise,
        cancel,
        continue: () => {
          const didContinue = continueFn == null ? void 0 : continueFn();
          return didContinue ? promise : Promise.resolve();
        },
        cancelRetry,
        continueRetry
      };
    }
    exports.CancelledError = CancelledError;
    exports.canFetch = canFetch;
    exports.createRetryer = createRetryer;
    exports.isCancelledError = isCancelledError;
  }
});

// node_modules/@tanstack/query-core/build/lib/logger.js
var require_logger = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultLogger = console;
    exports.defaultLogger = defaultLogger;
  }
});

// node_modules/@tanstack/query-core/build/lib/notifyManager.js
var require_notifyManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/notifyManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    function createNotifyManager() {
      let queue = [];
      let transactions = 0;
      let notifyFn = (callback) => {
        callback();
      };
      let batchNotifyFn = (callback) => {
        callback();
      };
      const batch = (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      };
      const schedule = (callback) => {
        if (transactions) {
          queue.push(callback);
        } else {
          utils.scheduleMicrotask(() => {
            notifyFn(callback);
          });
        }
      };
      const batchCalls = (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      };
      const flush = () => {
        const originalQueue = queue;
        queue = [];
        if (originalQueue.length) {
          utils.scheduleMicrotask(() => {
            batchNotifyFn(() => {
              originalQueue.forEach((callback) => {
                notifyFn(callback);
              });
            });
          });
        }
      };
      const setNotifyFunction = (fn) => {
        notifyFn = fn;
      };
      const setBatchNotifyFunction = (fn) => {
        batchNotifyFn = fn;
      };
      return {
        batch,
        batchCalls,
        schedule,
        setNotifyFunction,
        setBatchNotifyFunction
      };
    }
    var notifyManager = createNotifyManager();
    exports.createNotifyManager = createNotifyManager;
    exports.notifyManager = notifyManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/removable.js
var require_removable = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/removable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var Removable = class {
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (utils.isValidTimeout(this.cacheTime)) {
          this.gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.cacheTime);
        }
      }
      updateCacheTime(newCacheTime) {
        this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : utils.isServer ? Infinity : 5 * 60 * 1e3);
      }
      clearGcTimeout() {
        if (this.gcTimeout) {
          clearTimeout(this.gcTimeout);
          this.gcTimeout = void 0;
        }
      }
    };
    exports.Removable = Removable;
  }
});

// node_modules/@tanstack/query-core/build/lib/query.js
var require_query = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var logger = require_logger();
    var notifyManager = require_notifyManager();
    var retryer = require_retryer();
    var removable = require_removable();
    var Query = class extends removable.Removable {
      constructor(config) {
        super();
        this.abortSignalConsumed = false;
        this.defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.cache = config.cache;
        this.logger = config.logger || logger.defaultLogger;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.initialState = config.state || getDefaultState(this.options);
        this.state = this.initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.cache.remove(this);
        }
      }
      setData(newData, options) {
        const data = utils.replaceData(this.state.data, newData, this.options);
        this.dispatch({
          data,
          type: "success",
          dataUpdatedAt: options == null ? void 0 : options.updatedAt,
          manual: options == null ? void 0 : options.manual
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.dispatch({
          type: "setState",
          state,
          setStateOptions
        });
      }
      cancel(options) {
        var _this$retryer;
        const promise = this.promise;
        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
        return promise ? promise.then(utils.noop).catch(utils.noop) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({
          silent: true
        });
      }
      reset() {
        this.destroy();
        this.setState(this.initialState);
      }
      isActive() {
        return this.observers.some((observer) => observer.options.enabled !== false);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !utils.timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        var _this$retryer2;
        const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
      }
      onOnline() {
        var _this$retryer3;
        const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.cache.notify({
            type: "observerAdded",
            query: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x) => x !== observer);
          if (!this.observers.length) {
            if (this.retryer) {
              if (this.abortSignalConsumed) {
                this.retryer.cancel({
                  revert: true
                });
              } else {
                this.retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.cache.notify({
            type: "observerRemoved",
            query: this,
            observer
          });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.dispatch({
            type: "invalidate"
          });
        }
      }
      fetch(options, fetchOptions) {
        var _this$options$behavio, _context$fetchOptions;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
            this.cancel({
              silent: true
            });
          } else if (this.promise) {
            var _this$retryer4;
            (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
            return this.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x) => x.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (!Array.isArray(this.options.queryKey)) {
          if (true) {
            this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
          }
        }
        const abortController = utils.getAbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          pageParam: void 0,
          meta: this.meta
        };
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (abortController) {
                this.abortSignalConsumed = true;
                return abortController.signal;
              }
              return void 0;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (!this.options.queryFn) {
            return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
          }
          this.abortSignalConsumed = false;
          return this.options.queryFn(queryFnContext);
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
        this.revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
          var _context$fetchOptions2;
          this.dispatch({
            type: "fetch",
            meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
          });
        }
        const onError = (error) => {
          if (!(retryer.isCancelledError(error) && error.silent)) {
            this.dispatch({
              type: "error",
              error
            });
          }
          if (!retryer.isCancelledError(error)) {
            var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
            (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
            (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
            if (true) {
              this.logger.error(error);
            }
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.retryer = retryer.createRetryer({
          fn: context.fetchFn,
          abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
          onSuccess: (data) => {
            var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
            if (typeof data === "undefined") {
              if (true) {
                this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
              }
              onError(new Error(this.queryHash + " data is undefined"));
              return;
            }
            this.setData(data);
            (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
            (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode
        });
        this.promise = this.retryer.promise;
        return this.promise;
      }
      dispatch(action) {
        const reducer = (state) => {
          var _action$meta, _action$dataUpdatedAt;
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
                fetchStatus: retryer.canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!state.dataUpdatedAt && {
                  error: null,
                  status: "loading"
                }
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error = action.error;
              if (retryer.isCancelledError(error) && error.revert && this.revertState) {
                return {
                  ...this.revertState
                };
              }
              return {
                ...state,
                error,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate(action);
          });
          this.cache.notify({
            query: this,
            type: "updated",
            action
          });
        });
      }
    };
    function getDefaultState(options) {
      const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
      const hasData = typeof data !== "undefined";
      const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
      return {
        data,
        dataUpdateCount: 0,
        dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: false,
        status: hasData ? "success" : "loading",
        fetchStatus: "idle"
      };
    }
    exports.Query = Query;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryCache.js
var require_queryCache = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var query = require_query();
    var notifyManager = require_notifyManager();
    var subscribable = require_subscribable();
    var QueryCache = class extends subscribable.Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.queries = [];
        this.queriesMap = {};
      }
      build(client, options, state) {
        var _options$queryHash;
        const queryKey = options.queryKey;
        const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : utils.hashQueryKeyByOptions(queryKey, options);
        let query$1 = this.get(queryHash);
        if (!query$1) {
          query$1 = new query.Query({
            cache: this,
            logger: client.getLogger(),
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query$1);
        }
        return query$1;
      }
      add(query2) {
        if (!this.queriesMap[query2.queryHash]) {
          this.queriesMap[query2.queryHash] = query2;
          this.queries.push(query2);
          this.notify({
            type: "added",
            query: query2
          });
        }
      }
      remove(query2) {
        const queryInMap = this.queriesMap[query2.queryHash];
        if (queryInMap) {
          query2.destroy();
          this.queries = this.queries.filter((x) => x !== query2);
          if (queryInMap === query2) {
            delete this.queriesMap[query2.queryHash];
          }
          this.notify({
            type: "removed",
            query: query2
          });
        }
      }
      clear() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            this.remove(query2);
          });
        });
      }
      get(queryHash) {
        return this.queriesMap[queryHash];
      }
      getAll() {
        return this.queries;
      }
      find(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.queries.find((query2) => utils.matchQuery(filters, query2));
      }
      findAll(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        return Object.keys(filters).length > 0 ? this.queries.filter((query2) => utils.matchQuery(filters, query2)) : this.queries;
      }
      notify(event) {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            query2.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            query2.onOnline();
          });
        });
      }
    };
    exports.QueryCache = QueryCache;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutation.js
var require_mutation = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger = require_logger();
    var notifyManager = require_notifyManager();
    var removable = require_removable();
    var retryer = require_retryer();
    var Mutation = class extends removable.Removable {
      constructor(config) {
        super();
        this.defaultOptions = config.defaultOptions;
        this.mutationId = config.mutationId;
        this.mutationCache = config.mutationCache;
        this.logger = config.logger || logger.defaultLogger;
        this.observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      get meta() {
        return this.options.meta;
      }
      setState(state) {
        this.dispatch({
          type: "setState",
          state
        });
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.observers = this.observers.filter((x) => x !== observer);
        this.scheduleGc();
        this.mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.observers.length) {
          if (this.state.status === "loading") {
            this.scheduleGc();
          } else {
            this.mutationCache.remove(this);
          }
        }
      }
      continue() {
        var _this$retryer$continu, _this$retryer;
        return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
      }
      async execute() {
        const executeMutation = () => {
          var _this$options$retry;
          this.retryer = retryer.createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject("No mutationFn found");
              }
              return this.options.mutationFn(this.state.variables);
            },
            onFail: (failureCount, error) => {
              this.dispatch({
                type: "failed",
                failureCount,
                error
              });
            },
            onPause: () => {
              this.dispatch({
                type: "pause"
              });
            },
            onContinue: () => {
              this.dispatch({
                type: "continue"
              });
            },
            retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
          });
          return this.retryer.promise;
        };
        const restored = this.state.status === "loading";
        try {
          var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
          if (!restored) {
            var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
            this.dispatch({
              type: "loading",
              variables: this.options.variables
            });
            await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
            const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
            if (context !== this.state.context) {
              this.dispatch({
                type: "loading",
                context,
                variables: this.state.variables
              });
            }
          }
          const data = await executeMutation();
          await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
          await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
          await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
          this.dispatch({
            type: "success",
            data
          });
          return data;
        } catch (error) {
          try {
            var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
            await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
            if (true) {
              this.logger.error(error);
            }
            await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
            await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
            await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
            throw error;
          } finally {
            this.dispatch({
              type: "error",
              error
            });
          }
        }
      }
      dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "loading":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !retryer.canFetch(this.options.networkMode),
                status: "loading",
                variables: action.variables
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: false,
        status: "idle",
        variables: void 0
      };
    }
    exports.Mutation = Mutation;
    exports.getDefaultState = getDefaultState;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutationCache.js
var require_mutationCache = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutationCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var notifyManager = require_notifyManager();
    var mutation = require_mutation();
    var utils = require_utils();
    var subscribable = require_subscribable();
    var MutationCache = class extends subscribable.Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.mutations = [];
        this.mutationId = 0;
      }
      build(client, options, state) {
        const mutation$1 = new mutation.Mutation({
          mutationCache: this,
          logger: client.getLogger(),
          mutationId: ++this.mutationId,
          options: client.defaultMutationOptions(options),
          state,
          defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
        });
        this.add(mutation$1);
        return mutation$1;
      }
      add(mutation2) {
        this.mutations.push(mutation2);
        this.notify({
          type: "added",
          mutation: mutation2
        });
      }
      remove(mutation2) {
        this.mutations = this.mutations.filter((x) => x !== mutation2);
        this.notify({
          type: "removed",
          mutation: mutation2
        });
      }
      clear() {
        notifyManager.notifyManager.batch(() => {
          this.mutations.forEach((mutation2) => {
            this.remove(mutation2);
          });
        });
      }
      getAll() {
        return this.mutations;
      }
      find(filters) {
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.mutations.find((mutation2) => utils.matchMutation(filters, mutation2));
      }
      findAll(filters) {
        return this.mutations.filter((mutation2) => utils.matchMutation(filters, mutation2));
      }
      notify(event) {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        var _this$resuming;
        this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
          const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
          return notifyManager.notifyManager.batch(() => pausedMutations.reduce((promise, mutation2) => promise.then(() => mutation2.continue().catch(utils.noop)), Promise.resolve()));
        }).then(() => {
          this.resuming = void 0;
        });
        return this.resuming;
      }
    };
    exports.MutationCache = MutationCache;
  }
});

// node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js
var require_infiniteQueryBehavior = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function infiniteQueryBehavior() {
      return {
        onFetch: (context) => {
          context.fetchFn = () => {
            var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
            const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
            const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
            const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
            const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
            const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
            const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
            const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
            let newPageParams = oldPageParams;
            let cancelled = false;
            const addSignalProperty = (object) => {
              Object.defineProperty(object, "signal", {
                enumerable: true,
                get: () => {
                  var _context$signal;
                  if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                    cancelled = true;
                  } else {
                    var _context$signal2;
                    (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                      cancelled = true;
                    });
                  }
                  return context.signal;
                }
              });
            };
            const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
            const buildNewPages = (pages, param, page, previous) => {
              newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
              return previous ? [page, ...pages] : [...pages, page];
            };
            const fetchPage = (pages, manual, param, previous) => {
              if (cancelled) {
                return Promise.reject("Cancelled");
              }
              if (typeof param === "undefined" && !manual && pages.length) {
                return Promise.resolve(pages);
              }
              const queryFnContext = {
                queryKey: context.queryKey,
                pageParam: param,
                meta: context.options.meta
              };
              addSignalProperty(queryFnContext);
              const queryFnResult = queryFn(queryFnContext);
              const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
              return promise2;
            };
            let promise;
            if (!oldPages.length) {
              promise = fetchPage([]);
            } else if (isFetchingNextPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param);
            } else if (isFetchingPreviousPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param, true);
            } else {
              newPageParams = [];
              const manual = typeof context.options.getNextPageParam === "undefined";
              const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
              promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
              for (let i = 1; i < oldPages.length; i++) {
                promise = promise.then((pages) => {
                  const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;
                  if (shouldFetchNextPage) {
                    const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);
                    return fetchPage(pages, manual, param);
                  }
                  return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
                });
              }
            }
            const finalPromise = promise.then((pages) => ({
              pages,
              pageParams: newPageParams
            }));
            return finalPromise;
          };
        }
      };
    }
    function getNextPageParam(options, pages) {
      return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
    }
    function getPreviousPageParam(options, pages) {
      return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
    }
    function hasNextPage(options, pages) {
      if (options.getNextPageParam && Array.isArray(pages)) {
        const nextPageParam = getNextPageParam(options, pages);
        return typeof nextPageParam !== "undefined" && nextPageParam !== null && nextPageParam !== false;
      }
      return;
    }
    function hasPreviousPage(options, pages) {
      if (options.getPreviousPageParam && Array.isArray(pages)) {
        const previousPageParam = getPreviousPageParam(options, pages);
        return typeof previousPageParam !== "undefined" && previousPageParam !== null && previousPageParam !== false;
      }
      return;
    }
    exports.getNextPageParam = getNextPageParam;
    exports.getPreviousPageParam = getPreviousPageParam;
    exports.hasNextPage = hasNextPage;
    exports.hasPreviousPage = hasPreviousPage;
    exports.infiniteQueryBehavior = infiniteQueryBehavior;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryClient.js
var require_queryClient = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var queryCache = require_queryCache();
    var mutationCache = require_mutationCache();
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var notifyManager = require_notifyManager();
    var infiniteQueryBehavior = require_infiniteQueryBehavior();
    var logger = require_logger();
    var QueryClient = class {
      constructor(config = {}) {
        this.queryCache = config.queryCache || new queryCache.QueryCache();
        this.mutationCache = config.mutationCache || new mutationCache.MutationCache();
        this.logger = config.logger || logger.defaultLogger;
        this.defaultOptions = config.defaultOptions || {};
        this.queryDefaults = [];
        this.mutationDefaults = [];
        this.mountCount = 0;
        if (config.logger) {
          this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
        }
      }
      mount() {
        this.mountCount++;
        if (this.mountCount !== 1)
          return;
        this.unsubscribeFocus = focusManager.focusManager.subscribe(() => {
          if (focusManager.focusManager.isFocused()) {
            this.resumePausedMutations();
            this.queryCache.onFocus();
          }
        });
        this.unsubscribeOnline = onlineManager.onlineManager.subscribe(() => {
          if (onlineManager.onlineManager.isOnline()) {
            this.resumePausedMutations();
            this.queryCache.onOnline();
          }
        });
      }
      unmount() {
        var _this$unsubscribeFocu, _this$unsubscribeOnli;
        this.mountCount--;
        if (this.mountCount !== 0)
          return;
        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
        this.unsubscribeFocus = void 0;
        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
        this.unsubscribeOnline = void 0;
      }
      isFetching(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        filters.fetchStatus = "fetching";
        return this.queryCache.findAll(filters).length;
      }
      isMutating(filters) {
        return this.mutationCache.findAll({
          ...filters,
          fetching: true
        }).length;
      }
      getQueryData(queryKey, filters) {
        var _this$queryCache$find;
        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
      }
      ensureQueryData(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        const cachedData = this.getQueryData(parsedOptions.queryKey);
        return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
      }
      getQueriesData(queryKeyOrFilters) {
        return this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey,
          state
        }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options) {
        const query = this.queryCache.find(queryKey);
        const prevData = query == null ? void 0 : query.state.data;
        const data = utils.functionalUpdate(updater, prevData);
        if (typeof data === "undefined") {
          return void 0;
        }
        const parsedOptions = utils.parseQueryArgs(queryKey);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        return this.queryCache.build(this, defaultedOptions).setData(data, {
          ...options,
          manual: true
        });
      }
      setQueriesData(queryKeyOrFilters, updater, options) {
        return notifyManager.notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey
        }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
      }
      getQueryState(queryKey, filters) {
        var _this$queryCache$find2;
        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
      }
      removeQueries(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        const queryCache2 = this.queryCache;
        notifyManager.notifyManager.batch(() => {
          queryCache2.findAll(filters).forEach((query) => {
            queryCache2.remove(query);
          });
        });
      }
      resetQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        const queryCache2 = this.queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.notifyManager.batch(() => {
          queryCache2.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options);
        });
      }
      cancelQueries(arg1, arg2, arg3) {
        const [filters, cancelOptions = {}] = utils.parseFilterArgs(arg1, arg2, arg3);
        if (typeof cancelOptions.revert === "undefined") {
          cancelOptions.revert = true;
        }
        const promises = notifyManager.notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
        return Promise.all(promises).then(utils.noop).catch(utils.noop);
      }
      invalidateQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        return notifyManager.notifyManager.batch(() => {
          var _ref, _filters$refetchType;
          this.queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
          };
          return this.refetchQueries(refetchFilters, options);
        });
      }
      refetchQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        const promises = notifyManager.notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          var _options$cancelRefetc;
          return query.fetch(void 0, {
            ...options,
            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
            meta: {
              refetchPage: filters.refetchPage
            }
          });
        }));
        let promise = Promise.all(promises).then(utils.noop);
        if (!(options != null && options.throwOnError)) {
          promise = promise.catch(utils.noop);
        }
        return promise;
      }
      fetchQuery(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        const query = this.queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(arg1, arg2, arg3) {
        return this.fetchQuery(arg1, arg2, arg3).then(utils.noop).catch(utils.noop);
      }
      fetchInfiniteQuery(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        parsedOptions.behavior = infiniteQueryBehavior.infiniteQueryBehavior();
        return this.fetchQuery(parsedOptions);
      }
      prefetchInfiniteQuery(arg1, arg2, arg3) {
        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(utils.noop).catch(utils.noop);
      }
      resumePausedMutations() {
        return this.mutationCache.resumePausedMutations();
      }
      getQueryCache() {
        return this.queryCache;
      }
      getMutationCache() {
        return this.mutationCache;
      }
      getLogger() {
        return this.logger;
      }
      getDefaultOptions() {
        return this.defaultOptions;
      }
      setDefaultOptions(options) {
        this.defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        const result = this.queryDefaults.find((x) => utils.hashQueryKey(queryKey) === utils.hashQueryKey(x.queryKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.queryDefaults.push({
            queryKey,
            defaultOptions: options
          });
        }
      }
      getQueryDefaults(queryKey) {
        if (!queryKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.queryDefaults.find((x) => utils.partialMatchKey(queryKey, x.queryKey));
        if (true) {
          const matchingDefaults = this.queryDefaults.filter((x) => utils.partialMatchKey(queryKey, x.queryKey));
          if (matchingDefaults.length > 1) {
            this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
          }
        }
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      setMutationDefaults(mutationKey, options) {
        const result = this.mutationDefaults.find((x) => utils.hashQueryKey(mutationKey) === utils.hashQueryKey(x.mutationKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.mutationDefaults.push({
            mutationKey,
            defaultOptions: options
          });
        }
      }
      getMutationDefaults(mutationKey) {
        if (!mutationKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.mutationDefaults.find((x) => utils.partialMatchKey(mutationKey, x.mutationKey));
        if (true) {
          const matchingDefaults = this.mutationDefaults.filter((x) => utils.partialMatchKey(mutationKey, x.mutationKey));
          if (matchingDefaults.length > 1) {
            this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
          }
        }
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      defaultQueryOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.defaultOptions.queries,
          ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
          defaultedOptions.queryHash = utils.hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
        }
        if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (typeof defaultedOptions.useErrorBoundary === "undefined") {
          defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        return {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.queryCache.clear();
        this.mutationCache.clear();
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryObserver.js
var require_queryObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var notifyManager = require_notifyManager();
    var focusManager = require_focusManager();
    var subscribable = require_subscribable();
    var retryer = require_retryer();
    var QueryObserver = class extends subscribable.Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.options = options;
        this.trackedProps = /* @__PURE__ */ new Set();
        this.selectError = null;
        this.bindMethods();
        this.setOptions(options);
      }
      bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.currentQuery, this.options)) {
            this.executeFetch();
          }
          this.updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.clearStaleTimeout();
        this.clearRefetchInterval();
        this.currentQuery.removeObserver(this);
      }
      setOptions(options, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryOptions(options);
        if (typeof (options == null ? void 0 : options.isDataEqual) !== "undefined") {
          this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option");
        }
        if (!utils.shallowEqualObjects(prevOptions, this.options)) {
          this.client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this
          });
        }
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
          this.executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.updateStaleTimeout();
        }
        const nextRefetchInterval = this.computeRefetchInterval();
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
          this.updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query = this.client.getQueryCache().build(this.client, options);
        const result = this.createResult(query, options);
        if (shouldAssignObserverCurrentProperties(this, result, options)) {
          this.currentResult = result;
          this.currentResultOptions = this.options;
          this.currentResultState = this.currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.currentResult;
      }
      trackResult(result) {
        const trackedResult = {};
        Object.keys(result).forEach((key) => {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.trackedProps.add(key);
              return result[key];
            }
          });
        });
        return trackedResult;
      }
      getCurrentQuery() {
        return this.currentQuery;
      }
      remove() {
        this.client.getQueryCache().remove(this.currentQuery);
      }
      refetch({
        refetchPage,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            refetchPage
          }
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.client.defaultQueryOptions(options);
        const query = this.client.getQueryCache().build(this.client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        var _fetchOptions$cancelR;
        return this.executeFetch({
          ...fetchOptions,
          cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
        }).then(() => {
          this.updateResult();
          return this.currentResult;
        });
      }
      executeFetch(fetchOptions) {
        this.updateQuery();
        let promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions != null && fetchOptions.throwOnError)) {
          promise = promise.catch(utils.noop);
        }
        return promise;
      }
      updateStaleTimeout() {
        this.clearStaleTimeout();
        if (utils.isServer || this.currentResult.isStale || !utils.isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = utils.timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
        const timeout = time + 1;
        this.staleTimeoutId = setTimeout(() => {
          if (!this.currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
      }
      updateRefetchInterval(nextInterval) {
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (utils.isServer || this.options.enabled === false || !utils.isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
          return;
        }
        this.refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.focusManager.isFocused()) {
            this.executeFetch();
          }
        }, this.currentRefetchInterval);
      }
      updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
      }
      clearStaleTimeout() {
        if (this.staleTimeoutId) {
          clearTimeout(this.staleTimeoutId);
          this.staleTimeoutId = void 0;
        }
      }
      clearRefetchInterval() {
        if (this.refetchIntervalId) {
          clearInterval(this.refetchIntervalId);
          this.refetchIntervalId = void 0;
        }
      }
      createResult(query, options) {
        const prevQuery = this.currentQuery;
        const prevOptions = this.options;
        const prevResult = this.currentResult;
        const prevResultState = this.currentResultState;
        const prevResultOptions = this.currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        const {
          state
        } = query;
        let {
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          fetchStatus,
          status
        } = state;
        let isPreviousData = false;
        let isPlaceholderData = false;
        let data;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            fetchStatus = retryer.canFetch(query.options.networkMode) ? "fetching" : "paused";
            if (!dataUpdatedAt) {
              status = "loading";
            }
          }
          if (options._optimisticResults === "isRestoring") {
            fetchStatus = "idle";
          }
        }
        if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
          data = prevQueryResult.data;
          dataUpdatedAt = prevQueryResult.dataUpdatedAt;
          status = prevQueryResult.status;
          isPreviousData = true;
        } else if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
            data = this.selectResult;
          } else {
            try {
              this.selectFn = options.select;
              data = options.select(state.data);
              data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
              this.selectResult = data;
              this.selectError = null;
            } catch (selectError) {
              if (true) {
                this.client.getLogger().error(selectError);
              }
              this.selectError = selectError;
            }
          }
        } else {
          data = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
          let placeholderData;
          if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                this.selectError = null;
              } catch (selectError) {
                if (true) {
                  this.client.getLogger().error(selectError);
                }
                this.selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
            isPlaceholderData = true;
          }
        }
        if (this.selectError) {
          error = this.selectError;
          data = this.selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = fetchStatus === "fetching";
        const isLoading = status === "loading";
        const isError = status === "error";
        const result = {
          status,
          fetchStatus,
          isLoading,
          isSuccess: status === "success",
          isError,
          isInitialLoading: isLoading && isFetching,
          data,
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          failureReason: state.fetchFailureReason,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isLoading,
          isLoadingError: isError && state.dataUpdatedAt === 0,
          isPaused: fetchStatus === "paused",
          isPlaceholderData,
          isPreviousData,
          isRefetchError: isError && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch,
          remove: this.remove
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.currentResult;
        const nextResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options;
        if (utils.shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.currentResult = nextResult;
        const defaultNotifyOptions = {
          cache: true
        };
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const {
            notifyOnChangeProps
          } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
            return true;
          }
          const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
          if (this.options.useErrorBoundary) {
            includedProps.add("error");
          }
          return Object.keys(this.currentResult).some((key) => {
            const typedKey = key;
            const changed = this.currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.notify({
          ...defaultNotifyOptions,
          ...notifyOptions
        });
      }
      updateQuery() {
        const query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
          return;
        }
        const prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
          prevQuery == null ? void 0 : prevQuery.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate(action) {
        const notifyOptions = {};
        if (action.type === "success") {
          notifyOptions.onSuccess = !action.manual;
        } else if (action.type === "error" && !retryer.isCancelledError(action.error)) {
          notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
          this.updateTimers();
        }
      }
      notify(notifyOptions) {
        notifyManager.notifyManager.batch(() => {
          if (notifyOptions.onSuccess) {
            var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
            (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
            (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
          } else if (notifyOptions.onError) {
            var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
            (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
            (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
          }
          if (notifyOptions.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
          if (notifyOptions.cache) {
            this.client.getQueryCache().notify({
              query: this.currentQuery,
              type: "observerResultsUpdated"
            });
          }
        });
      }
    };
    function shouldLoadOnMount(query, options) {
      return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
    }
    function shouldFetchOnMount(query, options) {
      return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
    }
    function shouldFetchOn(query, options, field) {
      if (options.enabled !== false) {
        const value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
      }
      return false;
    }
    function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
      return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
    }
    function isStale(query, options) {
      return query.isStaleByTime(options.staleTime);
    }
    function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
      if (options.keepPreviousData) {
        return false;
      }
      if (options.placeholderData !== void 0) {
        return optimisticResult.isPlaceholderData;
      }
      if (!utils.shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
        return true;
      }
      return false;
    }
    exports.QueryObserver = QueryObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/queriesObserver.js
var require_queriesObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queriesObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var notifyManager = require_notifyManager();
    var queryObserver = require_queryObserver();
    var subscribable = require_subscribable();
    var QueriesObserver = class extends subscribable.Subscribable {
      constructor(client, queries) {
        super();
        this.client = client;
        this.queries = [];
        this.result = [];
        this.observers = [];
        this.observersMap = {};
        if (queries) {
          this.setQueries(queries);
        }
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.observers.forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
        }
      }
      onUnsubscribe() {
        if (!this.listeners.size) {
          this.destroy();
        }
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.observers.forEach((observer) => {
          observer.destroy();
        });
      }
      setQueries(queries, notifyOptions) {
        this.queries = queries;
        notifyManager.notifyManager.batch(() => {
          const prevObservers = this.observers;
          const newObserverMatches = this.findMatchingObservers(this.queries);
          newObserverMatches.forEach((match) => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));
          const newObservers = newObserverMatches.map((match) => match.observer);
          const newObserversMap = Object.fromEntries(newObservers.map((observer) => [observer.options.queryHash, observer]));
          const newResult = newObservers.map((observer) => observer.getCurrentResult());
          const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);
          if (prevObservers.length === newObservers.length && !hasIndexChange) {
            return;
          }
          this.observers = newObservers;
          this.observersMap = newObserversMap;
          this.result = newResult;
          if (!this.hasListeners()) {
            return;
          }
          utils.difference(prevObservers, newObservers).forEach((observer) => {
            observer.destroy();
          });
          utils.difference(newObservers, prevObservers).forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
          this.notify();
        });
      }
      getCurrentResult() {
        return this.result;
      }
      getQueries() {
        return this.observers.map((observer) => observer.getCurrentQuery());
      }
      getObservers() {
        return this.observers;
      }
      getOptimisticResult(queries) {
        return this.findMatchingObservers(queries).map((match) => match.observer.getOptimisticResult(match.defaultedQueryOptions));
      }
      findMatchingObservers(queries) {
        const prevObservers = this.observers;
        const prevObserversMap = new Map(prevObservers.map((observer) => [observer.options.queryHash, observer]));
        const defaultedQueryOptions = queries.map((options) => this.client.defaultQueryOptions(options));
        const matchingObservers = defaultedQueryOptions.flatMap((defaultedOptions) => {
          const match = prevObserversMap.get(defaultedOptions.queryHash);
          if (match != null) {
            return [{
              defaultedQueryOptions: defaultedOptions,
              observer: match
            }];
          }
          return [];
        });
        const matchedQueryHashes = new Set(matchingObservers.map((match) => match.defaultedQueryOptions.queryHash));
        const unmatchedQueries = defaultedQueryOptions.filter((defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash));
        const matchingObserversSet = new Set(matchingObservers.map((match) => match.observer));
        const unmatchedObservers = prevObservers.filter((prevObserver) => !matchingObserversSet.has(prevObserver));
        const getObserver = (options) => {
          const defaultedOptions = this.client.defaultQueryOptions(options);
          const currentObserver = this.observersMap[defaultedOptions.queryHash];
          return currentObserver != null ? currentObserver : new queryObserver.QueryObserver(this.client, defaultedOptions);
        };
        const newOrReusedObservers = unmatchedQueries.map((options, index) => {
          if (options.keepPreviousData) {
            const previouslyUsedObserver = unmatchedObservers[index];
            if (previouslyUsedObserver !== void 0) {
              return {
                defaultedQueryOptions: options,
                observer: previouslyUsedObserver
              };
            }
          }
          return {
            defaultedQueryOptions: options,
            observer: getObserver(options)
          };
        });
        const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);
        return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
      }
      onUpdate(observer, result) {
        const index = this.observers.indexOf(observer);
        if (index !== -1) {
          this.result = utils.replaceAt(this.result, index, result);
          this.notify();
        }
      }
      notify() {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.result);
          });
        });
      }
    };
    exports.QueriesObserver = QueriesObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.js
var require_infiniteQueryObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryObserver = require_queryObserver();
    var infiniteQueryBehavior = require_infiniteQueryBehavior();
    var InfiniteQueryObserver = class extends queryObserver.QueryObserver {
      // Type override
      // Type override
      // Type override
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(client, options) {
        super(client, options);
      }
      bindMethods() {
        super.bindMethods();
        this.fetchNextPage = this.fetchNextPage.bind(this);
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
      }
      setOptions(options, notifyOptions) {
        super.setOptions({
          ...options,
          behavior: infiniteQueryBehavior.infiniteQueryBehavior()
        }, notifyOptions);
      }
      getOptimisticResult(options) {
        options.behavior = infiniteQueryBehavior.infiniteQueryBehavior();
        return super.getOptimisticResult(options);
      }
      fetchNextPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "forward",
              pageParam
            }
          }
        });
      }
      fetchPreviousPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "backward",
              pageParam
            }
          }
        });
      }
      createResult(query, options) {
        var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;
        const {
          state
        } = query;
        const result = super.createResult(query, options);
        const {
          isFetching,
          isRefetching
        } = result;
        const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === "forward";
        const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === "backward";
        return {
          ...result,
          fetchNextPage: this.fetchNextPage,
          fetchPreviousPage: this.fetchPreviousPage,
          hasNextPage: infiniteQueryBehavior.hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
          hasPreviousPage: infiniteQueryBehavior.hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
          isFetchingNextPage,
          isFetchingPreviousPage,
          isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
        };
      }
    };
    exports.InfiniteQueryObserver = InfiniteQueryObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutationObserver.js
var require_mutationObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutationObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var mutation = require_mutation();
    var notifyManager = require_notifyManager();
    var subscribable = require_subscribable();
    var utils = require_utils();
    var MutationObserver = class extends subscribable.Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.setOptions(options);
        this.bindMethods();
        this.updateResult();
      }
      bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
      }
      setOptions(options) {
        var _this$currentMutation;
        const prevOptions = this.options;
        this.options = this.client.defaultMutationOptions(options);
        if (!utils.shallowEqualObjects(prevOptions, this.options)) {
          this.client.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.currentMutation,
            observer: this
          });
        }
        (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$currentMutation2;
          (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
        }
      }
      onMutationUpdate(action) {
        this.updateResult();
        const notifyOptions = {
          listeners: true
        };
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error") {
          notifyOptions.onError = true;
        }
        this.notify(notifyOptions);
      }
      getCurrentResult() {
        return this.currentResult;
      }
      reset() {
        this.currentMutation = void 0;
        this.updateResult();
        this.notify({
          listeners: true
        });
      }
      mutate(variables, options) {
        this.mutateOptions = options;
        if (this.currentMutation) {
          this.currentMutation.removeObserver(this);
        }
        this.currentMutation = this.client.getMutationCache().build(this.client, {
          ...this.options,
          variables: typeof variables !== "undefined" ? variables : this.options.variables
        });
        this.currentMutation.addObserver(this);
        return this.currentMutation.execute();
      }
      updateResult() {
        const state = this.currentMutation ? this.currentMutation.state : mutation.getDefaultState();
        const result = {
          ...state,
          isLoading: state.status === "loading",
          isSuccess: state.status === "success",
          isError: state.status === "error",
          isIdle: state.status === "idle",
          mutate: this.mutate,
          reset: this.reset
        };
        this.currentResult = result;
      }
      notify(options) {
        notifyManager.notifyManager.batch(() => {
          if (this.mutateOptions && this.hasListeners()) {
            if (options.onSuccess) {
              var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
              (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
            } else if (options.onError) {
              var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
              (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            }
          }
          if (options.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
        });
      }
    };
    exports.MutationObserver = MutationObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/hydration.js
var require_hydration = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/hydration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function dehydrateMutation(mutation) {
      return {
        mutationKey: mutation.options.mutationKey,
        state: mutation.state
      };
    }
    function dehydrateQuery(query) {
      return {
        state: query.state,
        queryKey: query.queryKey,
        queryHash: query.queryHash
      };
    }
    function defaultShouldDehydrateMutation(mutation) {
      return mutation.state.isPaused;
    }
    function defaultShouldDehydrateQuery(query) {
      return query.state.status === "success";
    }
    function dehydrate(client, options = {}) {
      const mutations = [];
      const queries = [];
      if (options.dehydrateMutations !== false) {
        const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;
        client.getMutationCache().getAll().forEach((mutation) => {
          if (shouldDehydrateMutation(mutation)) {
            mutations.push(dehydrateMutation(mutation));
          }
        });
      }
      if (options.dehydrateQueries !== false) {
        const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;
        client.getQueryCache().getAll().forEach((query) => {
          if (shouldDehydrateQuery(query)) {
            queries.push(dehydrateQuery(query));
          }
        });
      }
      return {
        mutations,
        queries
      };
    }
    function hydrate(client, dehydratedState, options) {
      if (typeof dehydratedState !== "object" || dehydratedState === null) {
        return;
      }
      const mutationCache = client.getMutationCache();
      const queryCache = client.getQueryCache();
      const mutations = dehydratedState.mutations || [];
      const queries = dehydratedState.queries || [];
      mutations.forEach((dehydratedMutation) => {
        var _options$defaultOptio;
        mutationCache.build(client, {
          ...options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations,
          mutationKey: dehydratedMutation.mutationKey
        }, dehydratedMutation.state);
      });
      queries.forEach((dehydratedQuery) => {
        var _options$defaultOptio2;
        const query = queryCache.get(dehydratedQuery.queryHash);
        const dehydratedQueryState = {
          ...dehydratedQuery.state,
          fetchStatus: "idle"
        };
        if (query) {
          if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {
            query.setState(dehydratedQueryState);
          }
          return;
        }
        queryCache.build(client, {
          ...options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries,
          queryKey: dehydratedQuery.queryKey,
          queryHash: dehydratedQuery.queryHash
        }, dehydratedQueryState);
      });
    }
    exports.defaultShouldDehydrateMutation = defaultShouldDehydrateMutation;
    exports.defaultShouldDehydrateQuery = defaultShouldDehydrateQuery;
    exports.dehydrate = dehydrate;
    exports.hydrate = hydrate;
  }
});

// node_modules/@tanstack/query-core/build/lib/index.js
var require_lib = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var retryer = require_retryer();
    var queryCache = require_queryCache();
    var queryClient = require_queryClient();
    var queryObserver = require_queryObserver();
    var queriesObserver = require_queriesObserver();
    var infiniteQueryObserver = require_infiniteQueryObserver();
    var mutationCache = require_mutationCache();
    var mutationObserver = require_mutationObserver();
    var notifyManager = require_notifyManager();
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var utils = require_utils();
    var hydration = require_hydration();
    var query = require_query();
    exports.CancelledError = retryer.CancelledError;
    exports.isCancelledError = retryer.isCancelledError;
    exports.QueryCache = queryCache.QueryCache;
    exports.QueryClient = queryClient.QueryClient;
    exports.QueryObserver = queryObserver.QueryObserver;
    exports.QueriesObserver = queriesObserver.QueriesObserver;
    exports.InfiniteQueryObserver = infiniteQueryObserver.InfiniteQueryObserver;
    exports.MutationCache = mutationCache.MutationCache;
    exports.MutationObserver = mutationObserver.MutationObserver;
    exports.notifyManager = notifyManager.notifyManager;
    exports.focusManager = focusManager.focusManager;
    exports.onlineManager = onlineManager.onlineManager;
    exports.hashQueryKey = utils.hashQueryKey;
    exports.isError = utils.isError;
    exports.isServer = utils.isServer;
    exports.matchQuery = utils.matchQuery;
    exports.parseFilterArgs = utils.parseFilterArgs;
    exports.parseMutationArgs = utils.parseMutationArgs;
    exports.parseMutationFilterArgs = utils.parseMutationFilterArgs;
    exports.parseQueryArgs = utils.parseQueryArgs;
    exports.replaceEqualDeep = utils.replaceEqualDeep;
    exports.defaultShouldDehydrateMutation = hydration.defaultShouldDehydrateMutation;
    exports.defaultShouldDehydrateQuery = hydration.defaultShouldDehydrateQuery;
    exports.dehydrate = hydration.dehydrate;
    exports.hydrate = hydration.hydrate;
    exports.Query = query.Query;
  }
});

// node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.js
var require_reactBatchedUpdates = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReactDOM = require_react_dom();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var ReactDOM__namespace = _interopNamespace(ReactDOM);
    var unstable_batchedUpdates = ReactDOM__namespace.unstable_batchedUpdates;
    exports.unstable_batchedUpdates = unstable_batchedUpdates;
  }
});

// node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.js
var require_setBatchUpdatesFn = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.js"() {
    "use strict";
    var queryCore = require_lib();
    var reactBatchedUpdates = require_reactBatchedUpdates();
    queryCore.notifyManager.setBatchNotifyFunction(reactBatchedUpdates.unstable_batchedUpdates);
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.js
var require_useSyncExternalStore = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_js = require_shim();
    var useSyncExternalStore = index_js.useSyncExternalStore;
    exports.useSyncExternalStore = useSyncExternalStore;
  }
});

// node_modules/@tanstack/react-query/build/lib/QueryClientProvider.js
var require_QueryClientProvider = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/QueryClientProvider.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var defaultContext = React__namespace.createContext(void 0);
    var QueryClientSharingContext = React__namespace.createContext(false);
    function getQueryClientContext(context, contextSharing) {
      if (context) {
        return context;
      }
      if (contextSharing && typeof window !== "undefined") {
        if (!window.ReactQueryClientContext) {
          window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
      }
      return defaultContext;
    }
    var useQueryClient = ({
      context
    } = {}) => {
      const queryClient = React__namespace.useContext(getQueryClientContext(context, React__namespace.useContext(QueryClientSharingContext)));
      if (!queryClient) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return queryClient;
    };
    var QueryClientProvider = ({
      client,
      children,
      context,
      contextSharing = false
    }) => {
      React__namespace.useEffect(() => {
        client.mount();
        return () => {
          client.unmount();
        };
      }, [client]);
      if (contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
      }
      const Context = getQueryClientContext(context, contextSharing);
      return React__namespace.createElement(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
      }, React__namespace.createElement(Context.Provider, {
        value: client
      }, children));
    };
    exports.QueryClientProvider = QueryClientProvider;
    exports.defaultContext = defaultContext;
    exports.useQueryClient = useQueryClient;
  }
});

// node_modules/@tanstack/react-query/build/lib/isRestoring.js
var require_isRestoring = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/isRestoring.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var IsRestoringContext = React__namespace.createContext(false);
    var useIsRestoring = () => React__namespace.useContext(IsRestoringContext);
    var IsRestoringProvider = IsRestoringContext.Provider;
    exports.IsRestoringProvider = IsRestoringProvider;
    exports.useIsRestoring = useIsRestoring;
  }
});

// node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.js
var require_QueryErrorResetBoundary = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function createValue() {
      let isReset = false;
      return {
        clearReset: () => {
          isReset = false;
        },
        reset: () => {
          isReset = true;
        },
        isReset: () => {
          return isReset;
        }
      };
    }
    var QueryErrorResetBoundaryContext = React__namespace.createContext(createValue());
    var useQueryErrorResetBoundary = () => React__namespace.useContext(QueryErrorResetBoundaryContext);
    var QueryErrorResetBoundary = ({
      children
    }) => {
      const [value] = React__namespace.useState(() => createValue());
      return React__namespace.createElement(QueryErrorResetBoundaryContext.Provider, {
        value
      }, typeof children === "function" ? children(value) : children);
    };
    exports.QueryErrorResetBoundary = QueryErrorResetBoundary;
    exports.useQueryErrorResetBoundary = useQueryErrorResetBoundary;
  }
});

// node_modules/@tanstack/react-query/build/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function shouldThrowError(_useErrorBoundary, params) {
      if (typeof _useErrorBoundary === "function") {
        return _useErrorBoundary(...params);
      }
      return !!_useErrorBoundary;
    }
    exports.shouldThrowError = shouldThrowError;
  }
});

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.js
var require_errorBoundaryUtils = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var utils = require_utils2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
      if (options.suspense || options.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    };
    var useClearResetErrorBoundary = (errorResetBoundary) => {
      React__namespace.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    };
    var getHasError = ({
      result,
      errorResetBoundary,
      useErrorBoundary,
      query
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && utils.shouldThrowError(useErrorBoundary, [result.error, query]);
    };
    exports.ensurePreventErrorBoundaryRetry = ensurePreventErrorBoundaryRetry;
    exports.getHasError = getHasError;
    exports.useClearResetErrorBoundary = useClearResetErrorBoundary;
  }
});

// node_modules/@tanstack/react-query/build/lib/suspense.js
var require_suspense = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/suspense.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ensureStaleTime = (defaultedOptions) => {
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
    };
    var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
    var shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
    var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
      data
    }) => {
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
    });
    exports.ensureStaleTime = ensureStaleTime;
    exports.fetchOptimistic = fetchOptimistic;
    exports.shouldSuspend = shouldSuspend;
    exports.willFetch = willFetch;
  }
});

// node_modules/@tanstack/react-query/build/lib/useQueries.js
var require_useQueries = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useQueries.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    var isRestoring = require_isRestoring();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var errorBoundaryUtils = require_errorBoundaryUtils();
    var suspense = require_suspense();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useQueries({
      queries,
      context
    }) {
      const queryClient = QueryClientProvider.useQueryClient({
        context
      });
      const isRestoring$1 = isRestoring.useIsRestoring();
      const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();
      const defaultedQueries = React__namespace.useMemo(() => queries.map((options) => {
        const defaultedOptions = queryClient.defaultQueryOptions(options);
        defaultedOptions._optimisticResults = isRestoring$1 ? "isRestoring" : "optimistic";
        return defaultedOptions;
      }), [queries, queryClient, isRestoring$1]);
      defaultedQueries.forEach((query) => {
        suspense.ensureStaleTime(query);
        errorBoundaryUtils.ensurePreventErrorBoundaryRetry(query, errorResetBoundary);
      });
      errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = React__namespace.useState(() => new queryCore.QueriesObserver(queryClient, defaultedQueries));
      const optimisticResult = observer.getOptimisticResult(defaultedQueries);
      useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => isRestoring$1 ? () => void 0 : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      React__namespace.useEffect(() => {
        observer.setQueries(defaultedQueries, {
          listeners: false
        });
      }, [defaultedQueries, observer]);
      const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => suspense.shouldSuspend(defaultedQueries[index], result, isRestoring$1));
      const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {
        const options = defaultedQueries[index];
        const queryObserver = observer.getObservers()[index];
        if (options && queryObserver) {
          if (suspense.shouldSuspend(options, result, isRestoring$1)) {
            return suspense.fetchOptimistic(options, queryObserver, errorResetBoundary);
          } else if (suspense.willFetch(result, isRestoring$1)) {
            void suspense.fetchOptimistic(options, queryObserver, errorResetBoundary);
          }
        }
        return [];
      }) : [];
      if (suspensePromises.length > 0) {
        throw Promise.all(suspensePromises);
      }
      const observerQueries = observer.getQueries();
      const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => {
        var _defaultedQueries$ind, _defaultedQueries$ind2;
        return errorBoundaryUtils.getHasError({
          result,
          errorResetBoundary,
          useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,
          query: observerQueries[index]
        });
      });
      if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {
        throw firstSingleResultWhichShouldThrow.error;
      }
      return optimisticResult;
    }
    exports.useQueries = useQueries;
  }
});

// node_modules/@tanstack/react-query/build/lib/useBaseQuery.js
var require_useBaseQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useBaseQuery.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var QueryClientProvider = require_QueryClientProvider();
    var isRestoring = require_isRestoring();
    var errorBoundaryUtils = require_errorBoundaryUtils();
    var suspense = require_suspense();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useBaseQuery(options, Observer) {
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const isRestoring$1 = isRestoring.useIsRestoring();
      const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();
      const defaultedOptions = queryClient.defaultQueryOptions(options);
      defaultedOptions._optimisticResults = isRestoring$1 ? "isRestoring" : "optimistic";
      if (defaultedOptions.onError) {
        defaultedOptions.onError = queryCore.notifyManager.batchCalls(defaultedOptions.onError);
      }
      if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = queryCore.notifyManager.batchCalls(defaultedOptions.onSuccess);
      }
      if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = queryCore.notifyManager.batchCalls(defaultedOptions.onSettled);
      }
      suspense.ensureStaleTime(defaultedOptions);
      errorBoundaryUtils.ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
      errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = React__namespace.useState(() => new Observer(queryClient, defaultedOptions));
      const result = observer.getOptimisticResult(defaultedOptions);
      useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => {
        const unsubscribe = isRestoring$1 ? () => void 0 : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      }, [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      React__namespace.useEffect(() => {
        observer.setOptions(defaultedOptions, {
          listeners: false
        });
      }, [defaultedOptions, observer]);
      if (suspense.shouldSuspend(defaultedOptions, result, isRestoring$1)) {
        throw suspense.fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
      }
      if (errorBoundaryUtils.getHasError({
        result,
        errorResetBoundary,
        useErrorBoundary: defaultedOptions.useErrorBoundary,
        query: observer.getCurrentQuery()
      })) {
        throw result.error;
      }
      return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
    }
    exports.useBaseQuery = useBaseQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/useQuery.js
var require_useQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useQuery.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryCore = require_lib();
    var useBaseQuery = require_useBaseQuery();
    function useQuery(arg1, arg2, arg3) {
      const parsedOptions = queryCore.parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery.useBaseQuery(parsedOptions, queryCore.QueryObserver);
    }
    exports.useQuery = useQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/Hydrate.js
var require_Hydrate = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/Hydrate.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useHydrate(state, options = {}) {
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const optionsRef = React__namespace.useRef(options);
      optionsRef.current = options;
      React__namespace.useMemo(() => {
        if (state) {
          queryCore.hydrate(queryClient, state, optionsRef.current);
        }
      }, [queryClient, state]);
    }
    var Hydrate = ({
      children,
      options,
      state
    }) => {
      useHydrate(state, options);
      return children;
    };
    exports.Hydrate = Hydrate;
    exports.useHydrate = useHydrate;
  }
});

// node_modules/@tanstack/react-query/build/lib/useIsFetching.js
var require_useIsFetching = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useIsFetching.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useIsFetching(arg1, arg2, arg3) {
      const [filters, options = {}] = queryCore.parseFilterArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const queryCache = queryClient.getQueryCache();
      return useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => queryCache.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [queryCache]), () => queryClient.isFetching(filters), () => queryClient.isFetching(filters));
    }
    exports.useIsFetching = useIsFetching;
  }
});

// node_modules/@tanstack/react-query/build/lib/useIsMutating.js
var require_useIsMutating = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useIsMutating.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useIsMutating(arg1, arg2, arg3) {
      const [filters, options = {}] = queryCore.parseMutationFilterArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const mutationCache = queryClient.getMutationCache();
      return useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => mutationCache.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [mutationCache]), () => queryClient.isMutating(filters), () => queryClient.isMutating(filters));
    }
    exports.useIsMutating = useIsMutating;
  }
});

// node_modules/@tanstack/react-query/build/lib/useMutation.js
var require_useMutation = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useMutation.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    var utils = require_utils2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    function useMutation(arg1, arg2, arg3) {
      const options = queryCore.parseMutationArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const [observer] = React__namespace.useState(() => new queryCore.MutationObserver(queryClient, options));
      React__namespace.useEffect(() => {
        observer.setOptions(options);
      }, [observer, options]);
      const result = useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      const mutate = React__namespace.useCallback((variables, mutateOptions) => {
        observer.mutate(variables, mutateOptions).catch(noop);
      }, [observer]);
      if (result.error && utils.shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
        throw result.error;
      }
      return {
        ...result,
        mutate,
        mutateAsync: result.mutate
      };
    }
    function noop() {
    }
    exports.useMutation = useMutation;
  }
});

// node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.js
var require_useInfiniteQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryCore = require_lib();
    var useBaseQuery = require_useBaseQuery();
    function useInfiniteQuery(arg1, arg2, arg3) {
      const options = queryCore.parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery.useBaseQuery(options, queryCore.InfiniteQueryObserver);
    }
    exports.useInfiniteQuery = useInfiniteQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_setBatchUpdatesFn();
    var queryCore = require_lib();
    var useQueries = require_useQueries();
    var useQuery = require_useQuery();
    var QueryClientProvider = require_QueryClientProvider();
    var Hydrate = require_Hydrate();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var useIsFetching = require_useIsFetching();
    var useIsMutating = require_useIsMutating();
    var useMutation = require_useMutation();
    var useInfiniteQuery = require_useInfiniteQuery();
    var isRestoring = require_isRestoring();
    exports.useQueries = useQueries.useQueries;
    exports.useQuery = useQuery.useQuery;
    exports.QueryClientProvider = QueryClientProvider.QueryClientProvider;
    exports.defaultContext = QueryClientProvider.defaultContext;
    exports.useQueryClient = QueryClientProvider.useQueryClient;
    exports.Hydrate = Hydrate.Hydrate;
    exports.useHydrate = Hydrate.useHydrate;
    exports.QueryErrorResetBoundary = QueryErrorResetBoundary.QueryErrorResetBoundary;
    exports.useQueryErrorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary;
    exports.useIsFetching = useIsFetching.useIsFetching;
    exports.useIsMutating = useIsMutating.useIsMutating;
    exports.useMutation = useMutation.useMutation;
    exports.useInfiniteQuery = useInfiniteQuery.useInfiniteQuery;
    exports.IsRestoringProvider = isRestoring.IsRestoringProvider;
    exports.useIsRestoring = isRestoring.useIsRestoring;
    Object.keys(queryCore).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return queryCore[k];
          }
        });
    });
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils3 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num2) {
      const hex = num2.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash3(hash4) {
      if (typeof hash4 !== "function" || typeof hash4.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash4.outputLen);
      number(hash4.blockLen);
    }
    exports.hash = hash3;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash: hash3, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils4 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils4();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take2 = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take2; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take2 = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
          this.posOut += take2;
          pos += take2;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils4();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take2 = Math.min(blockLen - this.pos, len - pos);
          if (take2 === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take2), this.pos);
          this.pos += take2;
          pos += take2;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils4();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num2, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num2 % modulo;
        num2 = num2 * num2 % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g2 = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g2, _1n << BigInt(r - m - 1));
          g2 = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g2);
          r = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map2, val) => {
        map2[val] = "function";
        return map2;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num2, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num2;
      let p = f.ONE;
      let d = num2;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num2);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num2);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num2) => mod(num2, ORDER),
        isValid: (num2) => {
          if (typeof num2 !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
          return _0n <= num2 && num2 < ORDER;
        },
        is0: (num2) => num2 === _0n,
        isOdd: (num2) => (num2 & _1n) === _1n,
        neg: (num2) => mod(-num2, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num2) => mod(num2 * num2, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num2, power) => FpPow(f, num2, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num2) => num2 * num2,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num2) => invert(num2, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash3, groupOrder, isLE = false) {
      hash3 = (0, utils_js_1.ensureBytes)("privateHash", hash3);
      const hashLen = hash3.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash3) : (0, utils_js_1.bytesToNumberBE)(hash3);
      return mod(num2, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num2, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField;
  }
});

// node_modules/@noble/curves/abstract/poseidon.js
var require_poseidon = __commonJS({
  "node_modules/@noble/curves/abstract/poseidon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poseidon = exports.splitConstants = exports.validateOpts = void 0;
    var modular_js_1 = require_modular();
    function validateOpts(opts) {
      const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
      const { roundsFull, roundsPartial, sboxPower, t } = opts;
      (0, modular_js_1.validateField)(Fp);
      for (const i of ["t", "roundsFull", "roundsPartial"]) {
        if (typeof opts[i] !== "number" || !Number.isSafeInteger(opts[i]))
          throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
      }
      if (!Array.isArray(mds) || mds.length !== t)
        throw new Error("Poseidon: wrong MDS matrix");
      const _mds = mds.map((mdsRow) => {
        if (!Array.isArray(mdsRow) || mdsRow.length !== t)
          throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
        return mdsRow.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon MDS matrix value=${i}`);
          return Fp.create(i);
        });
      });
      if (rev !== void 0 && typeof rev !== "boolean")
        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
      if (roundsFull % 2 !== 0)
        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
      const rounds = roundsFull + roundsPartial;
      if (!Array.isArray(rc) || rc.length !== rounds)
        throw new Error("Poseidon: wrong round constants");
      const roundConstants = rc.map((rc2) => {
        if (!Array.isArray(rc2) || rc2.length !== t)
          throw new Error(`Poseidon wrong round constants: ${rc2}`);
        return rc2.map((i) => {
          if (typeof i !== "bigint" || !Fp.isValid(i))
            throw new Error(`Poseidon wrong round constant=${i}`);
          return Fp.create(i);
        });
      });
      if (!sboxPower || ![3, 5, 7].includes(sboxPower))
        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
      const _sboxPower = BigInt(sboxPower);
      let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
      if (sboxPower === 3)
        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
      else if (sboxPower === 5)
        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
      return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
    }
    exports.validateOpts = validateOpts;
    function splitConstants(rc, t) {
      if (typeof t !== "number")
        throw new Error("poseidonSplitConstants: wrong t");
      if (!Array.isArray(rc) || rc.length % t)
        throw new Error("poseidonSplitConstants: wrong rc");
      const res = [];
      let tmp = [];
      for (let i = 0; i < rc.length; i++) {
        tmp.push(rc[i]);
        if (tmp.length === t) {
          res.push(tmp);
          tmp = [];
        }
      }
      return res;
    }
    exports.splitConstants = splitConstants;
    function poseidon(opts) {
      const _opts = validateOpts(opts);
      const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
      const halfRoundsFull = _opts.roundsFull / 2;
      const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
      const poseidonRound = (values2, isFull, idx) => {
        values2 = values2.map((i, j) => Fp.add(i, roundConstants[idx][j]));
        if (isFull)
          values2 = values2.map((i) => sboxFn(i));
        else
          values2[partialIdx] = sboxFn(values2[partialIdx]);
        values2 = mds.map((i) => i.reduce((acc, i2, j) => Fp.add(acc, Fp.mulN(i2, values2[j])), Fp.ZERO));
        return values2;
      };
      const poseidonHash = function poseidonHash2(values2) {
        if (!Array.isArray(values2) || values2.length !== t)
          throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
        values2 = values2.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
          return Fp.create(i);
        });
        let round = 0;
        for (let i = 0; i < halfRoundsFull; i++)
          values2 = poseidonRound(values2, true, round++);
        for (let i = 0; i < roundsPartial; i++)
          values2 = poseidonRound(values2, false, round++);
        for (let i = 0; i < halfRoundsFull; i++)
          values2 = poseidonRound(values2, true, round++);
        if (round !== rounds)
          throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);
        return values2;
      };
      poseidonHash.roundConstants = roundConstants;
      return poseidonHash;
    }
    exports.poseidon = poseidon;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg2 = item.negate();
        return condition ? neg2 : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils3();
    var utils_js_1 = require_utils3();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice3 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num2) => {
          const hex = num2.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice3(h(sig.s));
        const r = slice3(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num2) {
        return typeof num2 === "bigint" && _0n < num2 && num2 < CURVE.n;
      }
      function assertGE(num2) {
        if (!isWithinCurveOrder(num2))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num2;
        try {
          num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num2 = mod.mod(num2, n);
        assertGE(num2);
        return num2;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num2) {
        return _0n < num2 && num2 < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num2 = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num2 >> BigInt(delta) : num2;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num2) {
        if (typeof num2 !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num2 && num2 < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num2, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash3, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash3(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is2 = invN(s);
        const u1 = modN(h * is2);
        const u2 = modN(r * is2);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils4();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash3, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash3);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash3.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash3.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash3, key) => new HMAC(hash3, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils4();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash3) {
      return {
        hash: hash3,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash3, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash3) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash3) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@scure/starknet/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@scure/starknet/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.keccak = exports.computeHashOnElements = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = exports.MAX_VALUE = void 0;
    var sha3_1 = require_sha3();
    var sha256_1 = require_sha256();
    var utils_1 = require_utils4();
    var modular_1 = require_modular();
    var poseidon_1 = require_poseidon();
    var weierstrass_1 = require_weierstrass();
    var u = require_utils3();
    var _shortw_utils_1 = require_shortw_utils();
    var CURVE_ORDER = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583");
    exports.MAX_VALUE = BigInt("0x800000000000000000000000000000000000000000000000000000000000000");
    var nBitLength = 252;
    function bits2int(bytes) {
      while (bytes[0] === 0)
        bytes = bytes.subarray(1);
      const delta = bytes.length * 8 - nBitLength;
      const num2 = u.bytesToNumberBE(bytes);
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    }
    function hex0xToBytes(hex) {
      if (typeof hex === "string") {
        hex = strip0x(hex);
        if (hex.length & 1)
          hex = "0" + hex;
      }
      return u.hexToBytes(hex);
    }
    var curve = (0, weierstrass_1.weierstrass)({
      a: BigInt(1),
      b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
      Fp: (0, modular_1.Field)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
      n: CURVE_ORDER,
      nBitLength,
      Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
      Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
      h: BigInt(1),
      lowS: false,
      ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),
      bits2int,
      bits2int_modN: (bytes) => {
        const hex = u.bytesToNumberBE(bytes).toString(16);
        if (hex.length === 63)
          bytes = hex0xToBytes(hex + "0");
        return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);
      }
    });
    exports._starkCurve = curve;
    function ensureBytes(hex) {
      return u.ensureBytes("", typeof hex === "string" ? hex0xToBytes(hex) : hex);
    }
    function normPrivKey(privKey) {
      return u.bytesToHex(ensureBytes(privKey)).padStart(64, "0");
    }
    function getPublicKey(privKey, isCompressed = false) {
      return curve.getPublicKey(normPrivKey(privKey), isCompressed);
    }
    exports.getPublicKey = getPublicKey;
    function getSharedSecret(privKeyA, pubKeyB) {
      return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);
    }
    exports.getSharedSecret = getSharedSecret;
    function checkSignature(signature) {
      const { r, s } = signature;
      if (r < 0n || r >= exports.MAX_VALUE)
        throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);
      const w = (0, modular_1.invert)(s, CURVE_ORDER);
      if (w < 0n || w >= exports.MAX_VALUE)
        throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`);
    }
    function checkMessage(msgHash) {
      const bytes = ensureBytes(msgHash);
      const num2 = u.bytesToNumberBE(bytes);
      if (num2 >= exports.MAX_VALUE)
        throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);
      return bytes;
    }
    function sign(msgHash, privKey, opts) {
      const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);
      checkSignature(sig);
      return sig;
    }
    exports.sign = sign;
    function verify(signature, msgHash, pubKey) {
      if (!(signature instanceof Signature)) {
        const bytes = ensureBytes(signature);
        try {
          signature = Signature.fromDER(bytes);
        } catch (derError) {
          if (!(derError instanceof weierstrass_1.DER.Err))
            throw derError;
          signature = Signature.fromCompact(bytes);
        }
      }
      checkSignature(signature);
      return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));
    }
    exports.verify = verify;
    var { CURVE, ProjectivePoint, Signature, utils } = curve;
    exports.CURVE = CURVE;
    exports.ProjectivePoint = ProjectivePoint;
    exports.Signature = Signature;
    exports.utils = utils;
    function extractX(bytes) {
      const hex = u.bytesToHex(bytes.subarray(1));
      const stripped = hex.replace(/^0+/gm, "");
      return `0x${stripped}`;
    }
    function strip0x(hex) {
      return hex.replace(/^0x/i, "");
    }
    function grindKey(seed) {
      const _seed = ensureBytes(seed);
      const sha256mask = 2n ** 256n;
      const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);
      for (let i = 0; ; i++) {
        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));
        if (key < limit)
          return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);
        if (i === 1e5)
          throw new Error("grindKey is broken: tried 100k vals");
      }
    }
    exports.grindKey = grindKey;
    function getStarkKey(privateKey) {
      return extractX(getPublicKey(privateKey, true));
    }
    exports.getStarkKey = getStarkKey;
    function ethSigToPrivate(signature) {
      signature = strip0x(signature);
      if (signature.length !== 130)
        throw new Error("Wrong ethereum signature");
      return grindKey(signature.substring(0, 64));
    }
    exports.ethSigToPrivate = ethSigToPrivate;
    var MASK_31 = 2n ** 31n - 1n;
    var int31 = (n) => Number(n & MASK_31);
    function getAccountPath(layer, application, ethereumAddress, index) {
      const layerNum = int31(sha256Num(layer));
      const applicationNum = int31(sha256Num(application));
      const eth = u.hexToNumber(strip0x(ethereumAddress));
      return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;
    }
    exports.getAccountPath = getAccountPath;
    var PEDERSEN_POINTS = [
      new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
      new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
      new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
      new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
      new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
    ];
    function pedersenPrecompute(p1, p2) {
      const out = [];
      let p = p1;
      for (let i = 0; i < 248; i++) {
        out.push(p);
        p = p.double();
      }
      p = p2;
      for (let i = 0; i < 4; i++) {
        out.push(p);
        p = p.double();
      }
      return out;
    }
    var PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);
    var PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);
    function pedersenArg(arg) {
      let value;
      if (typeof arg === "bigint") {
        value = arg;
      } else if (typeof arg === "number") {
        if (!Number.isSafeInteger(arg))
          throw new Error(`Invalid pedersenArg: ${arg}`);
        value = BigInt(arg);
      } else {
        value = u.bytesToNumberBE(ensureBytes(arg));
      }
      if (!(0n <= value && value < curve.CURVE.Fp.ORDER))
        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);
      return value;
    }
    function pedersenSingle(point, value, constants2) {
      let x = pedersenArg(value);
      for (let j = 0; j < 252; j++) {
        const pt = constants2[j];
        if (pt.equals(point))
          throw new Error("Same point");
        if ((x & 1n) !== 0n)
          point = point.add(pt);
        x >>= 1n;
      }
      return point;
    }
    function pedersen(x, y) {
      let point = PEDERSEN_POINTS[0];
      point = pedersenSingle(point, x, PEDERSEN_POINTS1);
      point = pedersenSingle(point, y, PEDERSEN_POINTS2);
      return extractX(point.toRawBytes(true));
    }
    exports.pedersen = pedersen;
    var computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));
    exports.computeHashOnElements = computeHashOnElements;
    var MASK_250 = u.bitMask(250);
    var keccak = (data) => u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;
    exports.keccak = keccak;
    var sha256Num = (data) => u.bytesToNumberBE((0, sha256_1.sha256)(data));
    exports.Fp251 = (0, modular_1.Field)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
    function poseidonRoundConstant(Fp, name, idx) {
      const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));
      return Fp.create(val);
    }
    function _poseidonMDS(Fp, name, m, attempt = 0) {
      const x_values = [];
      const y_values = [];
      for (let i = 0; i < m; i++) {
        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));
        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));
      }
      if ((/* @__PURE__ */ new Set([...x_values, ...y_values])).size !== 2 * m)
        throw new Error("X and Y values are not distinct");
      return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));
    }
    exports._poseidonMDS = _poseidonMDS;
    var MDS_SMALL = [
      [3, 1, 1],
      [1, -1, 1],
      [1, 1, -2]
    ].map((i) => i.map(BigInt));
    function poseidonBasic(opts, mds) {
      (0, modular_1.validateField)(opts.Fp);
      if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))
        throw new Error(`Wrong poseidon opts: ${opts}`);
      const m = opts.rate + opts.capacity;
      const rounds = opts.roundsFull + opts.roundsPartial;
      const roundConstants = [];
      for (let i = 0; i < rounds; i++) {
        const row = [];
        for (let j = 0; j < m; j++)
          row.push(poseidonRoundConstant(opts.Fp, "Hades", m * i + j));
        roundConstants.push(row);
      }
      const res = (0, poseidon_1.poseidon)({
        ...opts,
        t: m,
        sboxPower: 3,
        reversePartialPowIdx: true,
        mds,
        roundConstants
      });
      res.m = m;
      res.rate = opts.rate;
      res.capacity = opts.capacity;
      return res;
    }
    exports.poseidonBasic = poseidonBasic;
    function poseidonCreate(opts, mdsAttempt = 0) {
      const m = opts.rate + opts.capacity;
      if (!Number.isSafeInteger(mdsAttempt))
        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);
      return poseidonBasic(opts, _poseidonMDS(opts.Fp, "HadesMDS", m, mdsAttempt));
    }
    exports.poseidonCreate = poseidonCreate;
    exports.poseidonSmall = poseidonBasic({ Fp: exports.Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);
    function poseidonHash(x, y, fn = exports.poseidonSmall) {
      return fn([x, y, 2n])[0];
    }
    exports.poseidonHash = poseidonHash;
    function poseidonHashFunc(x, y, fn = exports.poseidonSmall) {
      return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));
    }
    exports.poseidonHashFunc = poseidonHashFunc;
    function poseidonHashSingle(x, fn = exports.poseidonSmall) {
      return fn([x, 0n, 1n])[0];
    }
    exports.poseidonHashSingle = poseidonHashSingle;
    function poseidonHashMany(values2, fn = exports.poseidonSmall) {
      const { m, rate } = fn;
      if (!Array.isArray(values2))
        throw new Error("bigint array expected in values");
      const padded = Array.from(values2);
      padded.push(1n);
      while (padded.length % rate !== 0)
        padded.push(0n);
      let state = new Array(m).fill(0n);
      for (let i = 0; i < padded.length; i += rate) {
        for (let j = 0; j < rate; j++)
          state[j] += padded[i + j];
        state = fn(state);
      }
      return state[0];
    }
    exports.poseidonHashMany = poseidonHashMany;
  }
});

// node_modules/lossless-json/lib/umd/lossless-json.js
var require_lossless_json = __commonJS({
  "node_modules/lossless-json/lib/umd/lossless-json.js"(exports, module) {
    !function(t, r) {
      "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((t = "undefined" != typeof globalThis ? globalThis : t || self).LosslessJSON = {});
    }(exports, function(t) {
      "use strict";
      function r(t2) {
        return n.test(t2);
      }
      var n = /^-?[0-9]+$/;
      function e(t2) {
        return o.test(t2);
      }
      var o = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
      function i(t2, n2) {
        var e2 = parseFloat(t2), o2 = String(e2), i2 = u(t2), a2 = u(o2);
        if (i2 === a2)
          return true;
        if (true === (null == n2 ? void 0 : n2.approx)) {
          if (!r(t2) && a2.length >= 14 && i2.startsWith(a2.substring(0, 14)))
            return true;
        }
        return false;
      }
      var a = function(t2) {
        return t2.underflow = "underflow", t2.overflow = "overflow", t2.truncate_integer = "truncate_integer", t2.truncate_float = "truncate_float", t2;
      }({});
      function c(t2) {
        if (!i(t2, { approx: false })) {
          if (r(t2))
            return a.truncate_integer;
          var n2 = parseFloat(t2);
          return isFinite(n2) ? 0 === n2 ? a.underflow : a.truncate_float : a.overflow;
        }
      }
      function u(t2) {
        return t2.replace(f, "").replace(s, "").replace(y, "").replace(l, "");
      }
      var f = /[eE][+-]?\d+$/, l = /^-?(0*)?/, s = /\./, y = /0+$/;
      function d(t2) {
        return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, d(t2);
      }
      function p(t2, r2) {
        for (var n2 = 0; n2 < r2.length; n2++) {
          var e2 = r2[n2];
          e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(t2, v(e2.key), e2);
        }
      }
      function v(t2) {
        var r2 = function(t3, r3) {
          if ("object" !== d(t3) || null === t3)
            return t3;
          var n2 = t3[Symbol.toPrimitive];
          if (void 0 !== n2) {
            var e2 = n2.call(t3, r3 || "default");
            if ("object" !== d(e2))
              return e2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r3 ? String : Number)(t3);
        }(t2, "string");
        return "symbol" === d(r2) ? r2 : String(r2);
      }
      var b = function() {
        function t2(r2) {
          if (function(t3, r3) {
            if (!(t3 instanceof r3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t2), function(t3, r3, n3) {
            (r3 = v(r3)) in t3 ? Object.defineProperty(t3, r3, { value: n3, enumerable: true, configurable: true, writable: true }) : t3[r3] = n3;
          }(this, "isLosslessNumber", true), !e(r2))
            throw new Error('Invalid number (value: "' + r2 + '")');
          this.value = r2;
        }
        var n2, o2, i2;
        return n2 = t2, (o2 = [{ key: "valueOf", value: function() {
          var t3 = c(this.value);
          if (void 0 === t3 || t3 === a.truncate_float)
            return parseFloat(this.value);
          if (r(this.value))
            return BigInt(this.value);
          throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(t3, " and become ").concat(parseFloat(this.value)));
        } }, { key: "toString", value: function() {
          return this.value;
        } }]) && p(n2.prototype, o2), i2 && p(n2, i2), Object.defineProperty(n2, "prototype", { writable: false }), t2;
      }();
      function h(t2) {
        return t2 && "object" === d(t2) && true === t2.isLosslessNumber || false;
      }
      function m(t2) {
        return new b(t2);
      }
      function w(t2) {
        return w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, w(t2);
      }
      function g2(t2, r2, n2, e2) {
        return Array.isArray(n2) ? e2.call(t2, r2, function(t3, r3) {
          for (var n3 = 0; n3 < t3.length; n3++)
            t3[n3] = g2(t3, n3 + "", t3[n3], r3);
          return t3;
        }(n2, e2)) : n2 && "object" === w(n2) && !h(n2) ? e2.call(t2, r2, function(t3, r3) {
          return Object.keys(t3).forEach(function(n3) {
            var e3 = g2(t3, n3, t3[n3], r3);
            void 0 !== e3 ? t3[n3] = e3 : delete t3[n3];
          }), t3;
        }(n2, e2)) : e2.call(t2, r2, n2);
      }
      function S(t2) {
        return S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, S(t2);
      }
      function A(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return C(t3);
        }(t2) || function(t3) {
          if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
            return Array.from(t3);
        }(t2) || function(t3, r2) {
          if (!t3)
            return;
          if ("string" == typeof t3)
            return C(t3, r2);
          var n2 = Object.prototype.toString.call(t3).slice(8, -1);
          "Object" === n2 && t3.constructor && (n2 = t3.constructor.name);
          if ("Map" === n2 || "Set" === n2)
            return Array.from(t3);
          if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return C(t3, r2);
        }(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function C(t2, r2) {
        (null == r2 || r2 > t2.length) && (r2 = t2.length);
        for (var n2 = 0, e2 = new Array(r2); n2 < r2; n2++)
          e2[n2] = t2[n2];
        return e2;
      }
      function x(t2) {
        return t2 >= U && t2 <= M || t2 >= z && t2 <= V || t2 >= G && t2 <= X;
      }
      function E(t2) {
        return t2 >= U && t2 <= M;
      }
      function N(t2, r2) {
        return t2 === r2 || (Array.isArray(t2) && Array.isArray(r2) ? t2.length === r2.length && t2.every(function(t3, n2) {
          return N(t3, r2[n2]);
        }) : !(!j(t2) || !j(r2)) && A(new Set([].concat(A(Object.keys(t2)), A(Object.keys(r2))))).every(function(n2) {
          return N(t2[n2], r2[n2]);
        }));
      }
      function j(t2) {
        return "object" === S(t2) && null !== t2;
      }
      var O = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" }, I = 92, k = 123, _ = 125, F = 91, J = 93, L = 32, T = 10, $ = 9, P = 13, B = 34, D = 43, R = 45, U = 48, Q = 49, M = 57, W = 44, Z = 46, q = 58, z = 65, G = 97, H = 69, K = 101, V = 70, X = 102;
      function Y(t2) {
        return Y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, Y(t2);
      }
      var tt = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
      t.LosslessNumber = b, t.UnsafeNumberReason = a, t.config = function(t2) {
        throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.");
      }, t.getUnsafeNumberReason = c, t.isInteger = r, t.isLosslessNumber = h, t.isNumber = e, t.isSafeNumber = i, t.parse = function(t2, r2) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m, e2 = 0, o2 = c2();
        return function(t3) {
          if (void 0 === t3)
            throw new SyntaxError("JSON value expected ".concat(j2()));
        }(o2), function() {
          if (e2 < t2.length)
            throw new SyntaxError("Expected end of input ".concat(j2()));
        }(), r2 ? function(t3, r3) {
          return g2({ "": t3 }, "", t3, r3);
        }(o2, r2) : o2;
        function i2() {
          if (t2.charCodeAt(e2) === k) {
            e2++, f2();
            for (var r3 = {}, n3 = true; e2 < t2.length && t2.charCodeAt(e2) !== _; ) {
              n3 ? n3 = false : (s2(), f2());
              var o3 = e2, i3 = l2();
              void 0 === i3 && v2(), f2(), y2();
              var a3 = c2();
              void 0 === a3 && S2(), Object.prototype.hasOwnProperty.call(r3, i3) && !N(a3, r3[i3]) && b2(i3, o3 + 1), r3[i3] = a3;
            }
            return t2.charCodeAt(e2) !== _ && function() {
              throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(j2()));
            }(), e2++, r3;
          }
        }
        function a2() {
          if (t2.charCodeAt(e2) === F) {
            e2++, f2();
            for (var r3 = [], n3 = true; e2 < t2.length && t2.charCodeAt(e2) !== J; ) {
              n3 ? n3 = false : s2();
              var o3 = c2();
              d2(o3), r3.push(o3);
            }
            return t2.charCodeAt(e2) !== J && function() {
              throw new SyntaxError("Array item or end of array ']' expected ".concat(j2()));
            }(), e2++, r3;
          }
        }
        function c2() {
          var r3, o3, c3, s3, y3, d3;
          f2();
          var v3 = null !== (r3 = null !== (o3 = null !== (c3 = null !== (s3 = null !== (y3 = null !== (d3 = l2()) && void 0 !== d3 ? d3 : function() {
            var r4 = e2;
            t2.charCodeAt(e2) === R && (e2++, p2(r4));
            if (t2.charCodeAt(e2) === U)
              e2++;
            else if (o4 = t2.charCodeAt(e2), o4 >= Q && o4 <= M)
              for (e2++; E(t2.charCodeAt(e2)); )
                e2++;
            var o4;
            if (t2.charCodeAt(e2) === Z)
              for (e2++, p2(r4); E(t2.charCodeAt(e2)); )
                e2++;
            if (t2.charCodeAt(e2) === K || t2.charCodeAt(e2) === H)
              for (e2++, t2.charCodeAt(e2) !== R && t2.charCodeAt(e2) !== D || e2++, p2(r4); E(t2.charCodeAt(e2)); )
                e2++;
            if (e2 > r4)
              return n2(t2.slice(r4, e2));
          }()) && void 0 !== y3 ? y3 : i2()) && void 0 !== s3 ? s3 : a2()) && void 0 !== c3 ? c3 : u2("true", true)) && void 0 !== o3 ? o3 : u2("false", false)) && void 0 !== r3 ? r3 : u2("null", null);
          return f2(), v3;
        }
        function u2(r3, n3) {
          if (t2.slice(e2, e2 + r3.length) === r3)
            return e2 += r3.length, n3;
        }
        function f2() {
          for (; (r3 = t2.charCodeAt(e2)) === L || r3 === T || r3 === $ || r3 === P; )
            e2++;
          var r3;
        }
        function l2() {
          if (t2.charCodeAt(e2) === B) {
            e2++;
            for (var r3 = ""; e2 < t2.length && t2.charCodeAt(e2) !== B; ) {
              if (t2.charCodeAt(e2) === I) {
                var n3 = t2[e2 + 1], o3 = O[n3];
                void 0 !== o3 ? (r3 += o3, e2++) : "u" === n3 ? x(t2.charCodeAt(e2 + 2)) && x(t2.charCodeAt(e2 + 3)) && x(t2.charCodeAt(e2 + 4)) && x(t2.charCodeAt(e2 + 5)) ? (r3 += String.fromCharCode(parseInt(t2.slice(e2 + 2, e2 + 6), 16)), e2 += 5) : A2(e2) : w2(e2);
              } else
                (i3 = t2.charCodeAt(e2)) >= 32 && i3 <= 1114111 ? r3 += t2[e2] : h2(t2[e2]);
              e2++;
            }
            return function() {
              if (t2.charCodeAt(e2) !== B)
                throw new SyntaxError(`End of string '"' expected `.concat(j2()));
            }(), e2++, r3;
          }
          var i3;
        }
        function s2() {
          if (t2.charCodeAt(e2) !== W)
            throw new SyntaxError("Comma ',' expected after value ".concat(j2()));
          e2++;
        }
        function y2() {
          if (t2.charCodeAt(e2) !== q)
            throw new SyntaxError("Colon ':' expected after property name ".concat(j2()));
          e2++;
        }
        function d2(t3) {
          if (void 0 === t3)
            throw new SyntaxError("Array item expected ".concat(j2()));
        }
        function p2(r3) {
          if (!E(t2.charCodeAt(e2))) {
            var n3 = t2.slice(r3, e2);
            throw new SyntaxError("Invalid number '".concat(n3, "', expecting a digit ").concat(j2()));
          }
        }
        function v2() {
          throw new SyntaxError("Quoted object key expected ".concat(j2()));
        }
        function b2(t3, r3) {
          throw new SyntaxError("Duplicate key '".concat(t3, "' encountered at position ").concat(r3));
        }
        function h2(t3) {
          throw new SyntaxError("Invalid character '".concat(t3, "' ").concat(C2()));
        }
        function w2(r3) {
          var n3 = t2.slice(r3, r3 + 2);
          throw new SyntaxError("Invalid escape character '".concat(n3, "' ").concat(C2()));
        }
        function S2() {
          throw new SyntaxError("Object value expected after ':' ".concat(C2()));
        }
        function A2(r3) {
          for (var n3 = r3 + 2; /\w/.test(t2[n3]); )
            n3++;
          var e3 = t2.slice(r3, n3);
          throw new SyntaxError("Invalid unicode character '".concat(e3, "' ").concat(C2()));
        }
        function C2() {
          return "at position ".concat(e2);
        }
        function j2() {
          return (e2 < t2.length ? "but got '".concat(t2[e2], "'") : "but reached end of input") + " " + C2();
        }
      }, t.parseLosslessNumber = m, t.parseNumberAndBigInt = function(t2) {
        return r(t2) ? BigInt(t2) : parseFloat(t2);
      }, t.reviveDate = function(t2, r2) {
        return "string" == typeof r2 && tt.test(r2) ? new Date(r2) : r2;
      }, t.stringify = function t2(r2, n2, o2, i2) {
        var a2 = function(t3) {
          if ("number" == typeof t3)
            return " ".repeat(t3);
          if ("string" == typeof t3 && "" !== t3)
            return t3;
          return;
        }(o2);
        return c2("function" == typeof n2 ? n2.call({ "": r2 }, "", r2) : r2, "");
        function c2(r3, u2) {
          if (Array.isArray(i2)) {
            var f2 = i2.find(function(t3) {
              return t3.test(r3);
            });
            if (f2) {
              var l2 = f2.stringify(r3);
              if ("string" != typeof l2 || !e(l2))
                throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(l2, ")"));
              return l2;
            }
          }
          return "boolean" == typeof r3 || "number" == typeof r3 || "string" == typeof r3 || null === r3 || r3 instanceof Date || r3 instanceof Boolean || r3 instanceof Number || r3 instanceof String ? JSON.stringify(r3) : r3 && r3.isLosslessNumber || "bigint" == typeof r3 ? r3.toString() : Array.isArray(r3) ? function(t3, r4) {
            if (0 === t3.length)
              return "[]";
            for (var e2 = a2 ? r4 + a2 : void 0, o3 = a2 ? "[\n" : "[", i3 = 0; i3 < t3.length; i3++) {
              var u3 = "function" == typeof n2 ? n2.call(t3, String(i3), t3[i3]) : t3[i3];
              a2 && (o3 += e2), o3 += void 0 !== u3 && "function" != typeof u3 ? c2(u3, e2) : "null", i3 < t3.length - 1 && (o3 += a2 ? ",\n" : ",");
            }
            return o3 += a2 ? "\n" + r4 + "]" : "]", o3;
          }(r3, u2) : r3 && "object" === Y(r3) ? function(r4, e2) {
            if ("function" == typeof r4.toJSON)
              return t2(r4.toJSON(), n2, o2, void 0);
            var i3 = Array.isArray(n2) ? n2.map(String) : Object.keys(r4);
            if (0 === i3.length)
              return "{}";
            var u3 = a2 ? e2 + a2 : void 0, f3 = true, l3 = a2 ? "{\n" : "{";
            return i3.forEach(function(t3) {
              var e3 = "function" == typeof n2 ? n2.call(r4, t3, r4[t3]) : r4[t3];
              if (function(t4, r5) {
                return void 0 !== r5 && "function" != typeof r5 && "symbol" !== Y(r5);
              }(0, e3)) {
                f3 ? f3 = false : l3 += a2 ? ",\n" : ",";
                var o3 = JSON.stringify(t3);
                l3 += a2 ? u3 + o3 + ": " : o3 + ":", l3 += c2(e3, u3);
              }
            }), l3 += a2 ? "\n" + e2 + "}" : "}", l3;
          }(r3, u2) : void 0;
        }
      }, t.toLosslessNumber = function(t2) {
        if (u(t2 + "").length > 15)
          throw new Error("Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself " + "(value: ".concat(t2, ")"));
        if (isNaN(t2))
          throw new Error("Invalid number: NaN");
        if (!isFinite(t2))
          throw new Error("Invalid number: " + t2);
        return new b(String(t2));
      }, t.toSafeNumberOrThrow = function(t2, r2) {
        var n2 = parseFloat(t2), e2 = c(t2);
        if (true === (null == r2 ? void 0 : r2.approx) ? e2 && e2 !== a.truncate_float : e2) {
          var o2 = e2.replace(/_\w+$/, "");
          throw new Error("Cannot safely convert to number: " + "the value '".concat(t2, "' would ").concat(o2, " and become ").concat(n2));
        }
        return n2;
      };
    });
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          s.bl_tree[curlen * 2] += count2;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count2 <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count2 = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count2 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count2--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count2 - 3, 2);
        } else if (count2 <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count2 - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count2 - 11, 7);
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last3) => {
      send_bits(s, (STORED_BLOCK << 1) + (last3 ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last3) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last3);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last3 ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last3 ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last3) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last3) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last3);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last3 = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last3 = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last3);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last3 === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last3) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last3 = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last3);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last3 ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max2) => {
      const len = max2 || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max2));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max2) => {
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      let pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString5 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString5.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString5.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last3;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last3 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last3 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min2 = 0, max2 = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count2 = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count2[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count2[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count2[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count2[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count2[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count2[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count2[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count2[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE2 = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE2;
            case DONE2:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString5 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString5.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString5.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants2 = require_constants();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants2;
  }
});

// node_modules/whatwg-fetch/fetch.js
var fetch_exports = {};
__export(fetch_exports, {
  DOMException: () => DOMException,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  fetch: () => fetch
});
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.startsWith("file://") && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
var g, support, viewClasses, isArrayBufferView, methods, redirectStatuses, DOMException;
var init_fetch = __esm({
  "node_modules/whatwg-fetch/fetch.js"() {
    g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
    typeof global !== "undefined" && global || {};
    support = {
      searchParams: "URLSearchParams" in g,
      iterable: "Symbol" in g && "iterator" in Symbol,
      blob: "FileReader" in g && "Blob" in g && function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: "FormData" in g,
      arrayBuffer: "ArrayBuffer" in g
    };
    if (support.arrayBuffer) {
      viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ];
      isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ", " + value : value;
    };
    Headers.prototype["delete"] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit });
    };
    Body.call(Request.prototype);
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response.error = function() {
      var response = new Response(null, { status: 200, statusText: "" });
      response.status = 0;
      response.type = "error";
      return response;
    };
    redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError("Invalid status code");
      }
      return new Response(null, { status, headers: { location: url } });
    };
    DOMException = g.DOMException;
    try {
      new DOMException();
    } catch (err) {
      DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      DOMException.prototype = Object.create(Error.prototype);
      DOMException.prototype.constructor = DOMException;
    }
    fetch.polyfill = true;
    if (!g.fetch) {
      g.fetch = fetch;
      g.Headers = Headers;
      g.Request = Request;
      g.Response = Response;
    }
  }
});

// node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
    init_fetch();
    module.exports = self.fetch.bind(self);
  }
});

// node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "node_modules/url-join/lib/url-join.js"(exports, module) {
    (function(name, context, definition) {
      if (typeof module !== "undefined" && module.exports)
        module.exports = definition();
      else if (typeof define === "function" && define.amd)
        define(definition);
      else
        context[name] = definition();
    })("urljoin", exports, function() {
      function normalize(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first3 = strArray.shift();
          strArray[0] = first3 + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize(input);
      };
    });
  }
});

// node_modules/starknet/dist/index.js
var require_dist = __commonJS({
  "node_modules/starknet/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Account: () => Account,
      AccountInterface: () => AccountInterface,
      BlockStatus: () => BlockStatus,
      BlockTag: () => BlockTag,
      CairoCustomEnum: () => CairoCustomEnum,
      CairoOption: () => CairoOption,
      CairoOptionVariant: () => CairoOptionVariant,
      CairoResult: () => CairoResult,
      CairoResultVariant: () => CairoResultVariant,
      CallData: () => CallData,
      Contract: () => Contract,
      ContractFactory: () => ContractFactory,
      ContractInterface: () => ContractInterface,
      CustomError: () => CustomError,
      EntryPointType: () => EntryPointType,
      GatewayError: () => GatewayError,
      HttpError: () => HttpError,
      LibraryError: () => LibraryError,
      Litteral: () => Litteral,
      Provider: () => Provider,
      ProviderInterface: () => ProviderInterface,
      RPC: () => rpc_exports,
      RpcProvider: () => RpcProvider,
      SIMULATION_FLAG: () => SIMULATION_FLAG,
      Sequencer: () => sequencer_exports,
      SequencerProvider: () => SequencerProvider,
      Signer: () => Signer,
      SignerInterface: () => SignerInterface,
      TransactionExecutionStatus: () => TransactionExecutionStatus,
      TransactionFinalityStatus: () => TransactionFinalityStatus,
      TransactionStatus: () => TransactionStatus,
      TransactionType: () => TransactionType,
      Uint: () => Uint,
      ValidateType: () => ValidateType,
      addAddressPadding: () => addAddressPadding,
      buildUrl: () => buildUrl,
      cairo: () => cairo_exports,
      constants: () => constants_exports,
      contractClassResponseToLegacyCompiledContract: () => contractClassResponseToLegacyCompiledContract,
      defaultProvider: () => defaultProvider,
      ec: () => ec_exports,
      encode: () => encode_exports,
      events: () => events_exports,
      extractContractHashes: () => extractContractHashes,
      fixProto: () => fixProto,
      fixStack: () => fixStack,
      getCalldata: () => getCalldata,
      getChecksumAddress: () => getChecksumAddress,
      hash: () => hash_exports,
      isSierra: () => isSierra,
      isUrl: () => isUrl,
      json: () => json_exports,
      merkle: () => merkle_exports,
      num: () => num_exports,
      number: () => number,
      parseUDCEvent: () => parseUDCEvent,
      provider: () => provider_exports,
      selector: () => selector_exports,
      shortString: () => shortString_exports,
      splitArgsAndOptions: () => splitArgsAndOptions,
      stark: () => stark_exports,
      starknetId: () => starknetId_exports,
      transaction: () => transaction_exports,
      typedData: () => typedData_exports,
      types: () => types_exports,
      uint256: () => uint256_exports,
      validateAndParseAddress: () => validateAndParseAddress,
      validateChecksumAddress: () => validateChecksumAddress
    });
    module.exports = __toCommonJS2(src_exports);
    var constants_exports = {};
    __export2(constants_exports, {
      ALPHA: () => ALPHA,
      API_VERSION: () => API_VERSION,
      BETA: () => BETA,
      BaseUrl: () => BaseUrl,
      CONSTANT_POINTS: () => CONSTANT_POINTS,
      EC_ORDER: () => EC_ORDER,
      FIELD_GEN: () => FIELD_GEN,
      FIELD_PRIME: () => FIELD_PRIME,
      FIELD_SIZE: () => FIELD_SIZE,
      HEX_STR_TRANSACTION_VERSION_1: () => HEX_STR_TRANSACTION_VERSION_1,
      HEX_STR_TRANSACTION_VERSION_2: () => HEX_STR_TRANSACTION_VERSION_2,
      IS_BROWSER: () => IS_BROWSER,
      MASK_250: () => MASK_250,
      MASK_251: () => MASK_251,
      MAX_ECDSA_VAL: () => MAX_ECDSA_VAL,
      NetworkName: () => NetworkName,
      StarknetChainId: () => StarknetChainId,
      TransactionHashPrefix: () => TransactionHashPrefix,
      UDC: () => UDC,
      ZERO: () => ZERO
    });
    var encode_exports = {};
    __export2(encode_exports, {
      IS_BROWSER: () => IS_BROWSER,
      addHexPrefix: () => addHexPrefix,
      arrayBufferToString: () => arrayBufferToString,
      atobUniversal: () => atobUniversal,
      btoaUniversal: () => btoaUniversal,
      buf2hex: () => buf2hex,
      calcByteLength: () => calcByteLength,
      padLeft: () => padLeft,
      pascalToSnake: () => pascalToSnake,
      removeHexPrefix: () => removeHexPrefix,
      sanitizeBytes: () => sanitizeBytes,
      sanitizeHex: () => sanitizeHex,
      stringToArrayBuffer: () => stringToArrayBuffer,
      utf8ToArray: () => utf8ToArray
    });
    var IS_BROWSER = typeof window !== "undefined";
    var STRING_ZERO = "0";
    function arrayBufferToString(array) {
      return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), "");
    }
    function stringToArrayBuffer(s) {
      return Uint8Array.from(s, (c) => c.charCodeAt(0));
    }
    function atobUniversal(a) {
      return IS_BROWSER ? stringToArrayBuffer(atob(a)) : Buffer.from(a, "base64");
    }
    function btoaUniversal(b) {
      return IS_BROWSER ? btoa(arrayBufferToString(b)) : Buffer.from(b).toString("base64");
    }
    function buf2hex(buffer) {
      return [...buffer].map((x) => x.toString(16).padStart(2, "0")).join("");
    }
    function removeHexPrefix(hex) {
      return hex.replace(/^0x/i, "");
    }
    function addHexPrefix(hex) {
      return `0x${removeHexPrefix(hex)}`;
    }
    function padString(str, length, left, padding = STRING_ZERO) {
      const diff = length - str.length;
      let result = str;
      if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
      }
      return result;
    }
    function padLeft(str, length, padding = STRING_ZERO) {
      return padString(str, length, true, padding);
    }
    function calcByteLength(length, byteSize = 8) {
      const remainder = length % byteSize;
      return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
    }
    function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
      return padLeft(str, calcByteLength(str.length, byteSize), padding);
    }
    function sanitizeHex(hex) {
      hex = removeHexPrefix(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
        hex = addHexPrefix(hex);
      }
      return hex;
    }
    function utf8ToArray(str) {
      return new TextEncoder().encode(str);
    }
    var pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join("_").toUpperCase() : text;
    var HEX_STR_TRANSACTION_VERSION_1 = "0x1";
    var HEX_STR_TRANSACTION_VERSION_2 = "0x2";
    var ZERO = 0n;
    var MASK_250 = 2n ** 250n - 1n;
    var MASK_251 = 2n ** 251n;
    var API_VERSION = ZERO;
    var BaseUrl = ((BaseUrl2) => {
      BaseUrl2["SN_MAIN"] = "https://alpha-mainnet.starknet.io";
      BaseUrl2["SN_GOERLI"] = "https://alpha4.starknet.io";
      BaseUrl2["SN_GOERLI2"] = "https://alpha4-2.starknet.io";
      return BaseUrl2;
    })(BaseUrl || {});
    var NetworkName = ((NetworkName2) => {
      NetworkName2["SN_MAIN"] = "SN_MAIN";
      NetworkName2["SN_GOERLI"] = "SN_GOERLI";
      NetworkName2["SN_GOERLI2"] = "SN_GOERLI2";
      return NetworkName2;
    })(NetworkName || {});
    var StarknetChainId = ((StarknetChainId4) => {
      StarknetChainId4["SN_MAIN"] = "0x534e5f4d41494e";
      StarknetChainId4["SN_GOERLI"] = "0x534e5f474f45524c49";
      StarknetChainId4["SN_GOERLI2"] = "0x534e5f474f45524c4932";
      return StarknetChainId4;
    })(StarknetChainId || {});
    var TransactionHashPrefix = ((TransactionHashPrefix2) => {
      TransactionHashPrefix2["DECLARE"] = "0x6465636c617265";
      TransactionHashPrefix2["DEPLOY"] = "0x6465706c6f79";
      TransactionHashPrefix2["DEPLOY_ACCOUNT"] = "0x6465706c6f795f6163636f756e74";
      TransactionHashPrefix2["INVOKE"] = "0x696e766f6b65";
      TransactionHashPrefix2["L1_HANDLER"] = "0x6c315f68616e646c6572";
      return TransactionHashPrefix2;
    })(TransactionHashPrefix || {});
    var UDC = {
      ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
      ENTRYPOINT: "deployContract"
    };
    var FIELD_PRIME = "800000000000011000000000000000000000000000000000000000000000001";
    var FIELD_GEN = "3";
    var FIELD_SIZE = 251;
    var EC_ORDER = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F";
    var ALPHA = "1";
    var BETA = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89";
    var MAX_ECDSA_VAL = "800000000000000000000000000000000000000000000000000000000000000";
    var CONSTANT_POINTS = [
      [
        "49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804",
        "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"
      ],
      [
        "1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca",
        "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
      ],
      [
        "234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b",
        "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"
      ],
      [
        "3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476",
        "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"
      ],
      [
        "40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c",
        "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"
      ],
      [
        "2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b",
        "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"
      ],
      [
        "6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674",
        "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"
      ],
      [
        "7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62",
        "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"
      ],
      [
        "3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec",
        "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"
      ],
      [
        "1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e",
        "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"
      ],
      [
        "6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26",
        "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"
      ],
      [
        "54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4",
        "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"
      ],
      [
        "35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6",
        "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"
      ],
      [
        "4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23",
        "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"
      ],
      [
        "648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf",
        "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"
      ],
      [
        "bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b",
        "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"
      ],
      [
        "35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357",
        "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"
      ],
      [
        "36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643",
        "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"
      ],
      [
        "5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661",
        "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"
      ],
      [
        "21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6",
        "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"
      ],
      [
        "19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9",
        "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"
      ],
      [
        "888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24",
        "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"
      ],
      [
        "75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977",
        "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"
      ],
      [
        "640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5",
        "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"
      ],
      [
        "6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96",
        "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"
      ],
      [
        "5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876",
        "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"
      ],
      [
        "6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4",
        "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"
      ],
      [
        "542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18",
        "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"
      ],
      [
        "299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de",
        "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"
      ],
      [
        "628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73",
        "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"
      ],
      [
        "6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933",
        "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"
      ],
      [
        "28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a",
        "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"
      ],
      [
        "619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02",
        "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"
      ],
      [
        "641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96",
        "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"
      ],
      [
        "58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2",
        "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"
      ],
      [
        "a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74",
        "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"
      ],
      [
        "744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b",
        "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"
      ],
      [
        "434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c",
        "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"
      ],
      [
        "7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73",
        "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"
      ],
      [
        "4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7",
        "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"
      ],
      [
        "250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe",
        "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"
      ],
      [
        "2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2",
        "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"
      ],
      [
        "249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245",
        "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"
      ],
      [
        "6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb",
        "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"
      ],
      [
        "2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9",
        "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"
      ],
      [
        "4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea",
        "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"
      ],
      [
        "46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca",
        "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"
      ],
      [
        "2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152",
        "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"
      ],
      [
        "386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b",
        "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"
      ],
      [
        "407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90",
        "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"
      ],
      [
        "1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f",
        "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"
      ],
      [
        "7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e",
        "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"
      ],
      [
        "299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913",
        "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"
      ],
      [
        "551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5",
        "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"
      ],
      [
        "7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2",
        "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"
      ],
      [
        "28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504",
        "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"
      ],
      [
        "1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b",
        "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"
      ],
      [
        "2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b",
        "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"
      ],
      [
        "770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed",
        "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"
      ],
      [
        "5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9",
        "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"
      ],
      [
        "6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825",
        "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"
      ],
      [
        "404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1",
        "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"
      ],
      [
        "20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc",
        "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"
      ],
      [
        "119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa",
        "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"
      ],
      [
        "45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749",
        "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"
      ],
      [
        "1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38",
        "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"
      ],
      [
        "186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3",
        "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"
      ],
      [
        "58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9",
        "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"
      ],
      [
        "13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b",
        "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"
      ],
      [
        "48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676",
        "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"
      ],
      [
        "4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158",
        "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"
      ],
      [
        "4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b",
        "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"
      ],
      [
        "7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9",
        "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"
      ],
      [
        "65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f",
        "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"
      ],
      [
        "1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d",
        "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"
      ],
      [
        "3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b",
        "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"
      ],
      [
        "4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4",
        "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"
      ],
      [
        "6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8",
        "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"
      ],
      [
        "748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5",
        "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"
      ],
      [
        "7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3",
        "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"
      ],
      [
        "6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f",
        "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"
      ],
      [
        "1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309",
        "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"
      ],
      [
        "1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd",
        "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"
      ],
      [
        "6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162",
        "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"
      ],
      [
        "738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e",
        "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"
      ],
      [
        "2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8",
        "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"
      ],
      [
        "181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe",
        "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"
      ],
      [
        "1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a",
        "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"
      ],
      [
        "e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873",
        "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"
      ],
      [
        "4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45",
        "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"
      ],
      [
        "37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed",
        "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"
      ],
      [
        "27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c",
        "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"
      ],
      [
        "2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf",
        "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"
      ],
      [
        "307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72",
        "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"
      ],
      [
        "79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc",
        "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"
      ],
      [
        "4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292",
        "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"
      ],
      [
        "645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2",
        "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"
      ],
      [
        "1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f",
        "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"
      ],
      [
        "66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca",
        "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"
      ],
      [
        "5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1",
        "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"
      ],
      [
        "a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194",
        "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"
      ],
      [
        "1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c",
        "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"
      ],
      [
        "48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f",
        "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"
      ],
      [
        "17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd",
        "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"
      ],
      [
        "5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89",
        "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"
      ],
      [
        "6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58",
        "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"
      ],
      [
        "7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6",
        "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"
      ],
      [
        "17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d",
        "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"
      ],
      [
        "7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf",
        "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"
      ],
      [
        "7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d",
        "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"
      ],
      [
        "273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128",
        "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"
      ],
      [
        "3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212",
        "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"
      ],
      [
        "5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee",
        "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"
      ],
      [
        "7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9",
        "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"
      ],
      [
        "40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62",
        "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"
      ],
      [
        "6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465",
        "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"
      ],
      [
        "604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6",
        "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"
      ],
      [
        "73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4",
        "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"
      ],
      [
        "3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1",
        "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"
      ],
      [
        "39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f",
        "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"
      ],
      [
        "326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c",
        "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"
      ],
      [
        "53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632",
        "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"
      ],
      [
        "6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e",
        "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"
      ],
      [
        "3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332",
        "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"
      ],
      [
        "3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e",
        "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"
      ],
      [
        "7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a",
        "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"
      ],
      [
        "1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb",
        "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"
      ],
      [
        "3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344",
        "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"
      ],
      [
        "44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa",
        "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"
      ],
      [
        "7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e",
        "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"
      ],
      [
        "7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d",
        "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"
      ],
      [
        "7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c",
        "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"
      ],
      [
        "758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2",
        "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"
      ],
      [
        "7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e",
        "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"
      ],
      [
        "78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614",
        "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"
      ],
      [
        "6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647",
        "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"
      ],
      [
        "4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e",
        "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"
      ],
      [
        "3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d",
        "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"
      ],
      [
        "5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287",
        "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"
      ],
      [
        "3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004",
        "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"
      ],
      [
        "3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb",
        "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"
      ],
      [
        "16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52",
        "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"
      ],
      [
        "75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4",
        "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"
      ],
      [
        "3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8",
        "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"
      ],
      [
        "54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579",
        "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"
      ],
      [
        "d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0",
        "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"
      ],
      [
        "2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d",
        "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"
      ],
      [
        "752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3",
        "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"
      ],
      [
        "63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e",
        "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"
      ],
      [
        "d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b",
        "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"
      ],
      [
        "12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557",
        "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"
      ],
      [
        "46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c",
        "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"
      ],
      [
        "4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516",
        "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"
      ],
      [
        "71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833",
        "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"
      ],
      [
        "5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61",
        "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"
      ],
      [
        "161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941",
        "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"
      ],
      [
        "1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1",
        "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"
      ],
      [
        "56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44",
        "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"
      ],
      [
        "4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491",
        "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"
      ],
      [
        "7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606",
        "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"
      ],
      [
        "16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe",
        "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"
      ],
      [
        "323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b",
        "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"
      ],
      [
        "624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d",
        "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"
      ],
      [
        "f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d",
        "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"
      ],
      [
        "686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec",
        "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"
      ],
      [
        "3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e",
        "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"
      ],
      [
        "484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b",
        "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"
      ],
      [
        "203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a",
        "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"
      ],
      [
        "2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d",
        "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"
      ],
      [
        "5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef",
        "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"
      ],
      [
        "57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741",
        "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"
      ],
      [
        "611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1",
        "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"
      ],
      [
        "1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31",
        "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"
      ],
      [
        "275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234",
        "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"
      ],
      [
        "6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95",
        "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"
      ],
      [
        "44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c",
        "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"
      ],
      [
        "fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966",
        "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"
      ],
      [
        "9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef",
        "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"
      ],
      [
        "71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7",
        "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"
      ],
      [
        "1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345",
        "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"
      ],
      [
        "3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115",
        "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"
      ],
      [
        "c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d",
        "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"
      ],
      [
        "44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d",
        "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"
      ],
      [
        "35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f",
        "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"
      ],
      [
        "e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03",
        "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"
      ],
      [
        "3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a",
        "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"
      ],
      [
        "222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c",
        "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"
      ],
      [
        "3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764",
        "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"
      ],
      [
        "adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187",
        "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"
      ],
      [
        "3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9",
        "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"
      ],
      [
        "12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32",
        "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"
      ],
      [
        "27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b",
        "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"
      ],
      [
        "431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6",
        "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"
      ],
      [
        "4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33",
        "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"
      ],
      [
        "2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8",
        "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"
      ],
      [
        "e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc",
        "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"
      ],
      [
        "7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5",
        "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"
      ],
      [
        "62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b",
        "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"
      ],
      [
        "1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938",
        "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"
      ],
      [
        "78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea",
        "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"
      ],
      [
        "5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d",
        "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"
      ],
      [
        "62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04",
        "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"
      ],
      [
        "4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f",
        "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"
      ],
      [
        "52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1",
        "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"
      ],
      [
        "1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f",
        "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"
      ],
      [
        "4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232",
        "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"
      ],
      [
        "69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73",
        "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"
      ],
      [
        "b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62",
        "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"
      ],
      [
        "5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb",
        "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"
      ],
      [
        "1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0",
        "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"
      ],
      [
        "2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5",
        "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"
      ],
      [
        "d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3",
        "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"
      ],
      [
        "91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563",
        "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"
      ],
      [
        "1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7",
        "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"
      ],
      [
        "4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f",
        "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"
      ],
      [
        "3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069",
        "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"
      ],
      [
        "758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657",
        "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"
      ],
      [
        "19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8",
        "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"
      ],
      [
        "28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855",
        "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"
      ],
      [
        "3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f",
        "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"
      ],
      [
        "77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b",
        "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"
      ],
      [
        "97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6",
        "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"
      ],
      [
        "a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647",
        "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"
      ],
      [
        "e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc",
        "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"
      ],
      [
        "2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de",
        "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"
      ],
      [
        "744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f",
        "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"
      ],
      [
        "40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd",
        "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"
      ],
      [
        "5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc",
        "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"
      ],
      [
        "5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985",
        "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"
      ],
      [
        "2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649",
        "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"
      ],
      [
        "ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381",
        "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"
      ],
      [
        "233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c",
        "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"
      ],
      [
        "42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce",
        "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"
      ],
      [
        "30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44",
        "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"
      ],
      [
        "4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a",
        "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"
      ],
      [
        "62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466",
        "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"
      ],
      [
        "5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f",
        "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"
      ],
      [
        "670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728",
        "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"
      ],
      [
        "3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5",
        "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"
      ],
      [
        "4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3",
        "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"
      ],
      [
        "4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0",
        "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"
      ],
      [
        "574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219",
        "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"
      ],
      [
        "7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554",
        "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"
      ],
      [
        "67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6",
        "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"
      ],
      [
        "63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b",
        "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"
      ],
      [
        "3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543",
        "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"
      ],
      [
        "758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129",
        "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"
      ],
      [
        "38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c",
        "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"
      ],
      [
        "206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad",
        "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"
      ],
      [
        "56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d",
        "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"
      ],
      [
        "4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378",
        "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"
      ],
      [
        "450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58",
        "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"
      ],
      [
        "6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d",
        "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"
      ],
      [
        "1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf",
        "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"
      ],
      [
        "4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997",
        "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"
      ],
      [
        "21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef",
        "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"
      ],
      [
        "350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046",
        "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"
      ],
      [
        "529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6",
        "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"
      ],
      [
        "55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d",
        "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"
      ],
      [
        "405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f",
        "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"
      ],
      [
        "376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe",
        "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"
      ],
      [
        "2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38",
        "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"
      ],
      [
        "3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed",
        "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"
      ],
      [
        "7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4",
        "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"
      ],
      [
        "4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d",
        "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"
      ],
      [
        "79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72",
        "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"
      ],
      [
        "297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c",
        "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"
      ],
      [
        "44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7",
        "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"
      ],
      [
        "6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26",
        "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"
      ],
      [
        "14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24",
        "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"
      ],
      [
        "95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83",
        "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"
      ],
      [
        "2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5",
        "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"
      ],
      [
        "61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d",
        "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"
      ],
      [
        "79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf",
        "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"
      ],
      [
        "45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b",
        "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"
      ],
      [
        "37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007",
        "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"
      ],
      [
        "71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b",
        "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"
      ],
      [
        "78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06",
        "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"
      ],
      [
        "b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15",
        "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"
      ],
      [
        "441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc",
        "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"
      ],
      [
        "2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa",
        "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"
      ],
      [
        "3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f",
        "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"
      ],
      [
        "5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092",
        "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"
      ],
      [
        "3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771",
        "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"
      ],
      [
        "5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f",
        "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"
      ],
      [
        "1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281",
        "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"
      ],
      [
        "1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40",
        "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"
      ],
      [
        "61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b",
        "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"
      ],
      [
        "7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e",
        "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"
      ],
      [
        "124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316",
        "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"
      ],
      [
        "61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c",
        "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"
      ],
      [
        "70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d",
        "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"
      ],
      [
        "41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f",
        "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"
      ],
      [
        "62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8",
        "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"
      ],
      [
        "441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a",
        "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"
      ],
      [
        "2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee",
        "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"
      ],
      [
        "5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea",
        "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"
      ],
      [
        "3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7",
        "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"
      ],
      [
        "95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922",
        "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"
      ],
      [
        "621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c",
        "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"
      ],
      [
        "54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e",
        "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"
      ],
      [
        "21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d",
        "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"
      ],
      [
        "3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3",
        "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"
      ],
      [
        "befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392",
        "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"
      ],
      [
        "15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6",
        "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"
      ],
      [
        "38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8",
        "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"
      ],
      [
        "6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72",
        "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"
      ],
      [
        "5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30",
        "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"
      ],
      [
        "309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1",
        "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"
      ],
      [
        "89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc",
        "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"
      ],
      [
        "480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84",
        "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"
      ],
      [
        "3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb",
        "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"
      ],
      [
        "66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd",
        "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"
      ],
      [
        "373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3",
        "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"
      ],
      [
        "26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7",
        "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"
      ],
      [
        "ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f",
        "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"
      ],
      [
        "25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66",
        "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"
      ],
      [
        "243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742",
        "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"
      ],
      [
        "48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562",
        "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"
      ],
      [
        "592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca",
        "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"
      ],
      [
        "31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d",
        "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"
      ],
      [
        "4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc",
        "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"
      ],
      [
        "26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc",
        "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"
      ],
      [
        "3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe",
        "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"
      ],
      [
        "483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97",
        "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"
      ],
      [
        "65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9",
        "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"
      ],
      [
        "284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35",
        "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"
      ],
      [
        "32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85",
        "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"
      ],
      [
        "1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a",
        "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"
      ],
      [
        "270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf",
        "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"
      ],
      [
        "6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d",
        "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"
      ],
      [
        "48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1",
        "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"
      ],
      [
        "e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5",
        "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"
      ],
      [
        "5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8",
        "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"
      ],
      [
        "15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6",
        "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"
      ],
      [
        "274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50",
        "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"
      ],
      [
        "4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123",
        "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"
      ],
      [
        "4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a",
        "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"
      ],
      [
        "5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3",
        "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"
      ],
      [
        "11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483",
        "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"
      ],
      [
        "4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3",
        "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"
      ],
      [
        "2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3",
        "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"
      ],
      [
        "52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf",
        "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"
      ],
      [
        "541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961",
        "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"
      ],
      [
        "5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd",
        "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"
      ],
      [
        "15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4",
        "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"
      ],
      [
        "68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4",
        "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"
      ],
      [
        "67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df",
        "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"
      ],
      [
        "596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334",
        "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"
      ],
      [
        "567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395",
        "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"
      ],
      [
        "cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7",
        "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"
      ],
      [
        "4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06",
        "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"
      ],
      [
        "760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359",
        "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"
      ],
      [
        "6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2",
        "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"
      ],
      [
        "4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b",
        "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"
      ],
      [
        "5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7",
        "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"
      ],
      [
        "2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7",
        "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"
      ],
      [
        "5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00",
        "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"
      ],
      [
        "7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c",
        "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"
      ],
      [
        "37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843",
        "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"
      ],
      [
        "5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114",
        "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"
      ],
      [
        "25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63",
        "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"
      ],
      [
        "32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0",
        "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"
      ],
      [
        "49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f",
        "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"
      ],
      [
        "10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd",
        "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"
      ],
      [
        "79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36",
        "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"
      ],
      [
        "6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439",
        "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"
      ],
      [
        "71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097",
        "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"
      ],
      [
        "27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b",
        "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"
      ],
      [
        "6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c",
        "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"
      ],
      [
        "32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9",
        "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"
      ],
      [
        "4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e",
        "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"
      ],
      [
        "4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10",
        "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"
      ],
      [
        "87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a",
        "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"
      ],
      [
        "6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae",
        "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"
      ],
      [
        "19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a",
        "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"
      ],
      [
        "12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d",
        "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"
      ],
      [
        "13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2",
        "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"
      ],
      [
        "255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d",
        "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"
      ],
      [
        "7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31",
        "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"
      ],
      [
        "2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35",
        "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"
      ],
      [
        "750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b",
        "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"
      ],
      [
        "3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72",
        "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"
      ],
      [
        "4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb",
        "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"
      ],
      [
        "1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f",
        "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"
      ],
      [
        "2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087",
        "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"
      ],
      [
        "4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3",
        "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"
      ],
      [
        "2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05",
        "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"
      ],
      [
        "4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c",
        "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"
      ],
      [
        "7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b",
        "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"
      ],
      [
        "7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51",
        "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"
      ],
      [
        "36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881",
        "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"
      ],
      [
        "403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd",
        "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"
      ],
      [
        "3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb",
        "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"
      ],
      [
        "3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537",
        "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"
      ],
      [
        "235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65",
        "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"
      ],
      [
        "3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b",
        "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"
      ],
      [
        "48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518",
        "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"
      ],
      [
        "48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0",
        "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"
      ],
      [
        "2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097",
        "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"
      ],
      [
        "1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676",
        "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"
      ],
      [
        "2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b",
        "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"
      ],
      [
        "348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a",
        "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"
      ],
      [
        "7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31",
        "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"
      ],
      [
        "2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a",
        "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"
      ],
      [
        "1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2",
        "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"
      ],
      [
        "54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e",
        "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"
      ],
      [
        "525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b",
        "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"
      ],
      [
        "54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd",
        "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"
      ],
      [
        "4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae",
        "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"
      ],
      [
        "21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708",
        "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"
      ],
      [
        "167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66",
        "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"
      ],
      [
        "31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843",
        "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"
      ],
      [
        "1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b",
        "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"
      ],
      [
        "c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0",
        "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"
      ],
      [
        "394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6",
        "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"
      ],
      [
        "410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27",
        "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"
      ],
      [
        "38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734",
        "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"
      ],
      [
        "78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608",
        "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"
      ],
      [
        "6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867",
        "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"
      ],
      [
        "32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602",
        "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"
      ],
      [
        "49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5",
        "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"
      ],
      [
        "2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5",
        "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"
      ],
      [
        "3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70",
        "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"
      ],
      [
        "5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab",
        "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"
      ],
      [
        "19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a",
        "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"
      ],
      [
        "61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc",
        "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"
      ],
      [
        "2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df",
        "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"
      ],
      [
        "7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54",
        "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"
      ],
      [
        "b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed",
        "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"
      ],
      [
        "e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc",
        "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"
      ],
      [
        "7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4",
        "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"
      ],
      [
        "7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c",
        "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"
      ],
      [
        "225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5",
        "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"
      ],
      [
        "1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1",
        "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"
      ],
      [
        "59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335",
        "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"
      ],
      [
        "2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3",
        "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"
      ],
      [
        "6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb",
        "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"
      ],
      [
        "34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88",
        "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"
      ],
      [
        "436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d",
        "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"
      ],
      [
        "592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4",
        "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"
      ],
      [
        "89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009",
        "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"
      ],
      [
        "1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e",
        "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"
      ],
      [
        "574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03",
        "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"
      ],
      [
        "513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1",
        "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"
      ],
      [
        "53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9",
        "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"
      ],
      [
        "213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44",
        "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"
      ],
      [
        "735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c",
        "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"
      ],
      [
        "3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001",
        "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"
      ],
      [
        "51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74",
        "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"
      ],
      [
        "c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc",
        "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"
      ],
      [
        "5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece",
        "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"
      ],
      [
        "3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299",
        "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"
      ],
      [
        "6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0",
        "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"
      ],
      [
        "7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65",
        "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"
      ],
      [
        "2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6",
        "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"
      ],
      [
        "34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f",
        "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"
      ],
      [
        "6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441",
        "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"
      ],
      [
        "17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce",
        "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"
      ],
      [
        "70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27",
        "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"
      ],
      [
        "2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf",
        "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"
      ],
      [
        "5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1",
        "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"
      ],
      [
        "6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61",
        "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"
      ],
      [
        "74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293",
        "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"
      ],
      [
        "44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9",
        "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"
      ],
      [
        "2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc",
        "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"
      ],
      [
        "3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb",
        "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"
      ],
      [
        "284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677",
        "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"
      ],
      [
        "2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32",
        "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"
      ],
      [
        "5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7",
        "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"
      ],
      [
        "74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f",
        "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"
      ],
      [
        "334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45",
        "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"
      ],
      [
        "7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30",
        "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"
      ],
      [
        "4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8",
        "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"
      ],
      [
        "1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7",
        "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"
      ],
      [
        "294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1",
        "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"
      ],
      [
        "753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39",
        "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"
      ],
      [
        "5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e",
        "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"
      ],
      [
        "4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f",
        "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"
      ],
      [
        "726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8",
        "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"
      ],
      [
        "38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2",
        "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"
      ],
      [
        "6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291",
        "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"
      ],
      [
        "6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f",
        "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"
      ],
      [
        "2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155",
        "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"
      ],
      [
        "4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7",
        "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"
      ],
      [
        "110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3",
        "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"
      ],
      [
        "5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096",
        "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"
      ],
      [
        "2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d",
        "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"
      ],
      [
        "1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d",
        "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"
      ],
      [
        "2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d",
        "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"
      ],
      [
        "376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543",
        "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"
      ],
      [
        "a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066",
        "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"
      ],
      [
        "223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed",
        "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"
      ],
      [
        "102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2",
        "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"
      ],
      [
        "891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2",
        "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"
      ],
      [
        "215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203",
        "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"
      ],
      [
        "21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36",
        "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"
      ],
      [
        "60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae",
        "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"
      ],
      [
        "1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5",
        "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"
      ],
      [
        "5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e",
        "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"
      ],
      [
        "626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8",
        "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"
      ],
      [
        "23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd",
        "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"
      ],
      [
        "54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202",
        "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"
      ],
      [
        "13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c",
        "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"
      ],
      [
        "47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98",
        "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"
      ],
      [
        "2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585",
        "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"
      ]
    ];
    var types_exports = {};
    __export2(types_exports, {
      BlockStatus: () => BlockStatus,
      BlockTag: () => BlockTag,
      EntryPointType: () => EntryPointType,
      Litteral: () => Litteral,
      RPC: () => rpc_exports,
      SIMULATION_FLAG: () => SIMULATION_FLAG,
      Sequencer: () => sequencer_exports,
      TransactionExecutionStatus: () => TransactionExecutionStatus,
      TransactionFinalityStatus: () => TransactionFinalityStatus,
      TransactionStatus: () => TransactionStatus,
      TransactionType: () => TransactionType,
      Uint: () => Uint,
      ValidateType: () => ValidateType
    });
    var SIMULATION_FLAG = ((SIMULATION_FLAG3) => {
      SIMULATION_FLAG3["SKIP_VALIDATE"] = "SKIP_VALIDATE";
      SIMULATION_FLAG3["SKIP_EXECUTE"] = "SKIP_EXECUTE";
      return SIMULATION_FLAG3;
    })(SIMULATION_FLAG || {});
    var ValidateType = ((ValidateType2) => {
      ValidateType2["DEPLOY"] = "DEPLOY";
      ValidateType2["CALL"] = "CALL";
      ValidateType2["INVOKE"] = "INVOKE";
      return ValidateType2;
    })(ValidateType || {});
    var Uint = ((Uint2) => {
      Uint2["u8"] = "core::integer::u8";
      Uint2["u16"] = "core::integer::u16";
      Uint2["u32"] = "core::integer::u32";
      Uint2["u64"] = "core::integer::u64";
      Uint2["u128"] = "core::integer::u128";
      Uint2["u256"] = "core::integer::u256";
      return Uint2;
    })(Uint || {});
    var Litteral = ((Litteral2) => {
      Litteral2["ClassHash"] = "core::starknet::class_hash::ClassHash";
      Litteral2["ContractAddress"] = "core::starknet::contract_address::ContractAddress";
      return Litteral2;
    })(Litteral || {});
    var EntryPointType = ((EntryPointType2) => {
      EntryPointType2["EXTERNAL"] = "EXTERNAL";
      EntryPointType2["L1_HANDLER"] = "L1_HANDLER";
      EntryPointType2["CONSTRUCTOR"] = "CONSTRUCTOR";
      return EntryPointType2;
    })(EntryPointType || {});
    var TransactionType = ((TransactionType3) => {
      TransactionType3["DECLARE"] = "DECLARE";
      TransactionType3["DEPLOY"] = "DEPLOY";
      TransactionType3["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
      TransactionType3["INVOKE"] = "INVOKE_FUNCTION";
      return TransactionType3;
    })(TransactionType || {});
    var TransactionStatus = ((TransactionStatus2) => {
      TransactionStatus2["NOT_RECEIVED"] = "NOT_RECEIVED";
      TransactionStatus2["RECEIVED"] = "RECEIVED";
      TransactionStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      TransactionStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      TransactionStatus2["REJECTED"] = "REJECTED";
      TransactionStatus2["REVERTED"] = "REVERTED";
      return TransactionStatus2;
    })(TransactionStatus || {});
    var TransactionFinalityStatus = ((TransactionFinalityStatus3) => {
      TransactionFinalityStatus3["NOT_RECEIVED"] = "NOT_RECEIVED";
      TransactionFinalityStatus3["RECEIVED"] = "RECEIVED";
      TransactionFinalityStatus3["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      TransactionFinalityStatus3["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      return TransactionFinalityStatus3;
    })(TransactionFinalityStatus || {});
    var TransactionExecutionStatus = ((TransactionExecutionStatus3) => {
      TransactionExecutionStatus3["REJECTED"] = "REJECTED";
      TransactionExecutionStatus3["REVERTED"] = "REVERTED";
      TransactionExecutionStatus3["SUCCEEDED"] = "SUCCEEDED";
      return TransactionExecutionStatus3;
    })(TransactionExecutionStatus || {});
    var BlockStatus = ((BlockStatus2) => {
      BlockStatus2["PENDING"] = "PENDING";
      BlockStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      BlockStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      BlockStatus2["REJECTED"] = "REJECTED";
      return BlockStatus2;
    })(BlockStatus || {});
    var BlockTag = ((BlockTag2) => {
      BlockTag2["pending"] = "pending";
      BlockTag2["latest"] = "latest";
      return BlockTag2;
    })(BlockTag || {});
    var rpc_exports = {};
    __export2(rpc_exports, {
      SimulationFlag: () => SimulationFlag,
      TransactionExecutionStatus: () => TransactionExecutionStatus2,
      TransactionFinalityStatus: () => TransactionFinalityStatus2,
      TransactionType: () => TransactionType2
    });
    var TXN_TYPE = ((TXN_TYPE2) => {
      TXN_TYPE2["DECLARE"] = "DECLARE";
      TXN_TYPE2["DEPLOY"] = "DEPLOY";
      TXN_TYPE2["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
      TXN_TYPE2["INVOKE"] = "INVOKE";
      TXN_TYPE2["L1_HANDLER"] = "L1_HANDLER";
      return TXN_TYPE2;
    })(TXN_TYPE || {});
    var TXN_FINALITY_STATUS = ((TXN_FINALITY_STATUS2) => {
      TXN_FINALITY_STATUS2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      TXN_FINALITY_STATUS2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      return TXN_FINALITY_STATUS2;
    })(TXN_FINALITY_STATUS || {});
    var TXN_EXECUTION_STATUS = ((TXN_EXECUTION_STATUS2) => {
      TXN_EXECUTION_STATUS2["SUCCEEDED"] = "SUCCEEDED";
      TXN_EXECUTION_STATUS2["REVERTED"] = "REVERTED";
      return TXN_EXECUTION_STATUS2;
    })(TXN_EXECUTION_STATUS || {});
    var SIMULATION_FLAG2 = ((SIMULATION_FLAG3) => {
      SIMULATION_FLAG3["SKIP_VALIDATE"] = "SKIP_VALIDATE";
      SIMULATION_FLAG3["SKIP_FEE_CHARGE"] = "SKIP_FEE_CHARGE";
      return SIMULATION_FLAG3;
    })(SIMULATION_FLAG2 || {});
    var TransactionType2 = TXN_TYPE;
    var SimulationFlag = SIMULATION_FLAG2;
    var TransactionFinalityStatus2 = TXN_FINALITY_STATUS;
    var TransactionExecutionStatus2 = TXN_EXECUTION_STATUS;
    var sequencer_exports = {};
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failure");
      }
    }
    var num_exports = {};
    __export2(num_exports, {
      assertInRange: () => assertInRange,
      bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,
      bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,
      cleanHex: () => cleanHex,
      getDecimalString: () => getDecimalString,
      getHexString: () => getHexString,
      getHexStringArray: () => getHexStringArray,
      hexToBytes: () => hexToBytes,
      hexToDecimalString: () => hexToDecimalString,
      isBigInt: () => isBigInt,
      isHex: () => isHex,
      isStringWholeNumber: () => isStringWholeNumber,
      toBigInt: () => toBigInt,
      toCairoBool: () => toCairoBool,
      toHex: () => toHex,
      toHexString: () => toHexString,
      toStorageKey: () => toStorageKey
    });
    var import_utils = require_utils3();
    function isHex(hex) {
      return /^0x[0-9a-f]*$/i.test(hex);
    }
    function toBigInt(value) {
      return BigInt(value);
    }
    function isBigInt(value) {
      return typeof value === "bigint";
    }
    function toHex(number2) {
      return addHexPrefix(toBigInt(number2).toString(16));
    }
    function toStorageKey(number2) {
      const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, "0"));
      return res;
    }
    function hexToDecimalString(hex) {
      return BigInt(addHexPrefix(hex)).toString(10);
    }
    var cleanHex = (hex) => hex.toLowerCase().replace(/^(0x)0+/, "$1");
    function assertInRange(input, lowerBound, upperBound, inputName = "") {
      const messageSuffix = inputName === "" ? "invalid length" : `invalid ${inputName} length`;
      const inputBigInt = BigInt(input);
      const lowerBoundBigInt = BigInt(lowerBound);
      const upperBoundBigInt = BigInt(upperBound);
      assert(
        inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,
        `Message not signable, ${messageSuffix}.`
      );
    }
    function bigNumberishArrayToDecimalStringArray(rawCalldata) {
      return rawCalldata.map((x) => toBigInt(x).toString(10));
    }
    function bigNumberishArrayToHexadecimalStringArray(rawCalldata) {
      return rawCalldata.map((x) => toHex(x));
    }
    var isStringWholeNumber = (value) => /^\d+$/.test(value);
    var toHexString = (value) => toHex(value);
    function getDecimalString(value) {
      if (isHex(value)) {
        return hexToDecimalString(value);
      }
      if (isStringWholeNumber(value)) {
        return value;
      }
      throw new Error(`${value} need to be hex-string or whole-number-string`);
    }
    function getHexString(value) {
      if (isHex(value)) {
        return value;
      }
      if (isStringWholeNumber(value)) {
        return toHexString(value);
      }
      throw new Error(`${value} need to be hex-string or whole-number-string`);
    }
    function getHexStringArray(value) {
      return value.map((el) => getHexString(el));
    }
    var toCairoBool = (value) => (+value).toString();
    function hexToBytes(value) {
      if (!isHex(value))
        throw new Error(`${value} need to be a hex-string`);
      let adaptedValue = removeHexPrefix(value);
      if (adaptedValue.length % 2 !== 0) {
        adaptedValue = `0${adaptedValue}`;
      }
      return (0, import_utils.hexToBytes)(adaptedValue);
    }
    var selector_exports = {};
    __export2(selector_exports, {
      getSelector: () => getSelector,
      getSelectorFromName: () => getSelectorFromName,
      keccakBn: () => keccakBn,
      starknetKeccak: () => starknetKeccak
    });
    var import_starknet = require_lib3();
    function keccakBn(value) {
      const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));
      const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
      return addHexPrefix((0, import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));
    }
    function keccakHex(value) {
      return addHexPrefix((0, import_starknet.keccak)(utf8ToArray(value)).toString(16));
    }
    function starknetKeccak(value) {
      const hash3 = BigInt(keccakHex(value));
      return hash3 & MASK_250;
    }
    function getSelectorFromName(funcName) {
      return toHex(starknetKeccak(funcName));
    }
    function getSelector(value) {
      if (isHex(value)) {
        return value;
      }
      if (isStringWholeNumber(value)) {
        return toHexString(value);
      }
      return getSelectorFromName(value);
    }
    var shortString_exports = {};
    __export2(shortString_exports, {
      decodeShortString: () => decodeShortString,
      encodeShortString: () => encodeShortString,
      isASCII: () => isASCII,
      isDecimalString: () => isDecimalString,
      isLongText: () => isLongText,
      isShortString: () => isShortString,
      isShortText: () => isShortText,
      isText: () => isText,
      splitLongString: () => splitLongString
    });
    var TEXT_TO_FELT_MAX_LEN = 31;
    function isASCII(str) {
      return /^[\x00-\x7F]*$/.test(str);
    }
    function isShortString(str) {
      return str.length <= TEXT_TO_FELT_MAX_LEN;
    }
    function isDecimalString(decim) {
      return /^[0-9]*$/i.test(decim);
    }
    function isText(val) {
      return typeof val === "string" && !isHex(val) && !isStringWholeNumber(val);
    }
    var isShortText = (val) => isText(val) && isShortString(val);
    var isLongText = (val) => isText(val) && !isShortString(val);
    function splitLongString(longStr) {
      const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, "g");
      return longStr.match(regex) || [];
    }
    function encodeShortString(str) {
      if (!isASCII(str))
        throw new Error(`${str} is not an ASCII string`);
      if (!isShortString(str))
        throw new Error(`${str} is too long`);
      return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));
    }
    function decodeShortString(str) {
      if (!isASCII(str))
        throw new Error(`${str} is not an ASCII string`);
      if (isHex(str)) {
        return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));
      }
      if (isDecimalString(str)) {
        return decodeShortString("0X".concat(BigInt(str).toString(16)));
      }
      throw new Error(`${str} is not Hex or decimal`);
    }
    var cairo_exports = {};
    __export2(cairo_exports, {
      felt: () => felt,
      getArrayType: () => getArrayType,
      isCairo1Abi: () => isCairo1Abi,
      isCairo1Type: () => isCairo1Type,
      isLen: () => isLen,
      isTypeArray: () => isTypeArray,
      isTypeBool: () => isTypeBool,
      isTypeContractAddress: () => isTypeContractAddress,
      isTypeEnum: () => isTypeEnum,
      isTypeEthAddress: () => isTypeEthAddress,
      isTypeFelt: () => isTypeFelt,
      isTypeLitteral: () => isTypeLitteral,
      isTypeNamedTuple: () => isTypeNamedTuple,
      isTypeOption: () => isTypeOption,
      isTypeResult: () => isTypeResult,
      isTypeStruct: () => isTypeStruct,
      isTypeTuple: () => isTypeTuple,
      isTypeUint: () => isTypeUint,
      isTypeUint256: () => isTypeUint256,
      tuple: () => tuple,
      uint256: () => uint256
    });
    var uint256_exports = {};
    __export2(uint256_exports, {
      UINT_128_MAX: () => UINT_128_MAX,
      UINT_256_MAX: () => UINT_256_MAX,
      bnToUint256: () => bnToUint256,
      isUint256: () => isUint256,
      uint256ToBN: () => uint256ToBN
    });
    function uint256ToBN(uint2562) {
      return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);
    }
    var UINT_128_MAX = (1n << 128n) - 1n;
    var UINT_256_MAX = (1n << 256n) - 1n;
    function isUint256(bn) {
      return toBigInt(bn) <= UINT_256_MAX;
    }
    function bnToUint256(bignumber) {
      const bn = toBigInt(bignumber);
      if (!isUint256(bn))
        throw new Error("Number is too large");
      return {
        low: addHexPrefix((bn & UINT_128_MAX).toString(16)),
        high: addHexPrefix((bn >> 128n).toString(16))
      };
    }
    var isLen = (name) => /_len$/.test(name);
    var isTypeFelt = (type) => type === "felt" || type === "core::felt252";
    var isTypeArray = (type) => /\*/.test(type) || type.startsWith("core::array::Array::") || type.startsWith("core::array::Span::");
    var isTypeTuple = (type) => /^\(.*\)$/i.test(type);
    var isTypeNamedTuple = (type) => /\(.*\)/i.test(type) && type.includes(":");
    var isTypeStruct = (type, structs) => type in structs;
    var isTypeEnum = (type, enums) => type in enums;
    var isTypeOption = (type) => type.startsWith("core::option::Option::");
    var isTypeResult = (type) => type.startsWith("core::result::Result::");
    var isTypeUint = (type) => Object.values(Uint).includes(type);
    var isTypeLitteral = (type) => Object.values(Litteral).includes(type);
    var isTypeUint256 = (type) => type === "core::integer::u256";
    var isTypeBool = (type) => type === "core::bool";
    var isTypeContractAddress = (type) => type === "core::starknet::contract_address::ContractAddress";
    var isTypeEthAddress = (type) => type === "core::starknet::eth_address::EthAddress";
    var isCairo1Type = (type) => type.includes("core::");
    var getArrayType = (type) => {
      if (isCairo1Type(type)) {
        return type.substring(type.indexOf("<") + 1, type.lastIndexOf(">"));
      }
      return type.replace("*", "");
    };
    function isCairo1Abi(abi) {
      const firstFunction = abi.find((entry) => entry.type === "function");
      if (!firstFunction) {
        if (abi.find((it) => it.type === "interface")) {
          return true;
        }
        throw new Error(`Error in ABI. No function in ABI.`);
      }
      if (firstFunction.inputs.length) {
        return isCairo1Type(firstFunction.inputs[0].type);
      }
      if (firstFunction.outputs.length) {
        return isCairo1Type(firstFunction.outputs[0].type);
      }
      throw new Error(`Error in ABI. No input/output in function ${firstFunction.name}`);
    }
    var uint256 = (it) => {
      const bn = BigInt(it);
      if (!isUint256(bn))
        throw new Error("Number is too large");
      return {
        // eslint-disable-next-line no-bitwise
        low: (bn & UINT_128_MAX).toString(10),
        // eslint-disable-next-line no-bitwise
        high: (bn >> 128n).toString(10)
      };
    };
    var tuple = (...args) => ({ ...args });
    function felt(it) {
      if (isBigInt(it) || typeof it === "number" && Number.isInteger(it)) {
        return it.toString();
      }
      if (isText(it)) {
        if (!isShortString(it))
          throw new Error(
            `${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`
          );
        const encoded = encodeShortString(it);
        return BigInt(encoded).toString();
      }
      if (typeof it === "string" && isHex(it)) {
        return BigInt(it).toString();
      }
      if (typeof it === "string" && isStringWholeNumber(it)) {
        return it;
      }
      if (typeof it === "boolean") {
        return `${+it}`;
      }
      throw new Error(`${it} can't be computed by felt()`);
    }
    var CairoCustomEnum = class {
      /**
       * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.
       */
      constructor(enumContent) {
        const variantsList = Object.values(enumContent);
        if (variantsList.length === 0) {
          throw new Error("This Enum must have a least 1 variant");
        }
        const nbActiveVariants = variantsList.filter(
          (content) => typeof content !== "undefined"
        ).length;
        if (nbActiveVariants !== 1) {
          throw new Error("This Enum must have exactly one active variant");
        }
        this.variant = enumContent;
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo custom Enum.
       */
      unwrap() {
        const variants = Object.entries(this.variant);
        const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
        if (typeof activeVariant === "undefined") {
          return void 0;
        }
        return activeVariant[1];
      }
      /**
       *
       * @returns the name of the valid variant of a Cairo custom Enum.
       */
      activeVariant() {
        const variants = Object.entries(this.variant);
        const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
        if (typeof activeVariant === "undefined") {
          return "";
        }
        return activeVariant[0];
      }
    };
    var CairoOptionVariant = ((CairoOptionVariant2) => {
      CairoOptionVariant2[CairoOptionVariant2["Some"] = 0] = "Some";
      CairoOptionVariant2[CairoOptionVariant2["None"] = 1] = "None";
      return CairoOptionVariant2;
    })(CairoOptionVariant || {});
    var CairoOption = class {
      constructor(variant, someContent) {
        if (!(variant in CairoOptionVariant)) {
          throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");
        }
        if (variant === 0) {
          if (typeof someContent === "undefined") {
            throw new Error(
              'The creation of a Cairo Option with "Some" variant needs a content as input.'
            );
          }
          this.Some = someContent;
          this.None = void 0;
        } else {
          this.Some = void 0;
          this.None = true;
        }
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo custom Enum.
       *  If None, returns 'undefined'.
       */
      unwrap() {
        if (this.None) {
          return void 0;
        }
        return this.Some;
      }
      /**
       *
       * @returns true if the valid variant is 'isSome'.
       */
      isSome() {
        return !(typeof this.Some === "undefined");
      }
      /**
       *
       * @returns true if the valid variant is 'isNone'.
       */
      isNone() {
        return this.None === true;
      }
    };
    var CairoResultVariant = ((CairoResultVariant2) => {
      CairoResultVariant2[CairoResultVariant2["Ok"] = 0] = "Ok";
      CairoResultVariant2[CairoResultVariant2["Err"] = 1] = "Err";
      return CairoResultVariant2;
    })(CairoResultVariant || {});
    var CairoResult = class {
      constructor(variant, resultContent) {
        if (!(variant in CairoResultVariant)) {
          throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");
        }
        if (variant === 0) {
          this.Ok = resultContent;
          this.Err = void 0;
        } else {
          this.Ok = void 0;
          this.Err = resultContent;
        }
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo Result.
       */
      unwrap() {
        if (typeof this.Ok !== "undefined") {
          return this.Ok;
        }
        if (typeof this.Err !== "undefined") {
          return this.Err;
        }
        throw new Error("Both Result.Ok and .Err are undefined. Not authorized.");
      }
      /**
       *
       * @returns true if the valid variant is 'Ok'.
       */
      isOk() {
        return !(typeof this.Ok === "undefined");
      }
      /**
       *
       * @returns true if the valid variant is 'isErr'.
       */
      isErr() {
        return !(typeof this.Err === "undefined");
      }
    };
    var guard = {
      isBN: (data, type, key) => {
        if (!isBigInt(data[key]))
          throw new Error(
            `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`
          );
      },
      unknown: (data, type, key) => {
        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);
      }
    };
    function formatter(data, type, sameType) {
      return Object.entries(data).reduce((acc, [key, value]) => {
        const elType = sameType ?? type[key];
        if (!(key in type) && !sameType) {
          acc[key] = value;
          return acc;
        }
        if (elType === "string") {
          if (Array.isArray(data[key])) {
            const arrayStr = formatter(
              data[key],
              data[key].map((_) => elType)
            );
            acc[key] = Object.values(arrayStr).join("");
            return acc;
          }
          guard.isBN(data, type, key);
          acc[key] = decodeShortString(value);
          return acc;
        }
        if (elType === "number") {
          guard.isBN(data, type, key);
          acc[key] = Number(value);
          return acc;
        }
        if (typeof elType === "function") {
          acc[key] = elType(value);
          return acc;
        }
        if (Array.isArray(elType)) {
          const arrayObj = formatter(data[key], elType, elType[0]);
          acc[key] = Object.values(arrayObj);
          return acc;
        }
        if (typeof elType === "object") {
          acc[key] = formatter(data[key], elType);
          return acc;
        }
        guard.unknown(data, type, key);
        return acc;
      }, {});
    }
    var AbiParser1 = class {
      constructor(abi) {
        this.abi = abi;
      }
      /**
       * abi method inputs length without '_len' inputs
       * cairo 0 reducer
       * @param abiMethod FunctionAbi
       * @returns number
       */
      methodInputsLength(abiMethod) {
        return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);
      }
      /**
       * get method definition from abi
       * @param name string
       * @returns FunctionAbi | undefined
       */
      getMethod(name) {
        return this.abi.find((it) => it.name === name);
      }
      /**
       * Get Abi in legacy format
       * @returns Abi
       */
      getLegacyFormat() {
        return this.abi;
      }
    };
    var AbiParser2 = class {
      constructor(abi) {
        this.abi = abi;
      }
      /**
       * abi method inputs length
       * @param abiMethod FunctionAbi
       * @returns number
       */
      methodInputsLength(abiMethod) {
        return abiMethod.inputs.length;
      }
      /**
       * get method definition from abi
       * @param name string
       * @returns FunctionAbi | undefined
       */
      getMethod(name) {
        const intf = this.abi.find((it) => it.type === "interface");
        return intf.items.find((it) => it.name === name);
      }
      /**
       * Get Abi in legacy format
       * @returns Abi
       */
      getLegacyFormat() {
        return this.abi.flatMap((e) => {
          if (e.type === "interface") {
            return e.items;
          }
          return e;
        });
      }
    };
    function createAbiParser(abi) {
      const version2 = getAbiVersion(abi);
      if (version2 === 0 || version2 === 1) {
        return new AbiParser1(abi);
      }
      if (version2 === 2) {
        return new AbiParser2(abi);
      }
      throw Error(`Unsupported ABI version ${version2}`);
    }
    function getAbiVersion(abi) {
      if (abi.find((it) => it.type === "interface"))
        return 2;
      if (isCairo1Abi(abi))
        return 1;
      return 0;
    }
    function isNoConstructorValid(method, argsCalldata, abiMethod) {
      return method === "constructor" && !abiMethod && !argsCalldata.length;
    }
    function parseNamedTuple(namedTuple) {
      const name = namedTuple.substring(0, namedTuple.indexOf(":"));
      const type = namedTuple.substring(name.length + ":".length);
      return { name, type };
    }
    function parseSubTuple(s) {
      if (!s.includes("("))
        return { subTuple: [], result: s };
      const subTuple = [];
      let result = "";
      let i = 0;
      while (i < s.length) {
        if (s[i] === "(") {
          let counter = 1;
          const lBracket = i;
          i++;
          while (counter) {
            if (s[i] === ")")
              counter--;
            if (s[i] === "(")
              counter++;
            i++;
          }
          subTuple.push(s.substring(lBracket, i));
          result += " ";
          i--;
        } else {
          result += s[i];
        }
        i++;
      }
      return {
        subTuple,
        result
      };
    }
    function extractCairo0Tuple(type) {
      const cleanType = type.replace(/\s/g, "").slice(1, -1);
      const { subTuple, result } = parseSubTuple(cleanType);
      let recomposed = result.split(",").map((it) => {
        return subTuple.length ? it.replace(" ", subTuple.shift()) : it;
      });
      if (isTypeNamedTuple(type)) {
        recomposed = recomposed.reduce((acc, it) => {
          return acc.concat(parseNamedTuple(it));
        }, []);
      }
      return recomposed;
    }
    function extractCairo1Tuple(type) {
      const cleanType = type.replace(/\s/g, "").slice(1, -1);
      const { subTuple, result } = parseSubTuple(cleanType);
      const recomposed = result.split(",").map((it) => {
        return subTuple.length ? it.replace(" ", subTuple.shift()) : it;
      });
      return recomposed;
    }
    function extractTupleMemberTypes(type) {
      if (isCairo1Type(type)) {
        return extractCairo1Tuple(type);
      }
      return extractCairo0Tuple(type);
    }
    function errorU256(key) {
      return Error(
        `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`
      );
    }
    function orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {
      const orderInput = (unorderedItem, abiType) => {
        if (isTypeArray(abiType)) {
          return orderArray(unorderedItem, abiType);
        }
        if (isTypeEnum(abiType, enums)) {
          const abiObj = enums[abiType];
          return orderEnum(unorderedItem, abiObj);
        }
        if (isTypeTuple(abiType)) {
          return orderTuple(unorderedItem, abiType);
        }
        if (isTypeEthAddress(abiType)) {
          return unorderedItem;
        }
        if (isTypeUint256(abiType)) {
          const u256 = unorderedItem;
          if (typeof u256 !== "object") {
            return u256;
          }
          if (!("low" in u256 && "high" in u256)) {
            throw errorU256(abiType);
          }
          return { low: u256.low, high: u256.high };
        }
        if (isTypeStruct(abiType, structs)) {
          const abiOfStruct = structs[abiType].members;
          return orderStruct(unorderedItem, abiOfStruct);
        }
        return unorderedItem;
      };
      const orderStruct = (unorderedObject2, abiObject) => {
        const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {
          const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
            enumerable: true,
            value: value ?? unorderedObject2[abiParam.name]
          });
          if (unorderedObject2[abiParam.name] === "undefined") {
            if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {
              throw Error(`Your object needs a property with key : ${abiParam.name} .`);
            }
          }
          setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));
          return orderedObject;
        }, {});
        return orderedObject2;
      };
      function orderArray(myArray, abiParam) {
        const typeInArray = getArrayType(abiParam);
        if (typeof myArray === "string") {
          return myArray;
        }
        return myArray.map((myElem) => orderInput(myElem, typeInArray));
      }
      function orderTuple(unorderedObject2, abiParam) {
        const typeList = extractTupleMemberTypes(abiParam);
        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {
          const myObjKeys = Object.keys(unorderedObject2);
          const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {
            enumerable: true,
            value: value ?? unorderedObject2[myObjKeys[index]]
          });
          const abiType = (abiTypeCairoX == null ? void 0 : abiTypeCairoX.type) ? abiTypeCairoX.type : abiTypeCairoX;
          setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));
          return orderedObject;
        }, {});
        return orderedObject2;
      }
      const orderEnum = (unorderedObject2, abiObject) => {
        if (isTypeResult(abiObject.name)) {
          const unorderedResult = unorderedObject2;
          const resultOkType = abiObject.name.substring(
            abiObject.name.indexOf("<") + 1,
            abiObject.name.lastIndexOf(",")
          );
          const resultErrType = abiObject.name.substring(
            abiObject.name.indexOf(",") + 1,
            abiObject.name.lastIndexOf(">")
          );
          if (unorderedResult.isOk()) {
            return new CairoResult(
              0,
              orderInput(unorderedObject2.unwrap(), resultOkType)
            );
          }
          return new CairoResult(
            1,
            orderInput(unorderedObject2.unwrap(), resultErrType)
          );
        }
        if (isTypeOption(abiObject.name)) {
          const unorderedOption = unorderedObject2;
          const resultSomeType = abiObject.name.substring(
            abiObject.name.indexOf("<") + 1,
            abiObject.name.lastIndexOf(">")
          );
          if (unorderedOption.isSome()) {
            return new CairoOption(
              0,
              orderInput(unorderedOption.unwrap(), resultSomeType)
            );
          }
          return new CairoOption(1, {});
        }
        const unorderedCustomEnum = unorderedObject2;
        const variants = Object.entries(unorderedCustomEnum.variant);
        const newEntries = variants.map((variant) => {
          if (typeof variant[1] === "undefined") {
            return variant;
          }
          const variantType = abiObject.type.substring(
            abiObject.type.lastIndexOf("<") + 1,
            abiObject.type.lastIndexOf(">")
          );
          if (variantType === "()") {
            return variant;
          }
          return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];
        });
        return new CairoCustomEnum(Object.fromEntries(newEntries));
      };
      const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {
        const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
          enumerable: true,
          value
        });
        if (isLen(abiParam.name)) {
          return orderedObject;
        }
        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));
        return orderedObject;
      }, {});
      return finalOrderedObject;
    }
    function parseBaseTypes(type, val) {
      switch (true) {
        case isTypeUint256(type):
          const el_uint256 = uint256(val);
          return [felt(el_uint256.low), felt(el_uint256.high)];
        default:
          return felt(val);
      }
    }
    function parseTuple(element, typeStr) {
      const memberTypes = extractTupleMemberTypes(typeStr);
      const elements = Object.values(element);
      if (elements.length !== memberTypes.length) {
        throw Error(
          `ParseTuple: provided and expected abi tuple size do not match.
      provided: ${elements} 
      expected: ${memberTypes}`
        );
      }
      return memberTypes.map((it, dx) => {
        return {
          element: elements[dx],
          type: it.type ?? it
        };
      });
    }
    function parseUint256(element) {
      if (typeof element === "object") {
        const { low, high } = element;
        return [felt(low), felt(high)];
      }
      const el_uint256 = uint256(element);
      return [felt(el_uint256.low), felt(el_uint256.high)];
    }
    function parseCalldataValue(element, type, structs, enums) {
      if (element === void 0) {
        throw Error(`Missing parameter for type ${type}`);
      }
      if (Array.isArray(element)) {
        const result = [];
        result.push(felt(element.length));
        const arrayType = getArrayType(type);
        return element.reduce((acc, it) => {
          return acc.concat(parseCalldataValue(it, arrayType, structs, enums));
        }, result);
      }
      if (structs[type] && structs[type].members.length) {
        if (isTypeUint256(type)) {
          return parseUint256(element);
        }
        if (type === "core::starknet::eth_address::EthAddress")
          return parseBaseTypes(type, element);
        const { members } = structs[type];
        const subElement = element;
        return members.reduce((acc, it) => {
          return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));
        }, []);
      }
      if (isTypeTuple(type)) {
        const tupled = parseTuple(element, type);
        return tupled.reduce((acc, it) => {
          const parsedData = parseCalldataValue(it.element, it.type, structs, enums);
          return acc.concat(parsedData);
        }, []);
      }
      if (isTypeUint256(type)) {
        return parseUint256(element);
      }
      if (isTypeEnum(type, enums)) {
        const { variants } = enums[type];
        if (isTypeOption(type)) {
          const myOption = element;
          if (myOption.isSome()) {
            const listTypeVariant2 = variants.find((variant) => variant.name === "Some");
            if (typeof listTypeVariant2 === "undefined") {
              throw Error(`Error in abi : Option has no 'Some' variant.`);
            }
            const typeVariantSome = listTypeVariant2.type;
            if (typeVariantSome === "()") {
              return 0 .toString();
            }
            const parsedParameter2 = parseCalldataValue(
              myOption.unwrap(),
              typeVariantSome,
              structs,
              enums
            );
            if (Array.isArray(parsedParameter2)) {
              return [0 .toString(), ...parsedParameter2];
            }
            return [0 .toString(), parsedParameter2];
          }
          return 1 .toString();
        }
        if (isTypeResult(type)) {
          const myResult = element;
          if (myResult.isOk()) {
            const listTypeVariant3 = variants.find((variant) => variant.name === "Ok");
            if (typeof listTypeVariant3 === "undefined") {
              throw Error(`Error in abi : Result has no 'Ok' variant.`);
            }
            const typeVariantOk = listTypeVariant3.type;
            if (typeVariantOk === "()") {
              return 0 .toString();
            }
            const parsedParameter3 = parseCalldataValue(
              myResult.unwrap(),
              typeVariantOk,
              structs,
              enums
            );
            if (Array.isArray(parsedParameter3)) {
              return [0 .toString(), ...parsedParameter3];
            }
            return [0 .toString(), parsedParameter3];
          }
          const listTypeVariant2 = variants.find((variant) => variant.name === "Err");
          if (typeof listTypeVariant2 === "undefined") {
            throw Error(`Error in abi : Result has no 'Err' variant.`);
          }
          const typeVariantErr = listTypeVariant2.type;
          if (typeVariantErr === "()") {
            return 1 .toString();
          }
          const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);
          if (Array.isArray(parsedParameter2)) {
            return [1 .toString(), ...parsedParameter2];
          }
          return [1 .toString(), parsedParameter2];
        }
        const myEnum = element;
        const activeVariant = myEnum.activeVariant();
        const listTypeVariant = variants.find((variant) => variant.name === activeVariant);
        if (typeof listTypeVariant === "undefined") {
          throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);
        }
        const typeActiveVariant = listTypeVariant.type;
        const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);
        if (typeActiveVariant === "()") {
          return numActiveVariant.toString();
        }
        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);
        if (Array.isArray(parsedParameter)) {
          return [numActiveVariant.toString(), ...parsedParameter];
        }
        return [numActiveVariant.toString(), parsedParameter];
      }
      if (typeof element === "object") {
        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);
      }
      return parseBaseTypes(type, element);
    }
    function parseCalldataField(argsIterator, input, structs, enums) {
      const { name, type } = input;
      let { value } = argsIterator.next();
      switch (true) {
        case isTypeArray(type):
          if (!Array.isArray(value) && !isText(value)) {
            throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);
          }
          if (typeof value === "string") {
            value = splitLongString(value);
          }
          return parseCalldataValue(value, input.type, structs, enums);
        case type === "core::starknet::eth_address::EthAddress":
          return parseBaseTypes(type, value);
        case (isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type)):
          return parseCalldataValue(value, type, structs, enums);
        case isTypeEnum(type, enums):
          return parseCalldataValue(
            value,
            type,
            structs,
            enums
          );
        default:
          return parseBaseTypes(type, value);
      }
    }
    function parseBaseTypes2(type, it) {
      let temp;
      switch (true) {
        case isTypeBool(type):
          temp = it.next().value;
          return Boolean(BigInt(temp));
        case isTypeUint256(type):
          const low = it.next().value;
          const high = it.next().value;
          return uint256ToBN({ low, high });
        case type === "core::starknet::eth_address::EthAddress":
          temp = it.next().value;
          return BigInt(temp);
        default:
          temp = it.next().value;
          return BigInt(temp);
      }
    }
    function parseResponseValue(responseIterator, element, structs, enums) {
      if (element.type === "()") {
        return {};
      }
      if (isTypeUint256(element.type)) {
        const low = responseIterator.next().value;
        const high = responseIterator.next().value;
        return uint256ToBN({ low, high });
      }
      if (isTypeArray(element.type)) {
        const parsedDataArr = [];
        const el = { name: "", type: getArrayType(element.type) };
        const len = BigInt(responseIterator.next().value);
        while (parsedDataArr.length < len) {
          parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
        }
        return parsedDataArr;
      }
      if (structs && element.type in structs && structs[element.type]) {
        if (element.type === "core::starknet::eth_address::EthAddress") {
          return parseBaseTypes2(element.type, responseIterator);
        }
        return structs[element.type].members.reduce((acc, el) => {
          acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);
          return acc;
        }, {});
      }
      if (enums && element.type in enums && enums[element.type]) {
        const variantNum = Number(responseIterator.next().value);
        const rawEnum = enums[element.type].variants.reduce((acc, variant, num2) => {
          if (num2 === variantNum) {
            acc[variant.name] = parseResponseValue(
              responseIterator,
              { name: "", type: variant.type },
              structs,
              enums
            );
            return acc;
          }
          acc[variant.name] = void 0;
          return acc;
        }, {});
        if (element.type.startsWith("core::option::Option")) {
          const content = variantNum === 0 ? rawEnum.Some : void 0;
          return new CairoOption(variantNum, content);
        }
        if (element.type.startsWith("core::result::Result")) {
          let content;
          if (variantNum === 0) {
            content = rawEnum.Ok;
          } else {
            content = rawEnum.Err;
          }
          return new CairoResult(variantNum, content);
        }
        const customEnum = new CairoCustomEnum(rawEnum);
        return customEnum;
      }
      if (isTypeTuple(element.type)) {
        const memberTypes = extractTupleMemberTypes(element.type);
        return memberTypes.reduce((acc, it, idx) => {
          const name = (it == null ? void 0 : it.name) ? it.name : idx;
          const type = (it == null ? void 0 : it.type) ? it.type : it;
          const el = { name, type };
          acc[name] = parseResponseValue(responseIterator, el, structs, enums);
          return acc;
        }, {});
      }
      if (isTypeArray(element.type)) {
        const parsedDataArr = [];
        const el = { name: "", type: getArrayType(element.type) };
        const len = BigInt(responseIterator.next().value);
        while (parsedDataArr.length < len) {
          parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
        }
        return parsedDataArr;
      }
      return parseBaseTypes2(element.type, responseIterator);
    }
    function responseParser(responseIterator, output, structs, enums, parsedResult) {
      const { name, type } = output;
      let temp;
      switch (true) {
        case isLen(name):
          temp = responseIterator.next().value;
          return BigInt(temp);
        case (structs && type in structs || isTypeTuple(type)):
          return parseResponseValue(responseIterator, output, structs, enums);
        case (enums && isTypeEnum(type, enums)):
          return parseResponseValue(responseIterator, output, structs, enums);
        case isTypeArray(type):
          if (isCairo1Type(type)) {
            return parseResponseValue(responseIterator, output, structs, enums);
          }
          const parsedDataArr = [];
          if (parsedResult && parsedResult[`${name}_len`]) {
            const arrLen = parsedResult[`${name}_len`];
            while (parsedDataArr.length < arrLen) {
              parsedDataArr.push(
                parseResponseValue(
                  responseIterator,
                  { name, type: output.type.replace("*", "") },
                  structs,
                  enums
                )
              );
            }
          }
          return parsedDataArr;
        default:
          return parseBaseTypes2(type, responseIterator);
      }
    }
    var validateFelt = (parameter, input) => {
      assert(
        typeof parameter === "string" || typeof parameter === "number" || typeof parameter === "bigint",
        `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`
      );
      if (typeof parameter === "string" && !isHex(parameter))
        return;
      const param = BigInt(parameter.toString(10));
      assert(
        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266
        param >= 0n && param <= 2n ** 252n - 1n,
        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
      );
    };
    var validateUint = (parameter, input) => {
      if (typeof parameter === "number") {
        assert(
          parameter <= Number.MAX_SAFE_INTEGER,
          `Validation: Parameter is to large to be typed as Number use (BigInt or String)`
        );
      }
      assert(
        typeof parameter === "string" || typeof parameter === "number" || typeof parameter === "bigint" || typeof parameter === "object" && "low" in parameter && "high" in parameter,
        `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`
      );
      const param = typeof parameter === "object" ? uint256ToBN(parameter) : toBigInt(parameter);
      switch (input.type) {
        case "core::integer::u8":
          assert(
            param >= 0n && param <= 255n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`
          );
          break;
        case "core::integer::u16":
          assert(
            param >= 0n && param <= 65535n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`
          );
          break;
        case "core::integer::u32":
          assert(
            param >= 0n && param <= 4294967295n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`
          );
          break;
        case "core::integer::u64":
          assert(
            param >= 0n && param <= 2n ** 64n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`
          );
          break;
        case "core::integer::u128":
          assert(
            param >= 0n && param <= 2n ** 128n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`
          );
          break;
        case "core::integer::u256":
          assert(
            param >= 0n && param <= 2n ** 256n - 1n,
            `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`
          );
          break;
        case "core::starknet::class_hash::ClassHash":
          assert(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670
            param >= 0n && param <= 2n ** 252n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
          );
          break;
        case "core::starknet::contract_address::ContractAddress":
          assert(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245
            param >= 0n && param <= 2n ** 252n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
          );
          break;
        default:
          break;
      }
    };
    var validateBool = (parameter, input) => {
      assert(
        typeof parameter === "boolean",
        `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`
      );
    };
    var validateStruct = (parameter, input, structs) => {
      if (input.type === "core::integer::u256") {
        validateUint(parameter, input);
        return;
      }
      if (input.type === "core::starknet::eth_address::EthAddress") {
        assert(
          typeof parameter !== "object",
          `EthAdress type is waiting a BigNumberish. Got ${parameter}`
        );
        const param = BigInt(parameter.toString(10));
        assert(
          // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259
          param >= 0n && param <= 2n ** 160n - 1n,
          `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`
        );
        return;
      }
      assert(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`
      );
      structs[input.type].members.forEach(({ name }) => {
        assert(
          Object.keys(parameter).includes(name),
          `Validate: arg ${input.name} should have a property ${name}`
        );
      });
    };
    var validateEnum = (parameter, input) => {
      assert(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`
      );
      const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));
      const keys2 = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];
      if (isTypeOption(input.type) && keys2.includes("isSome") && keys2.includes("isNone")) {
        return;
      }
      if (isTypeResult(input.type) && keys2.includes("isOk") && keys2.includes("isErr")) {
        return;
      }
      if (keys2.includes("variant") && keys2.includes("activeVariant")) {
        return;
      }
      throw new Error(
        `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`
      );
    };
    var validateTuple = (parameter, input) => {
      assert(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} should be a tuple (defined as object)`
      );
    };
    var validateArray = (parameter, input, structs, enums) => {
      const baseType = getArrayType(input.type);
      if (isTypeFelt(baseType) && isLongText(parameter)) {
        return;
      }
      assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);
      switch (true) {
        case isTypeFelt(baseType):
          parameter.forEach((param) => validateFelt(param, input));
          break;
        case isTypeTuple(baseType):
          parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));
          break;
        case isTypeArray(baseType):
          parameter.forEach(
            (param) => validateArray(param, { name: "", type: baseType }, structs, enums)
          );
          break;
        case isTypeStruct(baseType, structs):
          parameter.forEach(
            (it) => validateStruct(it, { name: input.name, type: baseType }, structs)
          );
          break;
        case isTypeEnum(baseType, enums):
          parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));
          break;
        case (isTypeUint(baseType) || isTypeLitteral(baseType)):
          parameter.forEach((param) => validateUint(param, input));
          break;
        case isTypeBool(baseType):
          parameter.forEach((param) => validateBool(param, input));
          break;
        default:
          throw new Error(
            `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`
          );
      }
    };
    function validateFields(abiMethod, args, structs, enums) {
      abiMethod.inputs.reduce((acc, input) => {
        const parameter = args[acc];
        switch (true) {
          case isLen(input.name):
            return acc;
          case isTypeFelt(input.type):
            validateFelt(parameter, input);
            break;
          case (isTypeUint(input.type) || isTypeLitteral(input.type)):
            validateUint(parameter, input);
            break;
          case isTypeBool(input.type):
            validateBool(parameter, input);
            break;
          case isTypeArray(input.type):
            validateArray(parameter, input, structs, enums);
            break;
          case isTypeStruct(input.type, structs):
            validateStruct(parameter, input, structs);
            break;
          case isTypeEnum(input.type, enums):
            validateEnum(parameter, input);
            break;
          case isTypeTuple(input.type):
            validateTuple(parameter, input);
            break;
          default:
            throw new Error(
              `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`
            );
        }
        return acc + 1;
      }, 0);
    }
    var CallData = class {
      constructor(abi) {
        this.structs = CallData.getAbiStruct(abi);
        this.enums = CallData.getAbiEnum(abi);
        this.parser = createAbiParser(abi);
        this.abi = this.parser.getLegacyFormat();
      }
      /**
       * Validate arguments passed to the method as corresponding to the ones in the abi
       * @param type ValidateType - type of the method
       * @param method string - name of the method
       * @param args ArgsOrCalldata - arguments that are passed to the method
       */
      validate(type, method, args = []) {
        if (type !== "DEPLOY") {
          const invocableFunctionNames = this.abi.filter((abi) => {
            if (abi.type !== "function")
              return false;
            const isView = abi.stateMutability === "view" || abi.state_mutability === "view";
            return type === "INVOKE" ? !isView : isView;
          }).map((abi) => abi.name);
          assert(
            invocableFunctionNames.includes(method),
            `${type === "INVOKE" ? "invocable" : "viewable"} method not found in abi`
          );
        }
        const abiMethod = this.abi.find(
          (abi) => type === "DEPLOY" ? abi.name === method && abi.type === "constructor" : abi.name === method && abi.type === "function"
        );
        if (isNoConstructorValid(method, args, abiMethod)) {
          return;
        }
        const inputsLength = this.parser.methodInputsLength(abiMethod);
        if (args.length !== inputsLength) {
          throw Error(
            `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`
          );
        }
        validateFields(abiMethod, args, this.structs, this.enums);
      }
      /**
       * Compile contract callData with abi
       * Parse the calldata by using input fields from the abi for that method
       * @param method string - method name
       * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
       * @return Calldata - parsed arguments in format that contract is expecting
       * @example
       * ```typescript
       * const calldata = myCallData.compile("constructor",["0x34a",[1,3n]]);
       * ```
       * ```typescript
       * const calldata2 = myCallData.compile("constructor",{list:[1,3n],balance:"0x34"}); // wrong order is valid
       * ```
       */
      compile(method, argsCalldata) {
        const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);
        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {
          return [];
        }
        let args;
        if (Array.isArray(argsCalldata)) {
          args = argsCalldata;
        } else {
          const orderedObject = orderPropsByAbi(
            argsCalldata,
            abiMethod.inputs,
            this.structs,
            this.enums
          );
          args = Object.values(orderedObject);
          validateFields(abiMethod, args, this.structs, this.enums);
        }
        const argsIterator = args[Symbol.iterator]();
        const callArray = abiMethod.inputs.reduce(
          (acc, input) => isLen(input.name) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),
          []
        );
        Object.defineProperty(callArray, "__compiled__", {
          enumerable: false,
          writable: false,
          value: true
        });
        return callArray;
      }
      /**
       * Compile contract callData without abi
       * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
       * @returns Calldata
       */
      static compile(rawArgs) {
        const createTree = (obj) => {
          const getEntries = (o, prefix = ".") => {
            const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;
            return Object.entries(oe).flatMap(([k, v]) => {
              let value = v;
              if (isLongText(value))
                value = splitLongString(value);
              if (k === "entrypoint")
                value = getSelectorFromName(value);
              const kk = Array.isArray(oe) && k === "0" ? "$$len" : k;
              if (isBigInt(value))
                return [[`${prefix}${kk}`, felt(value)]];
              if (Object(value) === value) {
                const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));
                const keys2 = [...Object.getOwnPropertyNames(value), ...methodsKeys];
                if (keys2.includes("isSome") && keys2.includes("isNone")) {
                  const myOption = value;
                  const variantNb = myOption.isSome() ? 0 : 1;
                  if (myOption.isSome())
                    return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);
                  return [[`${prefix}${kk}`, felt(variantNb)]];
                }
                if (keys2.includes("isOk") && keys2.includes("isErr")) {
                  const myResult = value;
                  const variantNb = myResult.isOk() ? 0 : 1;
                  return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);
                }
                if (keys2.includes("variant") && keys2.includes("activeVariant")) {
                  const myEnum = value;
                  const activeVariant = myEnum.activeVariant();
                  const listVariants = Object.keys(myEnum.variant);
                  const activeVariantNb = listVariants.findIndex(
                    (variant) => variant === activeVariant
                  );
                  if (typeof myEnum.unwrap() === "object" && Object.keys(myEnum.unwrap()).length === 0) {
                    return [[`${prefix}${kk}`, felt(activeVariantNb)]];
                  }
                  return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);
                }
                return getEntries(value, `${prefix}${kk}.`);
              }
              return [[`${prefix}${kk}`, felt(value)]];
            });
          };
          const result = Object.fromEntries(getEntries(obj));
          return result;
        };
        let callTreeArray;
        if (!Array.isArray(rawArgs)) {
          const callTree = createTree(rawArgs);
          callTreeArray = Object.values(callTree);
        } else {
          const callObj = { ...rawArgs };
          const callTree = createTree(callObj);
          callTreeArray = Object.values(callTree);
        }
        Object.defineProperty(callTreeArray, "__compiled__", {
          enumerable: false,
          writable: false,
          value: true
        });
        return callTreeArray;
      }
      /**
       * Parse elements of the response array and structuring them into response object
       * @param method string - method name
       * @param response string[] - response from the method
       * @return Result - parsed response corresponding to the abi
       */
      parse(method, response) {
        const { outputs } = this.abi.find((abi) => abi.name === method);
        const responseIterator = response.flat()[Symbol.iterator]();
        const parsed = outputs.flat().reduce((acc, output, idx) => {
          const propName = output.name ?? idx;
          acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);
          if (acc[propName] && acc[`${propName}_len`]) {
            delete acc[`${propName}_len`];
          }
          return acc;
        }, {});
        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;
      }
      /**
       * Format cairo method response data to native js values based on provided format schema
       * @param method string - cairo method name
       * @param response string[] - cairo method response
       * @param format object - formatter object schema
       * @returns Result - parsed and formatted response object
       */
      format(method, response, format) {
        const parsed = this.parse(method, response);
        return formatter(parsed, format);
      }
      /**
       * Helper to extract structs from abi
       * @param abi Abi
       * @returns AbiStructs - structs from abi
       */
      static getAbiStruct(abi) {
        return abi.filter((abiEntry) => abiEntry.type === "struct").reduce(
          (acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }),
          {}
        );
      }
      /**
       * Helper to extract enums from abi
       * @param abi Abi
       * @returns AbiEnums - enums from abi
       */
      static getAbiEnum(abi) {
        const fullEnumList = abi.filter((abiEntry) => abiEntry.type === "enum").reduce(
          (acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }),
          {}
        );
        delete fullEnumList["core::bool"];
        return fullEnumList;
      }
      /**
       * Helper: Compile HexCalldata | RawCalldata | RawArgs
       * @param rawCalldata HexCalldata | RawCalldata | RawArgs
       * @returns Calldata
       */
      static toCalldata(rawCalldata = []) {
        return CallData.compile(rawCalldata);
      }
      /**
       * Helper: Convert raw to HexCalldata
       * @param raw HexCalldata | RawCalldata | RawArgs
       * @returns HexCalldata
       */
      static toHex(raw = []) {
        const calldata = CallData.compile(raw);
        return calldata.map((it) => toHex(it));
      }
    };
    var hash_exports = {};
    __export2(hash_exports, {
      calculateContractAddressFromHash: () => calculateContractAddressFromHash,
      calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,
      calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,
      calculateDeployTransactionHash: () => calculateDeployTransactionHash,
      calculateTransactionHash: () => calculateTransactionHash,
      calculateTransactionHashCommon: () => calculateTransactionHashCommon,
      computeCompiledClassHash: () => computeCompiledClassHash,
      computeContractClassHash: () => computeContractClassHash,
      computeHashOnElements: () => computeHashOnElements,
      computeLegacyContractClassHash: () => computeLegacyContractClassHash,
      computeSierraContractClassHash: () => computeSierraContractClassHash,
      default: () => computeHintedClassHash,
      feeTransactionVersion: () => feeTransactionVersion,
      feeTransactionVersion_2: () => feeTransactionVersion_2,
      formatSpaces: () => formatSpaces,
      getSelector: () => getSelector,
      getSelectorFromName: () => getSelectorFromName,
      getVersionsByType: () => getVersionsByType,
      keccakBn: () => keccakBn,
      poseidon: () => poseidon,
      starknetKeccak: () => starknetKeccak,
      transactionVersion: () => transactionVersion,
      transactionVersion_2: () => transactionVersion_2
    });
    var import_starknet2 = require_lib3();
    var ec_exports = {};
    __export2(ec_exports, {
      starkCurve: () => starkCurve,
      weierstrass: () => weierstrass
    });
    var starkCurve = __toESM(require_lib3());
    var weierstrass = __toESM(require_weierstrass());
    var json_exports = {};
    __export2(json_exports, {
      parse: () => parse2,
      parseAlwaysAsBig: () => parseAlwaysAsBig,
      stringify: () => stringify2,
      stringifyAlwaysAsBig: () => stringifyAlwaysAsBig
    });
    var json = __toESM(require_lossless_json());
    var parseIntAsNumberOrBigInt = (x) => {
      if (!json.isInteger(x))
        return parseFloat(x);
      const v = parseInt(x, 10);
      return Number.isSafeInteger(v) ? v : BigInt(x);
    };
    var parse2 = (x) => json.parse(String(x), void 0, parseIntAsNumberOrBigInt);
    var parseAlwaysAsBig = (x) => json.parse(String(x), void 0, json.parseNumberAndBigInt);
    var stringify2 = (value, replacer, space, numberStringifiers) => json.stringify(value, replacer, space, numberStringifiers);
    var stringifyAlwaysAsBig = stringify2;
    var poseidon = __toESM(require_poseidon());
    var transactionVersion = 1n;
    var transactionVersion_2 = 2n;
    var feeTransactionVersion = 2n ** 128n + transactionVersion;
    var feeTransactionVersion_2 = 2n ** 128n + transactionVersion_2;
    function getVersionsByType(versionType) {
      return versionType === "fee" ? { v1: feeTransactionVersion, v2: feeTransactionVersion_2 } : { v1: transactionVersion, v2: transactionVersion_2 };
    }
    function computeHashOnElements(data) {
      return [...data, data.length].reduce((x, y) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0).toString();
    }
    function calculateTransactionHashCommon(txHashPrefix, version2, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {
      const calldataHash = computeHashOnElements(calldata);
      const dataToHash = [
        txHashPrefix,
        version2,
        contractAddress,
        entryPointSelector,
        calldataHash,
        maxFee,
        chainId,
        ...additionalData
      ];
      return computeHashOnElements(dataToHash);
    }
    function calculateDeployTransactionHash(contractAddress, constructorCalldata, version2, chainId, constructorName = "constructor") {
      return calculateTransactionHashCommon(
        "0x6465706c6f79",
        version2,
        contractAddress,
        getSelectorFromName(constructorName),
        constructorCalldata,
        0,
        chainId
      );
    }
    function calculateDeclareTransactionHash(classHash, senderAddress, version2, maxFee, chainId, nonce, compiledClassHash) {
      return calculateTransactionHashCommon(
        "0x6465636c617265",
        version2,
        senderAddress,
        0,
        [classHash],
        maxFee,
        chainId,
        [nonce, ...compiledClassHash ? [compiledClassHash] : []]
      );
    }
    function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version2, maxFee, chainId, nonce) {
      const calldata = [classHash, salt, ...constructorCalldata];
      return calculateTransactionHashCommon(
        "0x6465706c6f795f6163636f756e74",
        version2,
        contractAddress,
        0,
        calldata,
        maxFee,
        chainId,
        [nonce]
      );
    }
    function calculateTransactionHash(contractAddress, version2, calldata, maxFee, chainId, nonce) {
      return calculateTransactionHashCommon(
        "0x696e766f6b65",
        version2,
        contractAddress,
        0,
        calldata,
        maxFee,
        chainId,
        [nonce]
      );
    }
    function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
      const compiledCalldata = CallData.compile(constructorCalldata);
      const constructorCalldataHash = computeHashOnElements(compiledCalldata);
      const CONTRACT_ADDRESS_PREFIX = felt("0x535441524b4e45545f434f4e54524143545f41444452455353");
      return computeHashOnElements([
        CONTRACT_ADDRESS_PREFIX,
        deployerAddress,
        salt,
        classHash,
        constructorCalldataHash
      ]);
    }
    function nullSkipReplacer(key, value) {
      if (key === "attributes" || key === "accessible_scopes") {
        return Array.isArray(value) && value.length === 0 ? void 0 : value;
      }
      if (key === "debug_info") {
        return null;
      }
      return value === null ? void 0 : value;
    }
    function formatSpaces(json2) {
      let insideQuotes = false;
      const newString = [];
      for (const char of json2) {
        if (char === '"' && (newString.length > 0 && newString.slice(-1)[0] === "\\") === false) {
          insideQuotes = !insideQuotes;
        }
        if (insideQuotes) {
          newString.push(char);
        } else {
          newString.push(char === ":" ? ": " : char === "," ? ", " : char);
        }
      }
      return newString.join("");
    }
    function computeHintedClassHash(compiledContract) {
      const { abi, program } = compiledContract;
      const contractClass = { abi, program };
      const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));
      return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));
    }
    function computeLegacyContractClassHash(contract) {
      const compiledContract = typeof contract === "string" ? parse2(contract) : contract;
      const apiVersion = toHex(API_VERSION);
      const externalEntryPointsHash = computeHashOnElements(
        compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])
      );
      const l1HandlerEntryPointsHash = computeHashOnElements(
        compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])
      );
      const constructorEntryPointHash = computeHashOnElements(
        compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])
      );
      const builtinsHash = computeHashOnElements(
        compiledContract.program.builtins.map((s) => encodeShortString(s))
      );
      const hintedClassHash = computeHintedClassHash(compiledContract);
      const dataHash = computeHashOnElements(compiledContract.program.data);
      return computeHashOnElements([
        apiVersion,
        externalEntryPointsHash,
        l1HandlerEntryPointsHash,
        constructorEntryPointHash,
        builtinsHash,
        hintedClassHash,
        dataHash
      ]);
    }
    function hashBuiltins(builtins) {
      return (0, import_starknet2.poseidonHashMany)(
        builtins.flatMap((it) => {
          return BigInt(encodeShortString(it));
        })
      );
    }
    function hashEntryPoint(data) {
      const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];
      });
      return (0, import_starknet2.poseidonHashMany)(base);
    }
    function computeCompiledClassHash(casm) {
      const COMPILED_CLASS_VERSION = "COMPILED_CLASS_V1";
      const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));
      const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);
      const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);
      const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);
      const bytecode = (0, import_starknet2.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));
      return toHex(
        (0, import_starknet2.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          bytecode
        ])
      );
    }
    function hashEntryPointSierra(data) {
      const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.function_idx)];
      });
      return (0, import_starknet2.poseidonHashMany)(base);
    }
    function hashAbi(sierra) {
      const indentString = formatSpaces(stringify2(sierra.abi, null));
      return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));
    }
    function computeSierraContractClassHash(sierra) {
      const CONTRACT_CLASS_VERSION = "CONTRACT_CLASS_V0.1.0";
      const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));
      const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);
      const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);
      const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);
      const abiHash = hashAbi(sierra);
      const sierraProgram = (0, import_starknet2.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));
      return toHex(
        (0, import_starknet2.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          abiHash,
          sierraProgram
        ])
      );
    }
    function computeContractClassHash(contract) {
      const compiledContract = typeof contract === "string" ? parse2(contract) : contract;
      if ("sierra_program" in compiledContract) {
        return computeSierraContractClassHash(compiledContract);
      }
      return computeLegacyContractClassHash(compiledContract);
    }
    var stark_exports = {};
    __export2(stark_exports, {
      compressProgram: () => compressProgram,
      decompressProgram: () => decompressProgram,
      estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,
      formatSignature: () => formatSignature,
      makeAddress: () => makeAddress,
      randomAddress: () => randomAddress,
      signatureToDecimalArray: () => signatureToDecimalArray,
      signatureToHexArray: () => signatureToHexArray
    });
    var import_starknet3 = require_lib3();
    var import_pako = require_pako();
    function compressProgram(jsonProgram) {
      const stringified = typeof jsonProgram === "string" ? jsonProgram : stringify2(jsonProgram);
      const compressedProgram = (0, import_pako.gzip)(stringified);
      return btoaUniversal(compressedProgram);
    }
    function decompressProgram(base64) {
      if (Array.isArray(base64))
        return base64;
      const decompressed = arrayBufferToString((0, import_pako.ungzip)(atobUniversal(base64)));
      return parse2(decompressed);
    }
    function randomAddress() {
      const randomKeyPair = import_starknet3.utils.randomPrivateKey();
      return (0, import_starknet3.getStarkKey)(randomKeyPair);
    }
    function makeAddress(input) {
      return addHexPrefix(input).toLowerCase();
    }
    function formatSignature(sig) {
      if (!sig)
        throw Error("formatSignature: provided signature is undefined");
      if (Array.isArray(sig)) {
        return sig.map((it) => toHex(it));
      }
      try {
        const { r, s } = sig;
        return [toHex(r), toHex(s)];
      } catch (e) {
        throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
      }
    }
    function signatureToDecimalArray(sig) {
      return bigNumberishArrayToDecimalStringArray(formatSignature(sig));
    }
    function signatureToHexArray(sig) {
      return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));
    }
    function estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {
      const overHeadPercent = Math.round((1 + overhead) * 100);
      return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;
    }
    function isSierra(contract) {
      const compiledContract = typeof contract === "string" ? parse2(contract) : contract;
      return "sierra_program" in compiledContract;
    }
    function extractContractHashes(payload) {
      const response = { ...payload };
      if (isSierra(payload.contract)) {
        if (!payload.compiledClassHash && payload.casm) {
          response.compiledClassHash = computeCompiledClassHash(payload.casm);
        }
        if (!response.compiledClassHash)
          throw new Error(
            "Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash"
          );
      }
      response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);
      if (!response.classHash)
        throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
      return response;
    }
    function contractClassResponseToLegacyCompiledContract(ccr) {
      if (isSierra(ccr)) {
        throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");
      }
      const contract = ccr;
      return { ...contract, program: decompressProgram(contract.program) };
    }
    var import_isomorphic_fetch = __toESM(require_fetch_npm_browserify());
    var fetchPonyfill_default = typeof window !== "undefined" && window.fetch || // use buildin fetch in browser if available
    typeof global !== "undefined" && global.fetch || // use buildin fetch in node, react-native and service worker if available
    import_isomorphic_fetch.default;
    var provider_exports = {};
    __export2(provider_exports, {
      createSierraContractClass: () => createSierraContractClass,
      parseContract: () => parseContract,
      wait: () => wait
    });
    function wait(delay) {
      return new Promise((res) => {
        setTimeout(res, delay);
      });
    }
    function createSierraContractClass(contract) {
      const result = { ...contract };
      delete result.sierra_program_debug_info;
      result.abi = formatSpaces(stringify2(contract.abi));
      result.sierra_program = formatSpaces(stringify2(contract.sierra_program));
      result.sierra_program = compressProgram(result.sierra_program);
      return result;
    }
    function parseContract(contract) {
      const parsedContract = typeof contract === "string" ? parse2(contract) : contract;
      if (!isSierra(contract)) {
        return {
          ...parsedContract,
          ..."program" in parsedContract && { program: compressProgram(parsedContract.program) }
        };
      }
      return createSierraContractClass(parsedContract);
    }
    var RPCResponseParser = class {
      parseGetBlockResponse(res) {
        return {
          timestamp: res.timestamp,
          block_hash: res.block_hash,
          block_number: res.block_number,
          new_root: res.new_root,
          parent_hash: res.parent_hash,
          status: res.status,
          transactions: res.transactions
        };
      }
      parseGetTransactionResponse(res) {
        return {
          calldata: res.calldata || [],
          contract_address: res.contract_address,
          sender_address: res.contract_address,
          max_fee: res.max_fee,
          nonce: res.nonce,
          signature: res.signature || [],
          transaction_hash: res.transaction_hash,
          version: res.version
        };
      }
      parseFeeEstimateResponse(res) {
        return {
          overall_fee: toBigInt(res[0].overall_fee),
          gas_consumed: toBigInt(res[0].gas_consumed),
          gas_price: toBigInt(res[0].gas_price)
        };
      }
      parseFeeEstimateBulkResponse(res) {
        return res.map((val) => ({
          overall_fee: toBigInt(val.overall_fee),
          gas_consumed: toBigInt(val.gas_consumed),
          gas_price: toBigInt(val.gas_price)
        }));
      }
      parseCallContractResponse(res) {
        return {
          result: res
        };
      }
      parseSimulateTransactionResponse(res) {
        return res.map((it) => {
          return {
            ...it,
            suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))
          };
        });
      }
      parseContractClassResponse(res) {
        return {
          ...res,
          abi: typeof res.abi === "string" ? JSON.parse(res.abi) : res.abi
        };
      }
    };
    function fixStack(target, fn = target.constructor) {
      const { captureStackTrace } = Error;
      captureStackTrace && captureStackTrace(target, fn);
    }
    function fixProto(target, prototype) {
      const { setPrototypeOf } = Object;
      setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
    }
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        Object.defineProperty(this, "name", {
          value: new.target.name,
          enumerable: false,
          configurable: true
        });
        fixProto(this, new.target.prototype);
        fixStack(this);
      }
    };
    var LibraryError = class extends CustomError {
    };
    var GatewayError = class extends LibraryError {
      constructor(message, errorCode) {
        super(message);
        this.errorCode = errorCode;
      }
    };
    var HttpError = class extends LibraryError {
      constructor(message, errorCode) {
        super(message);
        this.errorCode = errorCode;
      }
    };
    var starknetId_exports = {};
    __export2(starknetId_exports, {
      StarknetIdContract: () => StarknetIdContract,
      getStarknetIdContract: () => getStarknetIdContract,
      useDecoded: () => useDecoded,
      useEncoded: () => useEncoded
    });
    var basicAlphabet = "abcdefghijklmnopqrstuvwxyz0123456789-";
    var basicSizePlusOne = BigInt(basicAlphabet.length + 1);
    var bigAlphabet = "";
    var basicAlphabetSize = BigInt(basicAlphabet.length);
    var bigAlphabetSize = BigInt(bigAlphabet.length);
    var bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);
    function extractStars(str) {
      let k = 0;
      while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {
        str = str.substring(0, str.length - 1);
        k += 1;
      }
      return [str, k];
    }
    function useDecoded(encoded) {
      let decoded = "";
      encoded.forEach((subdomain) => {
        while (subdomain !== ZERO) {
          const code = subdomain % basicSizePlusOne;
          subdomain /= basicSizePlusOne;
          if (code === BigInt(basicAlphabet.length)) {
            const nextSubdomain = subdomain / bigAlphabetSizePlusOne;
            if (nextSubdomain === ZERO) {
              const code2 = subdomain % bigAlphabetSizePlusOne;
              subdomain = nextSubdomain;
              if (code2 === ZERO)
                decoded += basicAlphabet[0];
              else
                decoded += bigAlphabet[Number(code2) - 1];
            } else {
              const code2 = subdomain % bigAlphabetSize;
              decoded += bigAlphabet[Number(code2)];
              subdomain /= bigAlphabetSize;
            }
          } else
            decoded += basicAlphabet[Number(code)];
        }
        const [str, k] = extractStars(decoded);
        if (k)
          decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));
        decoded += ".";
      });
      if (!decoded) {
        return decoded;
      }
      return decoded.concat("stark");
    }
    function useEncoded(decoded) {
      let encoded = BigInt(0);
      let multiplier = BigInt(1);
      if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));
        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));
      } else {
        const [str, k] = extractStars(decoded);
        if (k)
          decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));
      }
      for (let i = 0; i < decoded.length; i += 1) {
        const char = decoded[i];
        const index = basicAlphabet.indexOf(char);
        const bnIndex = BigInt(basicAlphabet.indexOf(char));
        if (index !== -1) {
          if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {
            encoded += multiplier * basicAlphabetSize;
            multiplier *= basicSizePlusOne;
            multiplier *= basicSizePlusOne;
          } else {
            encoded += multiplier * bnIndex;
            multiplier *= basicSizePlusOne;
          }
        } else if (bigAlphabet.indexOf(char) !== -1) {
          encoded += multiplier * basicAlphabetSize;
          multiplier *= basicSizePlusOne;
          const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
          encoded += multiplier * BigInt(newid);
          multiplier *= bigAlphabetSize;
        }
      }
      return encoded;
    }
    var StarknetIdContract = ((StarknetIdContract2) => {
      StarknetIdContract2["MAINNET"] = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
      StarknetIdContract2["TESTNET"] = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
      return StarknetIdContract2;
    })(StarknetIdContract || {});
    function getStarknetIdContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
        case "0x534e5f474f45524c49":
          return "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
        default:
          throw new Error("Starknet.id is not yet deployed on this network");
      }
    }
    async function getStarkName(provider2, address, StarknetIdContract2) {
      const chainId = await provider2.getChainId();
      const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
      try {
        const hexDomain = await provider2.callContract({
          contractAddress: contract,
          entrypoint: "address_to_domain",
          calldata: CallData.compile({
            address
          })
        });
        const decimalDomain = hexDomain.result.map((element) => BigInt(element)).slice(1);
        const stringDomain = useDecoded(decimalDomain);
        if (!stringDomain) {
          throw Error("Starkname not found");
        }
        return stringDomain;
      } catch (e) {
        if (e instanceof Error && e.message === "Starkname not found") {
          throw e;
        }
        throw Error("Could not get stark name");
      }
    }
    async function getAddressFromStarkName(provider2, name, StarknetIdContract2) {
      const chainId = await provider2.getChainId();
      const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
      try {
        const addressData = await provider2.callContract({
          contractAddress: contract,
          entrypoint: "domain_to_address",
          calldata: CallData.compile({
            domain: [useEncoded(name.replace(".stark", "")).toString(10)]
          })
        });
        return addressData.result[0];
      } catch {
        throw Error("Could not get address from stark name");
      }
    }
    var validBlockTags = Object.values(BlockTag);
    var Block = class {
      constructor(_identifier) {
        this.hash = null;
        this.number = null;
        this.tag = null;
        this.valueOf = () => this.number;
        this.toString = () => this.hash;
        this.setIdentifier(_identifier);
      }
      setIdentifier(__identifier) {
        if (typeof __identifier === "string" && isHex(__identifier)) {
          this.hash = __identifier;
        } else if (typeof __identifier === "bigint") {
          this.hash = toHex(__identifier);
        } else if (typeof __identifier === "number") {
          this.number = __identifier;
        } else if (typeof __identifier === "string" && validBlockTags.includes(__identifier)) {
          this.tag = __identifier;
        } else {
          this.tag = "pending";
        }
      }
      // TODO: fix any
      get queryIdentifier() {
        if (this.number !== null) {
          return `blockNumber=${this.number}`;
        }
        if (this.hash !== null) {
          return `blockHash=${this.hash}`;
        }
        return `blockNumber=${this.tag}`;
      }
      // TODO: fix any
      get identifier() {
        if (this.number !== null) {
          return { block_number: this.number };
        }
        if (this.hash !== null) {
          return { block_hash: this.hash };
        }
        return this.tag;
      }
      set identifier(_identifier) {
        this.setIdentifier(_identifier);
      }
      get sequencerIdentifier() {
        return this.hash !== null ? { blockHash: this.hash } : { blockNumber: this.number ?? this.tag };
      }
    };
    var defaultOptions = {
      headers: { "Content-Type": "application/json" },
      blockIdentifier: "pending",
      retries: 200
    };
    var RpcProvider = class {
      constructor(optionsOrProvider) {
        this.responseParser = new RPCResponseParser();
        const { nodeUrl, retries, headers, blockIdentifier, chainId } = optionsOrProvider;
        this.nodeUrl = nodeUrl;
        this.retries = retries || defaultOptions.retries;
        this.headers = { ...defaultOptions.headers, ...headers };
        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;
        this.chainId = chainId;
        this.getChainId();
      }
      fetch(method, params) {
        const body = stringify2({ method, jsonrpc: "2.0", params, id: 0 });
        return fetchPonyfill_default(this.nodeUrl, {
          method: "POST",
          body,
          headers: this.headers
        });
      }
      errorHandler(error) {
        if (error) {
          const { code, message } = error;
          throw new LibraryError(`${code}: ${message}`);
        }
      }
      async fetchEndpoint(method, params) {
        var _a;
        try {
          const rawResult = await this.fetch(method, params);
          const { error, result } = await rawResult.json();
          this.errorHandler(error);
          return result;
        } catch (error) {
          this.errorHandler((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.data);
          throw error;
        }
      }
      // Methods from Interface
      async getChainId() {
        this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId"));
        return this.chainId;
      }
      async getBlock(blockIdentifier = this.blockIdentifier) {
        return this.getBlockWithTxHashes(blockIdentifier).then(
          this.responseParser.parseGetBlockResponse
        );
      }
      async getBlockHashAndNumber() {
        return this.fetchEndpoint("starknet_blockHashAndNumber");
      }
      async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id });
      }
      async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id });
      }
      async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassHashAt", {
          block_id,
          contract_address: contractAddress
        });
      }
      async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getNonce", {
          contract_address: contractAddress,
          block_id
        });
      }
      async getPendingTransactions() {
        return this.fetchEndpoint("starknet_pendingTransactions");
      }
      async getProtocolVersion() {
        throw new Error("Pathfinder does not implement this rpc 0.1.0 method");
      }
      async getStateUpdate(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStateUpdate", { block_id });
      }
      async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
        const parsedKey = toStorageKey(key);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStorageAt", {
          contract_address: contractAddress,
          key: parsedKey,
          block_id
        });
      }
      // Methods from Interface
      async getTransaction(txHash) {
        return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);
      }
      async getTransactionByHash(txHash) {
        return this.fetchEndpoint("starknet_getTransactionByHash", { transaction_hash: txHash });
      }
      async getTransactionByBlockIdAndIndex(blockIdentifier, index) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id, index });
      }
      async getTransactionReceipt(txHash) {
        return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash: txHash });
      }
      async getClassByHash(classHash) {
        return this.getClass(classHash);
      }
      async getClass(classHash, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClass", {
          class_hash: classHash,
          block_id
        }).then(this.responseParser.parseContractClassResponse);
      }
      async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassAt", {
          block_id,
          contract_address: contractAddress
        }).then(this.responseParser.parseContractClassResponse);
      }
      async getCode(_contractAddress, _blockIdentifier) {
        throw new Error("RPC does not implement getCode function");
      }
      async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {
        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);
      }
      async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        const transaction2 = this.buildTransaction(
          {
            type: "INVOKE_FUNCTION",
            ...invocation,
            ...invocationDetails
          },
          "fee"
        );
        return this.fetchEndpoint("starknet_estimateFee", {
          request: [transaction2],
          block_id
        }).then(this.responseParser.parseFeeEstimateResponse);
      }
      async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        const transaction2 = this.buildTransaction(
          {
            type: "DECLARE",
            ...invocation,
            ...details
          },
          "fee"
        );
        return this.fetchEndpoint("starknet_estimateFee", {
          request: [transaction2],
          block_id
        }).then(this.responseParser.parseFeeEstimateResponse);
      }
      async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        const transaction2 = this.buildTransaction(
          {
            type: "DEPLOY_ACCOUNT",
            ...invocation,
            ...details
          },
          "fee"
        );
        return this.fetchEndpoint("starknet_estimateFee", {
          request: [transaction2],
          block_id
        }).then(this.responseParser.parseFeeEstimateResponse);
      }
      async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {
        if (skipValidate) {
          console.warn("getEstimateFeeBulk RPC does not support skipValidate");
        }
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_estimateFee", {
          request: invocations.map((it) => this.buildTransaction(it, "fee")),
          block_id
        }).then(this.responseParser.parseFeeEstimateBulkResponse);
      }
      async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {
        if (!isSierra(contract)) {
          return this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: rpc_exports.TransactionType.DECLARE,
              contract_class: {
                program: contract.program,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              version: HEX_STR_TRANSACTION_VERSION_1,
              max_fee: toHex(details.maxFee || 0),
              signature: signatureToHexArray(signature),
              sender_address: senderAddress,
              nonce: toHex(details.nonce)
            }
          });
        }
        return this.fetchEndpoint("starknet_addDeclareTransaction", {
          declare_transaction: {
            type: rpc_exports.TransactionType.DECLARE,
            contract_class: {
              sierra_program: decompressProgram(contract.sierra_program),
              contract_class_version: contract.contract_class_version,
              entry_points_by_type: contract.entry_points_by_type,
              abi: contract.abi
            },
            compiled_class_hash: compiledClassHash || "",
            version: HEX_STR_TRANSACTION_VERSION_2,
            max_fee: toHex(details.maxFee || 0),
            signature: signatureToHexArray(signature),
            sender_address: senderAddress,
            nonce: toHex(details.nonce)
          }
        });
      }
      async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {
        return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
          deploy_account_transaction: {
            constructor_calldata: CallData.toHex(constructorCalldata || []),
            class_hash: toHex(classHash),
            contract_address_salt: toHex(addressSalt || 0),
            type: rpc_exports.TransactionType.DEPLOY_ACCOUNT,
            max_fee: toHex(details.maxFee || 0),
            version: toHex(details.version || 0),
            signature: signatureToHexArray(signature),
            nonce: toHex(details.nonce)
          }
        });
      }
      async invokeFunction(functionInvocation, details) {
        return this.fetchEndpoint("starknet_addInvokeTransaction", {
          invoke_transaction: {
            sender_address: functionInvocation.contractAddress,
            calldata: CallData.toHex(functionInvocation.calldata),
            type: rpc_exports.TransactionType.INVOKE,
            max_fee: toHex(details.maxFee || 0),
            version: "0x1",
            signature: signatureToHexArray(functionInvocation.signature),
            nonce: toHex(details.nonce)
          }
        });
      }
      // Methods from Interface
      async callContract(call, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        const result = await this.fetchEndpoint("starknet_call", {
          request: {
            contract_address: call.contractAddress,
            entry_point_selector: getSelectorFromName(call.entrypoint),
            calldata: CallData.toHex(call.calldata)
          },
          block_id
        });
        return this.responseParser.parseCallContractResponse(result);
      }
      async traceTransaction(transactionHash) {
        return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash: transactionHash });
      }
      async traceBlockTransactions(blockHash) {
        return this.fetchEndpoint("starknet_traceBlockTransactions", { block_hash: blockHash });
      }
      async waitForTransaction(txHash, options) {
        let { retries } = this;
        let onchain = false;
        let isErrorState = false;
        let txReceipt = {};
        const retryInterval = (options == null ? void 0 : options.retryInterval) ?? 5e3;
        const errorStates = (options == null ? void 0 : options.errorStates) ?? [TransactionExecutionStatus2.REVERTED];
        const successStates = (options == null ? void 0 : options.successStates) ?? [
          TransactionExecutionStatus2.SUCCEEDED,
          TransactionFinalityStatus2.ACCEPTED_ON_L1,
          TransactionFinalityStatus2.ACCEPTED_ON_L2
        ];
        while (!onchain) {
          await wait(retryInterval);
          try {
            txReceipt = await this.getTransactionReceipt(txHash);
            const executionStatus = pascalToSnake(txReceipt.execution_status);
            const finalityStatus = pascalToSnake(txReceipt.finality_status);
            if (!executionStatus || !finalityStatus) {
              const error = new Error("waiting for transaction status");
              throw error;
            }
            if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {
              onchain = true;
            } else if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
              const message = `${executionStatus}: ${finalityStatus}: ${txReceipt.revert_reason}`;
              const error = new Error(message);
              error.response = txReceipt;
              isErrorState = true;
              throw error;
            }
          } catch (error) {
            if (error instanceof Error && isErrorState) {
              throw error;
            }
            if (retries === 0) {
              throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
            }
          }
          retries -= 1;
        }
        await wait(retryInterval);
        return txReceipt;
      }
      /**
       * Gets the transaction count from a block.
       *
       *
       * @param blockIdentifier
       * @returns Number of transactions
       */
      async getTransactionCount(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id });
      }
      /**
       * Gets the latest block number
       *
       *
       * @returns Number of the latest block
       */
      async getBlockNumber() {
        return this.fetchEndpoint("starknet_blockNumber");
      }
      /**
       * Gets syncing status of the node
       *
       *
       * @returns Object with the stats data
       */
      async getSyncingStats() {
        return this.fetchEndpoint("starknet_syncing");
      }
      /**
       * Gets all the events filtered
       *
       *
       * @returns events and the pagination of the events
       */
      async getEvents(eventFilter) {
        return this.fetchEndpoint("starknet_getEvents", { filter: eventFilter });
      }
      async getSimulateTransaction(invocations, {
        blockIdentifier = this.blockIdentifier,
        skipValidate = false,
        skipExecute = false,
        // @deprecated
        skipFeeCharge = true
        // Pathfinder currently does not support `starknet_simulateTransactions` without `SKIP_FEE_CHARGE` simulation flag being set. This will become supported in a future release
      }) {
        const block_id = new Block(blockIdentifier).identifier;
        const simulationFlags = [];
        if (skipValidate)
          simulationFlags.push(SimulationFlag.SKIP_VALIDATE);
        if (skipExecute || skipFeeCharge)
          simulationFlags.push(SimulationFlag.SKIP_FEE_CHARGE);
        return this.fetchEndpoint("starknet_simulateTransactions", {
          block_id,
          transactions: invocations.map((it) => this.buildTransaction(it)),
          simulation_flags: simulationFlags
        }).then(this.responseParser.parseSimulateTransactionResponse);
      }
      async getStarkName(address, StarknetIdContract2) {
        return getStarkName(this, address, StarknetIdContract2);
      }
      async getAddressFromStarkName(name, StarknetIdContract2) {
        return getAddressFromStarkName(this, name, StarknetIdContract2);
      }
      buildTransaction(invocation, versionType) {
        const defaultVersions = getVersionsByType(versionType);
        const details = {
          signature: signatureToHexArray(invocation.signature),
          nonce: toHex(invocation.nonce),
          max_fee: toHex(invocation.maxFee || 0)
        };
        if (invocation.type === "INVOKE_FUNCTION") {
          return {
            type: rpc_exports.TransactionType.INVOKE,
            // Diff between sequencer and rpc invoke type
            sender_address: invocation.contractAddress,
            calldata: CallData.toHex(invocation.calldata),
            version: toHex(invocation.version || defaultVersions.v1),
            // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
            ...details
          };
        }
        if (invocation.type === "DECLARE") {
          if (!isSierra(invocation.contract)) {
            return {
              type: invocation.type,
              contract_class: invocation.contract,
              sender_address: invocation.senderAddress,
              version: toHex(invocation.version || defaultVersions.v1),
              // HEX_STR_TRANSACTION_VERSION_1, // as any HOTFIX TODO: Resolve spec version
              ...details
            };
          }
          return {
            // compiled_class_hash
            type: invocation.type,
            contract_class: {
              ...invocation.contract,
              sierra_program: decompressProgram(invocation.contract.sierra_program)
            },
            compiled_class_hash: invocation.compiledClassHash || "",
            sender_address: invocation.senderAddress,
            version: toHex(invocation.version || defaultVersions.v2),
            // HEX_STR_TRANSACTION_VERSION_2, // as any HOTFIX TODO: Resolve spec version
            ...details
          };
        }
        if (invocation.type === "DEPLOY_ACCOUNT") {
          return {
            type: invocation.type,
            constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
            class_hash: toHex(invocation.classHash),
            contract_address_salt: toHex(invocation.addressSalt || 0),
            version: toHex(invocation.version || defaultVersions.v1),
            ...details
          };
        }
        throw Error("RPC buildTransaction received unknown TransactionType");
      }
    };
    var import_url_join2 = __toESM(require_url_join());
    var ResponseParser = class {
    };
    var SequencerAPIResponseParser = class extends ResponseParser {
      parseGetBlockResponse(res) {
        return {
          ...res,
          new_root: res.state_root,
          parent_hash: res.parent_block_hash,
          transactions: Object.values(res.transactions).map((value) => "transaction_hash" in value && value.transaction_hash).filter(Boolean)
        };
      }
      parseGetTransactionResponse(res) {
        if (res.status === "NOT_RECEIVED" && res.finality_status === "NOT_RECEIVED") {
          throw new LibraryError();
        }
        return {
          ...res,
          calldata: "calldata" in res.transaction ? res.transaction.calldata : [],
          contract_class: "contract_class" in res.transaction ? res.transaction.contract_class : void 0,
          entry_point_selector: "entry_point_selector" in res.transaction ? res.transaction.entry_point_selector : void 0,
          max_fee: "max_fee" in res.transaction ? res.transaction.max_fee : void 0,
          nonce: res.transaction.nonce,
          sender_address: "sender_address" in res.transaction ? res.transaction.sender_address : void 0,
          signature: "signature" in res.transaction ? res.transaction.signature : void 0,
          transaction_hash: "transaction_hash" in res.transaction ? res.transaction.transaction_hash : void 0,
          version: "version" in res.transaction ? res.transaction.version : void 0
        };
      }
      parseGetTransactionReceiptResponse(res) {
        return {
          ...res,
          messages_sent: res.l2_to_l1_messages,
          ..."revert_error" in res && { revert_reason: res.revert_error }
        };
      }
      parseFeeEstimateResponse(res) {
        if ("overall_fee" in res) {
          let gasInfo = {};
          try {
            gasInfo = {
              gas_consumed: toBigInt(res.gas_usage),
              gas_price: toBigInt(res.gas_price)
            };
          } catch {
          }
          return {
            overall_fee: toBigInt(res.overall_fee),
            ...gasInfo
          };
        }
        return {
          overall_fee: toBigInt(res.amount)
        };
      }
      parseFeeEstimateBulkResponse(res) {
        return [].concat(res).map((item) => {
          if ("overall_fee" in item) {
            let gasInfo = {};
            try {
              gasInfo = {
                gas_consumed: toBigInt(item.gas_usage),
                gas_price: toBigInt(item.gas_price)
              };
            } catch {
            }
            return {
              overall_fee: toBigInt(item.overall_fee),
              ...gasInfo
            };
          }
          return {
            overall_fee: toBigInt(item.amount)
          };
        });
      }
      parseSimulateTransactionResponse(res) {
        const suggestedMaxFee = "overall_fee" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;
        return [
          {
            transaction_trace: res.trace,
            fee_estimation: res.fee_estimation,
            suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))
          }
        ];
      }
      parseCallContractResponse(res) {
        return {
          result: res.result
        };
      }
      parseInvokeFunctionResponse(res) {
        return {
          transaction_hash: res.transaction_hash
        };
      }
      parseDeployContractResponse(res) {
        return {
          transaction_hash: res.transaction_hash,
          contract_address: res.address
        };
      }
      parseDeclareContractResponse(res) {
        return {
          transaction_hash: res.transaction_hash,
          class_hash: res.class_hash
        };
      }
      parseGetStateUpdateResponse(res) {
        const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce]) => ({
          contract_address,
          nonce
        }));
        const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(
          ([address, storage_entries]) => ({ address, storage_entries })
        );
        return {
          ...res,
          state_diff: {
            ...res.state_diff,
            storage_diffs,
            nonces
          }
        };
      }
      parseContractClassResponse(res) {
        const response = isSierra(res) ? res : parseContract(res);
        return {
          ...response,
          abi: typeof response.abi === "string" ? JSON.parse(response.abi) : response.abi
        };
      }
    };
    var import_url_join = __toESM(require_url_join());
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
    function isUrl(s) {
      if (!s) {
        return false;
      }
      if (typeof s !== "string") {
        return false;
      }
      const match = s.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      const everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
    function buildUrl(baseUrl, defaultPath, urlOrPath) {
      return isUrl(urlOrPath) ? urlOrPath : (0, import_url_join.default)(baseUrl, urlOrPath ?? defaultPath);
    }
    function isEmptyQueryObject(obj) {
      return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v]) => k === "blockIdentifier" && v === null);
    }
    var defaultOptions2 = {
      network: "SN_GOERLI2",
      blockIdentifier: "pending"
      /* pending */
    };
    var SequencerProvider = class {
      constructor(optionsOrProvider = defaultOptions2) {
        this.responseParser = new SequencerAPIResponseParser();
        if ("network" in optionsOrProvider) {
          this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);
          this.feederGatewayUrl = buildUrl(this.baseUrl, "feeder_gateway");
          this.gatewayUrl = buildUrl(this.baseUrl, "gateway");
        } else {
          this.baseUrl = optionsOrProvider.baseUrl;
          this.feederGatewayUrl = buildUrl(
            this.baseUrl,
            "feeder_gateway",
            optionsOrProvider.feederGatewayUrl
          );
          this.gatewayUrl = buildUrl(this.baseUrl, "gateway", optionsOrProvider.gatewayUrl);
        }
        this.chainId = (optionsOrProvider == null ? void 0 : optionsOrProvider.chainId) ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);
        this.headers = optionsOrProvider.headers;
        this.blockIdentifier = (optionsOrProvider == null ? void 0 : optionsOrProvider.blockIdentifier) || defaultOptions2.blockIdentifier;
      }
      static getNetworkFromName(name) {
        switch (name) {
          case "SN_MAIN":
          case "0x534e5f4d41494e":
            return "https://alpha-mainnet.starknet.io";
          case "SN_GOERLI":
          case "0x534e5f474f45524c49":
            return "https://alpha4.starknet.io";
          case "SN_GOERLI2":
          case "0x534e5f474f45524c4932":
            return "https://alpha4-2.starknet.io";
          default:
            throw new Error("Could not detect base url from NetworkName");
        }
      }
      static getChainIdFromBaseUrl(baseUrl) {
        try {
          const url = new URL(baseUrl);
          if (url.host.includes("mainnet.starknet.io")) {
            return "0x534e5f4d41494e";
          }
          if (url.host.includes("alpha4-2.starknet.io")) {
            return "0x534e5f474f45524c4932";
          }
          return "0x534e5f474f45524c49";
        } catch {
          console.error(`Could not parse baseUrl: ${baseUrl}`);
          return "0x534e5f474f45524c49";
        }
      }
      getFetchUrl(endpoint) {
        const gatewayUrlEndpoints = ["add_transaction"];
        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;
      }
      getFetchMethod(endpoint) {
        const postMethodEndpoints = [
          "add_transaction",
          "call_contract",
          "estimate_fee",
          "estimate_message_fee",
          "estimate_fee_bulk",
          "simulate_transaction"
        ];
        return postMethodEndpoints.includes(endpoint) ? "POST" : "GET";
      }
      getQueryString(query) {
        if (isEmptyQueryObject(query)) {
          return "";
        }
        const queryString = Object.entries(query).map(([key, value]) => {
          if (key === "blockIdentifier") {
            const block = new Block(value);
            return `${block.queryIdentifier}`;
          }
          return `${key}=${value}`;
        }).join("&");
        return `?${queryString}`;
      }
      getHeaders(method) {
        if (method === "POST") {
          return {
            "Content-Type": "application/json",
            ...this.headers
          };
        }
        return this.headers;
      }
      // typesafe fetch
      async fetchEndpoint(endpoint, ...[query, request]) {
        const baseUrl = this.getFetchUrl(endpoint);
        const method = this.getFetchMethod(endpoint);
        const queryString = this.getQueryString(query);
        const url = (0, import_url_join2.default)(baseUrl, endpoint, queryString);
        return this.fetch(url, {
          method,
          body: request
        });
      }
      async fetch(endpoint, options) {
        const url = buildUrl(this.baseUrl, "", endpoint);
        const method = (options == null ? void 0 : options.method) ?? "GET";
        const headers = this.getHeaders(method);
        const body = stringify2(options == null ? void 0 : options.body);
        try {
          const response = await fetchPonyfill_default(url, {
            method,
            body,
            headers
          });
          const textResponse = await response.text();
          if (!response.ok) {
            let responseBody;
            try {
              responseBody = parse2(textResponse);
            } catch {
              throw new HttpError(response.statusText, response.status);
            }
            throw new GatewayError(responseBody.message, responseBody.code);
          }
          const parseChoice = (options == null ? void 0 : options.parseAlwaysAsBigInt) ? parseAlwaysAsBig : parse2;
          return parseChoice(textResponse);
        } catch (error) {
          if (error instanceof Error && !(error instanceof LibraryError))
            throw Error(`Could not ${method} from endpoint \`${url}\`: ${error.message}`);
          throw error;
        }
      }
      async getChainId() {
        return Promise.resolve(this.chainId);
      }
      async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint(
          "call_contract",
          { blockIdentifier },
          {
            // TODO - determine best choice once both are fully supported in devnet
            // signature: [],
            // sender_address: contractAddress,
            contract_address: contractAddress,
            entry_point_selector: getSelectorFromName(entryPointSelector),
            calldata: CallData.compile(calldata)
          }
        ).then(this.responseParser.parseCallContractResponse);
      }
      async getBlock(blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_block", { blockIdentifier }).then(
          this.responseParser.parseGetBlockResponse
        );
      }
      async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_nonce", { contractAddress, blockIdentifier });
      }
      async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
        const parsedKey = toBigInt(key).toString(10);
        return this.fetchEndpoint("get_storage_at", {
          blockIdentifier,
          contractAddress,
          key: parsedKey
        });
      }
      async getTransaction(txHash) {
        const txHashHex = toHex(txHash);
        return this.fetchEndpoint("get_transaction", { transactionHash: txHashHex }).then((result) => {
          if (Object.values(result).length === 1)
            throw new LibraryError(result.status);
          return this.responseParser.parseGetTransactionResponse(result);
        });
      }
      async getTransactionReceipt(txHash) {
        const txHashHex = toHex(txHash);
        return this.fetchEndpoint("get_transaction_receipt", { transactionHash: txHashHex }).then(
          this.responseParser.parseGetTransactionReceiptResponse
        );
      }
      async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_full_contract", { blockIdentifier, contractAddress }).then(
          this.responseParser.parseContractClassResponse
        );
      }
      async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_class_hash_at", { blockIdentifier, contractAddress });
      }
      async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_class_by_hash", { classHash, blockIdentifier }).then(
          this.responseParser.parseContractClassResponse
        );
      }
      async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_compiled_class_by_class_hash", { classHash, blockIdentifier });
      }
      async invokeFunction(functionInvocation, details) {
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "INVOKE_FUNCTION",
          sender_address: functionInvocation.contractAddress,
          calldata: CallData.compile(functionInvocation.calldata ?? []),
          signature: signatureToDecimalArray(functionInvocation.signature),
          nonce: toHex(details.nonce),
          max_fee: toHex(details.maxFee || 0),
          version: "0x1"
        }).then(this.responseParser.parseInvokeFunctionResponse);
      }
      async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "DEPLOY_ACCOUNT",
          contract_address_salt: addressSalt ?? randomAddress(),
          constructor_calldata: CallData.compile(constructorCalldata ?? []),
          class_hash: toHex(classHash),
          max_fee: toHex(details.maxFee || 0),
          version: toHex(details.version || 0),
          nonce: toHex(details.nonce),
          signature: signatureToDecimalArray(signature)
        }).then(this.responseParser.parseDeployContractResponse);
      }
      async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {
        if (!isSierra(contract)) {
          return this.fetchEndpoint("add_transaction", void 0, {
            type: "DECLARE",
            contract_class: contract,
            nonce: toHex(details.nonce),
            signature: signatureToDecimalArray(signature),
            sender_address: senderAddress,
            max_fee: toHex(details.maxFee || 0),
            version: toHex(transactionVersion)
          }).then(this.responseParser.parseDeclareContractResponse);
        }
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "DECLARE",
          sender_address: senderAddress,
          compiled_class_hash: compiledClassHash,
          contract_class: contract,
          nonce: toHex(details.nonce),
          signature: signatureToDecimalArray(signature),
          max_fee: toHex(details.maxFee || 0),
          version: toHex(transactionVersion_2)
        }).then(this.responseParser.parseDeclareContractResponse);
      }
      async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {
        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);
      }
      async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {
        const transaction2 = this.buildTransaction(
          {
            type: "INVOKE_FUNCTION",
            ...invocation,
            ...invocationDetails
          },
          "fee"
        );
        return this.fetchEndpoint("estimate_fee", { blockIdentifier, skipValidate }, transaction2).then(
          this.responseParser.parseFeeEstimateResponse
        );
      }
      async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {
        const transaction2 = this.buildTransaction(
          {
            type: "DECLARE",
            ...invocation,
            ...details
          },
          "fee"
        );
        return this.fetchEndpoint("estimate_fee", { blockIdentifier, skipValidate }, transaction2).then(
          this.responseParser.parseFeeEstimateResponse
        );
      }
      async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {
        const transaction2 = this.buildTransaction(
          {
            type: "DEPLOY_ACCOUNT",
            ...invocation,
            ...details
          },
          "fee"
        );
        return this.fetchEndpoint("estimate_fee", { blockIdentifier, skipValidate }, transaction2).then(
          this.responseParser.parseFeeEstimateResponse
        );
      }
      async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {
        const transactions = invocations.map((it) => this.buildTransaction(it, "fee"));
        return this.fetchEndpoint(
          "estimate_fee_bulk",
          { blockIdentifier, skipValidate },
          transactions
        ).then(this.responseParser.parseFeeEstimateBulkResponse);
      }
      async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {
        return this.fetchEndpoint("get_code", { contractAddress, blockIdentifier });
      }
      async waitForTransaction(txHash, options) {
        let res;
        let completed = false;
        let retries = 0;
        const retryInterval = (options == null ? void 0 : options.retryInterval) ?? 5e3;
        const errorStates = (options == null ? void 0 : options.errorStates) ?? [
          "REJECTED",
          "NOT_RECEIVED",
          "REVERTED"
          /* REVERTED */
        ];
        const successStates = (options == null ? void 0 : options.successStates) ?? [
          "SUCCEEDED",
          "ACCEPTED_ON_L1",
          "ACCEPTED_ON_L2"
          /* ACCEPTED_ON_L2 */
        ];
        while (!completed) {
          await wait(retryInterval);
          res = await this.getTransactionStatus(txHash);
          if ("NOT_RECEIVED" === res.finality_status && retries < 3) {
            retries += 1;
          } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {
            completed = true;
          } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {
            let message;
            if (res.tx_failure_reason) {
              message = `${res.tx_status}: ${res.tx_failure_reason.code}
${res.tx_failure_reason.error_message}`;
            } else if (res.tx_revert_reason) {
              message = `${res.tx_status}: ${res.tx_revert_reason}`;
            } else {
              message = res.tx_status;
            }
            const error = new Error(message);
            error.response = res;
            throw error;
          }
        }
        const txReceipt = await this.getTransactionReceipt(txHash);
        return txReceipt;
      }
      /**
       * Gets the status of a transaction.
       * @param txHash BigNumberish
       * @returns GetTransactionStatusResponse - the transaction status object
       */
      async getTransactionStatus(txHash) {
        const txHashHex = toHex(txHash);
        return this.fetchEndpoint("get_transaction_status", { transactionHash: txHashHex });
      }
      /**
       * Gets the smart contract address on the goerli testnet.
       * @returns GetContractAddressesResponse - starknet smart contract addresses
       */
      async getContractAddresses() {
        return this.fetchEndpoint("get_contract_addresses");
      }
      /**
       * Gets the transaction trace from a tx id.
       * @param txHash BigNumberish
       * @returns TransactionTraceResponse - the transaction trace
       */
      async getTransactionTrace(txHash) {
        const txHashHex = toHex(txHash);
        return this.fetchEndpoint("get_transaction_trace", { transactionHash: txHashHex });
      }
      async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {
        const validCallL1Handler = {
          from_address: getDecimalString(from_address),
          to_address: getHexString(to_address),
          entry_point_selector: getSelector(entry_point_selector),
          payload: getHexStringArray(payload)
        };
        return this.fetchEndpoint("estimate_message_fee", { blockIdentifier }, validCallL1Handler);
      }
      /**
       * Simulate transaction using Sequencer provider
       * WARNING!: Sequencer will process only first element from invocations array
       *
       * @param invocations Array of invocations, but only first invocation will be processed
       * @param blockIdentifier block identifier, default 'latest'
       * @param skipValidate Skip Account __validate__ method
       * @returns
       */
      async getSimulateTransaction(invocations, {
        blockIdentifier = this.blockIdentifier,
        skipValidate = false,
        skipExecute = false
      }) {
        if (invocations.length > 1) {
          console.warn("Sequencer simulate process only first element from invocations list");
        }
        if (skipExecute) {
          console.warn("Sequencer can't skip account __execute__");
        }
        const transaction2 = this.buildTransaction(invocations[0]);
        return this.fetchEndpoint(
          "simulate_transaction",
          {
            blockIdentifier,
            skipValidate: skipValidate ?? false
          },
          transaction2
        ).then(this.responseParser.parseSimulateTransactionResponse);
      }
      async getStateUpdate(blockIdentifier = this.blockIdentifier) {
        const args = new Block(blockIdentifier).sequencerIdentifier;
        return this.fetchEndpoint("get_state_update", { ...args }).then(
          this.responseParser.parseGetStateUpdateResponse
        );
      }
      // consider adding an optional trace retrieval parameter to the getBlock method
      async getBlockTraces(blockIdentifier = this.blockIdentifier) {
        const args = new Block(blockIdentifier).sequencerIdentifier;
        return this.fetchEndpoint("get_block_traces", { ...args });
      }
      async getStarkName(address, StarknetIdContract2) {
        return getStarkName(this, address, StarknetIdContract2);
      }
      async getAddressFromStarkName(name, StarknetIdContract2) {
        return getAddressFromStarkName(this, name, StarknetIdContract2);
      }
      /**
       * Build Single AccountTransaction from Single AccountInvocation
       * @param invocation AccountInvocationItem
       * @param versionType 'fee' | 'transaction' - used to determine default versions
       * @returns AccountTransactionItem
       */
      buildTransaction(invocation, versionType) {
        const defaultVersions = getVersionsByType(versionType);
        const details = {
          signature: signatureToDecimalArray(invocation.signature),
          nonce: toHex(invocation.nonce)
        };
        if (invocation.type === "INVOKE_FUNCTION") {
          return {
            type: invocation.type,
            sender_address: invocation.contractAddress,
            calldata: CallData.compile(invocation.calldata ?? []),
            version: toHex(invocation.version || defaultVersions.v1),
            ...details
          };
        }
        if (invocation.type === "DECLARE") {
          if (!isSierra(invocation.contract)) {
            return {
              type: invocation.type,
              contract_class: invocation.contract,
              sender_address: invocation.senderAddress,
              version: toHex(invocation.version || defaultVersions.v1),
              // fee from getDeclareEstimateFee use t.v. instead of feet.v.
              ...details
            };
          }
          return {
            type: invocation.type,
            contract_class: invocation.contract,
            compiled_class_hash: invocation.compiledClassHash,
            sender_address: invocation.senderAddress,
            version: toHex(invocation.version || defaultVersions.v2),
            // fee on getDeclareEstimateFee use t.v. instead of feet.v.
            ...details
          };
        }
        if (invocation.type === "DEPLOY_ACCOUNT") {
          return {
            type: invocation.type,
            constructor_calldata: CallData.compile(invocation.constructorCalldata || []),
            class_hash: toHex(invocation.classHash),
            contract_address_salt: toHex(invocation.addressSalt || 0),
            version: toHex(invocation.version || defaultVersions.v1),
            ...details
          };
        }
        throw Error("Sequencer buildTransaction received unknown TransactionType");
      }
    };
    var Provider = class {
      constructor(providerOrOptions) {
        if (providerOrOptions instanceof Provider) {
          this.provider = providerOrOptions.provider;
        } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {
          this.provider = providerOrOptions;
        } else if (providerOrOptions && "rpc" in providerOrOptions) {
          this.provider = new RpcProvider(providerOrOptions.rpc);
        } else if (providerOrOptions && "sequencer" in providerOrOptions) {
          this.provider = new SequencerProvider(providerOrOptions.sequencer);
        } else {
          this.provider = new SequencerProvider();
        }
      }
      async getChainId() {
        return this.provider.getChainId();
      }
      async getBlock(blockIdentifier) {
        return this.provider.getBlock(blockIdentifier);
      }
      async getClassAt(contractAddress, blockIdentifier) {
        return this.provider.getClassAt(contractAddress, blockIdentifier);
      }
      async getClassHashAt(contractAddress, blockIdentifier) {
        return this.provider.getClassHashAt(contractAddress, blockIdentifier);
      }
      getClassByHash(classHash) {
        return this.provider.getClassByHash(classHash);
      }
      async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {
        return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);
      }
      async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {
        return this.provider.getInvokeEstimateFee(
          invocationWithTxType,
          invocationDetails,
          blockIdentifier,
          skipValidate
        );
      }
      async getEstimateFeeBulk(invocations, options) {
        return this.provider.getEstimateFeeBulk(invocations, options);
      }
      async getNonceForAddress(contractAddress, blockIdentifier) {
        return this.provider.getNonceForAddress(contractAddress, blockIdentifier);
      }
      async getStorageAt(contractAddress, key, blockIdentifier) {
        return this.provider.getStorageAt(contractAddress, key, blockIdentifier);
      }
      async getTransaction(txHash) {
        return this.provider.getTransaction(txHash);
      }
      async getTransactionReceipt(txHash) {
        return this.provider.getTransactionReceipt(txHash);
      }
      async callContract(request, blockIdentifier) {
        return this.provider.callContract(request, blockIdentifier);
      }
      async invokeFunction(functionInvocation, details) {
        return this.provider.invokeFunction(functionInvocation, details);
      }
      async deployAccountContract(payload, details) {
        return this.provider.deployAccountContract(payload, details);
      }
      async declareContract(transaction2, details) {
        return this.provider.declareContract(transaction2, details);
      }
      async getDeclareEstimateFee(transaction2, details, blockIdentifier, skipValidate) {
        return this.provider.getDeclareEstimateFee(transaction2, details, blockIdentifier, skipValidate);
      }
      getDeployAccountEstimateFee(transaction2, details, blockIdentifier, skipValidate) {
        return this.provider.getDeployAccountEstimateFee(
          transaction2,
          details,
          blockIdentifier,
          skipValidate
        );
      }
      async getCode(contractAddress, blockIdentifier) {
        return this.provider.getCode(contractAddress, blockIdentifier);
      }
      async waitForTransaction(txHash, options) {
        return this.provider.waitForTransaction(txHash, options);
      }
      async getSimulateTransaction(invocations, options) {
        return this.provider.getSimulateTransaction(invocations, options);
      }
      async getStateUpdate(blockIdentifier) {
        return this.provider.getStateUpdate(blockIdentifier);
      }
      async getStarkName(address, StarknetIdContract2) {
        return getStarkName(this, address, StarknetIdContract2);
      }
      async getAddressFromStarkName(name, StarknetIdContract2) {
        return getAddressFromStarkName(this, name, StarknetIdContract2);
      }
    };
    var SignerInterface = class {
    };
    var transaction_exports = {};
    __export2(transaction_exports, {
      fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,
      fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,
      fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,
      getExecuteCalldata: () => getExecuteCalldata,
      transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,
      transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1
    });
    var transformCallsToMulticallArrays = (calls) => {
      const callArray = [];
      const calldata = [];
      calls.forEach((call) => {
        const data = CallData.compile(call.calldata || []);
        callArray.push({
          to: toBigInt(call.contractAddress).toString(10),
          selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
          data_offset: calldata.length.toString(),
          data_len: data.length.toString()
        });
        calldata.push(...data);
      });
      return {
        callArray,
        calldata: CallData.compile({ calldata })
      };
    };
    var fromCallsToExecuteCalldata = (calls) => {
      const { callArray, calldata } = transformCallsToMulticallArrays(calls);
      const compiledCalls = CallData.compile({ callArray });
      return [...compiledCalls, ...calldata];
    };
    var fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {
      return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];
    };
    var transformCallsToMulticallArrays_cairo1 = (calls) => {
      const callArray = calls.map((call) => ({
        to: toBigInt(call.contractAddress).toString(10),
        selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
        calldata: CallData.compile(call.calldata || [])
      }));
      return callArray;
    };
    var fromCallsToExecuteCalldata_cairo1 = (calls) => {
      const orderCalls = calls.map((call) => ({
        contractAddress: call.contractAddress,
        entrypoint: call.entrypoint,
        calldata: call.calldata
      }));
      return CallData.compile({ orderCalls });
    };
    var getExecuteCalldata = (calls, cairoVersion = "0") => {
      if (cairoVersion === "1") {
        return fromCallsToExecuteCalldata_cairo1(calls);
      }
      return fromCallsToExecuteCalldata(calls);
    };
    var typedData_exports = {};
    __export2(typedData_exports, {
      encodeData: () => encodeData,
      encodeType: () => encodeType,
      encodeValue: () => encodeValue,
      getDependencies: () => getDependencies,
      getMessageHash: () => getMessageHash,
      getStructHash: () => getStructHash,
      getTypeHash: () => getTypeHash,
      isMerkleTreeType: () => isMerkleTreeType,
      prepareSelector: () => prepareSelector
    });
    var merkle_exports = {};
    __export2(merkle_exports, {
      MerkleTree: () => MerkleTree,
      proofMerklePath: () => proofMerklePath
    });
    var MerkleTree = class {
      constructor(leafHashes) {
        this.branches = [];
        this.leaves = leafHashes;
        this.root = this.build(leafHashes);
      }
      build(leaves) {
        if (leaves.length === 1) {
          return leaves[0];
        }
        if (leaves.length !== this.leaves.length) {
          this.branches.push(leaves);
        }
        const newLeaves = [];
        for (let i = 0; i < leaves.length; i += 2) {
          if (i + 1 === leaves.length) {
            newLeaves.push(MerkleTree.hash(leaves[i], "0x0"));
          } else {
            newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));
          }
        }
        return this.build(newLeaves);
      }
      static hash(a, b) {
        const [aSorted, bSorted] = [toBigInt(a), toBigInt(b)].sort((x, y) => x >= y ? 1 : -1);
        return starkCurve.pedersen(aSorted, bSorted);
      }
      getProof(leaf, branch = this.leaves, hashPath = []) {
        const index = branch.indexOf(leaf);
        if (index === -1) {
          throw new Error("leaf not found");
        }
        if (branch.length === 1) {
          return hashPath;
        }
        const isLeft = index % 2 === 0;
        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? "0x0";
        const newHashPath = [...hashPath, neededBranch];
        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);
        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
        return this.getProof(
          MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf),
          nextBranch,
          newHashPath
        );
      }
    };
    function proofMerklePath(root, leaf, path) {
      if (path.length === 0) {
        return root === leaf;
      }
      const [next, ...rest2] = path;
      return proofMerklePath(root, MerkleTree.hash(leaf, next), rest2);
    }
    function getHex(value) {
      try {
        return toHex(value);
      } catch (e) {
        if (typeof value === "string") {
          return toHex(encodeShortString(value));
        }
        throw new Error(`Invalid BigNumberish: ${value}`);
      }
    }
    var validateTypedData = (data) => {
      const typedData2 = data;
      const valid = Boolean(typedData2.types && typedData2.primaryType && typedData2.message);
      return valid;
    };
    function prepareSelector(selector2) {
      return isHex(selector2) ? selector2 : getSelectorFromName(selector2);
    }
    function isMerkleTreeType(type) {
      return type.type === "merkletree";
    }
    var getDependencies = (types2, type, dependencies = []) => {
      if (type[type.length - 1] === "*") {
        type = type.slice(0, -1);
      }
      if (dependencies.includes(type)) {
        return dependencies;
      }
      if (!types2[type]) {
        return dependencies;
      }
      return [
        type,
        ...types2[type].reduce(
          (previous, t) => [
            ...previous,
            ...getDependencies(types2, t.type, previous).filter(
              (dependency) => !previous.includes(dependency)
            )
          ],
          []
        )
      ];
    };
    function getMerkleTreeType(types2, ctx) {
      if (ctx.parent && ctx.key) {
        const parentType = types2[ctx.parent];
        const merkleType = parentType.find((t) => t.name === ctx.key);
        const isMerkleTree = isMerkleTreeType(merkleType);
        if (!isMerkleTree) {
          throw new Error(`${ctx.key} is not a merkle tree`);
        }
        if (merkleType.contains.endsWith("*")) {
          throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
        }
        return merkleType.contains;
      }
      return "raw";
    }
    var encodeType = (types2, type) => {
      const [primary, ...dependencies] = getDependencies(types2, type);
      const newTypes = !primary ? [] : [primary, ...dependencies.sort()];
      return newTypes.map((dependency) => {
        return `${dependency}(${types2[dependency].map((t) => `${t.name}:${t.type}`)})`;
      }).join("");
    };
    var getTypeHash = (types2, type) => {
      return getSelectorFromName(encodeType(types2, type));
    };
    var encodeValue = (types2, type, data, ctx = {}) => {
      if (types2[type]) {
        return [type, getStructHash(types2, type, data)];
      }
      if (Object.keys(types2).map((x) => `${x}*`).includes(type)) {
        const structHashes = data.map((struct) => {
          return getStructHash(types2, type.slice(0, -1), struct);
        });
        return [type, computeHashOnElements(structHashes)];
      }
      if (type === "merkletree") {
        const merkleTreeType = getMerkleTreeType(types2, ctx);
        const structHashes = data.map((struct) => {
          return encodeValue(types2, merkleTreeType, struct)[1];
        });
        const { root } = new MerkleTree(structHashes);
        return ["felt", root];
      }
      if (type === "felt*") {
        return ["felt*", computeHashOnElements(data)];
      }
      if (type === "selector") {
        return ["felt", prepareSelector(data)];
      }
      return [type, getHex(data)];
    };
    var encodeData = (types2, type, data) => {
      const [returnTypes, values2] = types2[type].reduce(
        ([ts, vs], field) => {
          if (data[field.name] === void 0 || data[field.name] === null) {
            throw new Error(`Cannot encode data: missing data for '${field.name}'`);
          }
          const value = data[field.name];
          const [t, encodedValue] = encodeValue(types2, field.type, value, {
            parent: type,
            key: field.name
          });
          return [
            [...ts, t],
            [...vs, encodedValue]
          ];
        },
        [["felt"], [getTypeHash(types2, type)]]
      );
      return [returnTypes, values2];
    };
    var getStructHash = (types2, type, data) => {
      return computeHashOnElements(encodeData(types2, type, data)[1]);
    };
    var getMessageHash = (typedData2, account) => {
      if (!validateTypedData(typedData2)) {
        throw new Error("Typed data does not match JSON schema");
      }
      const message = [
        encodeShortString("StarkNet Message"),
        getStructHash(typedData2.types, "StarkNetDomain", typedData2.domain),
        account,
        getStructHash(typedData2.types, typedData2.primaryType, typedData2.message)
      ];
      return computeHashOnElements(message);
    };
    var Signer = class {
      constructor(pk = starkCurve.utils.randomPrivateKey()) {
        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);
      }
      async getPubKey() {
        return starkCurve.getStarkKey(this.pk);
      }
      async signMessage(typedData2, accountAddress) {
        const msgHash = getMessageHash(typedData2, accountAddress);
        return starkCurve.sign(msgHash, this.pk);
      }
      async signTransaction(transactions, transactionsDetail, abis) {
        if (abis && abis.length !== transactions.length) {
          throw new Error("ABI must be provided for each transaction or no transaction");
        }
        const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);
        const msgHash = calculateTransactionHash(
          transactionsDetail.walletAddress,
          transactionsDetail.version,
          calldata,
          transactionsDetail.maxFee,
          transactionsDetail.chainId,
          transactionsDetail.nonce
        );
        return starkCurve.sign(msgHash, this.pk);
      }
      async signDeployAccountTransaction({
        classHash,
        contractAddress,
        constructorCalldata,
        addressSalt,
        maxFee,
        version: version2,
        chainId,
        nonce
      }) {
        const msgHash = calculateDeployAccountTransactionHash(
          contractAddress,
          classHash,
          CallData.compile(constructorCalldata),
          addressSalt,
          version2,
          maxFee,
          chainId,
          nonce
        );
        return starkCurve.sign(msgHash, this.pk);
      }
      async signDeclareTransaction({
        classHash,
        senderAddress,
        chainId,
        maxFee,
        version: version2,
        nonce,
        compiledClassHash
      }) {
        const msgHash = calculateDeclareTransactionHash(
          classHash,
          senderAddress,
          version2,
          maxFee,
          chainId,
          nonce,
          compiledClassHash
        );
        return starkCurve.sign(msgHash, this.pk);
      }
    };
    function parseUDCEvent(txReceipt) {
      if (!txReceipt.events) {
        throw new Error("UDC emited event is empty");
      }
      const event = txReceipt.events.find(
        (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)
      ) || {
        data: []
      };
      return {
        transaction_hash: txReceipt.transaction_hash,
        contract_address: event.data[0],
        address: event.data[0],
        deployer: event.data[1],
        unique: event.data[2],
        classHash: event.data[3],
        calldata_len: event.data[4],
        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
        salt: event.data[event.data.length - 1]
      };
    }
    var Account = class extends Provider {
      constructor(providerOrOptions, address, pkOrSigner, cairoVersion = "0") {
        super(providerOrOptions);
        this.deploySelf = this.deployAccount;
        this.address = address.toLowerCase();
        this.signer = typeof pkOrSigner === "string" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;
        this.cairoVersion = cairoVersion;
      }
      async getNonce(blockIdentifier) {
        return super.getNonceForAddress(this.address, blockIdentifier);
      }
      async getNonceSafe(nonce) {
        try {
          return toBigInt(nonce ?? await this.getNonce());
        } catch (error) {
          return 0n;
        }
      }
      async estimateFee(calls, estimateFeeDetails) {
        return this.estimateInvokeFee(calls, estimateFeeDetails);
      }
      async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {
        const transactions = Array.isArray(calls) ? calls : [calls];
        const nonce = toBigInt(providedNonce ?? await this.getNonce());
        const version2 = toBigInt(feeTransactionVersion);
        const chainId = await this.getChainId();
        const signerDetails = {
          walletAddress: this.address,
          nonce,
          maxFee: ZERO,
          version: version2,
          chainId,
          cairoVersion: this.cairoVersion
        };
        const invocation = await this.buildInvocation(transactions, signerDetails);
        const response = await super.getInvokeEstimateFee(
          { ...invocation },
          { version: version2, nonce },
          blockIdentifier,
          skipValidate
        );
        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
        return {
          ...response,
          suggestedMaxFee
        };
      }
      async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {
        const nonce = toBigInt(providedNonce ?? await this.getNonce());
        const version2 = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;
        const chainId = await this.getChainId();
        const declareContractTransaction = await this.buildDeclarePayload(
          { classHash: providedClassHash, contract, casm, compiledClassHash },
          {
            nonce,
            chainId,
            version: version2,
            walletAddress: this.address,
            maxFee: ZERO,
            cairoVersion: this.cairoVersion
          }
        );
        const response = await super.getDeclareEstimateFee(
          declareContractTransaction,
          { version: version2, nonce },
          blockIdentifier,
          skipValidate
        );
        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
        return {
          ...response,
          suggestedMaxFee
        };
      }
      async estimateAccountDeployFee({
        classHash,
        addressSalt = 0,
        constructorCalldata = [],
        contractAddress: providedContractAddress
      }, { blockIdentifier, skipValidate } = {}) {
        const version2 = toBigInt(feeTransactionVersion);
        const nonce = ZERO;
        const chainId = await this.getChainId();
        const payload = await this.buildAccountDeployPayload(
          { classHash, addressSalt, constructorCalldata, contractAddress: providedContractAddress },
          {
            nonce,
            chainId,
            version: version2,
            walletAddress: this.address,
            maxFee: ZERO,
            cairoVersion: this.cairoVersion
          }
        );
        const response = await super.getDeployAccountEstimateFee(
          { ...payload },
          { version: version2, nonce },
          blockIdentifier,
          skipValidate
        );
        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
        return {
          ...response,
          suggestedMaxFee
        };
      }
      async estimateDeployFee(payload, transactionsDetail) {
        const calls = this.buildUDCContractPayload(payload);
        return this.estimateInvokeFee(calls, transactionsDetail);
      }
      async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {
        const accountInvocations = await this.accountInvocationsFactory(invocations, {
          versions: [feeTransactionVersion, feeTransactionVersion_2],
          nonce,
          blockIdentifier
        });
        const response = await super.getEstimateFeeBulk(accountInvocations, {
          blockIdentifier,
          skipValidate
        });
        return [].concat(response).map((elem) => {
          const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);
          return {
            ...elem,
            suggestedMaxFee
          };
        });
      }
      async buildInvocation(call, signerDetails) {
        const calldata = getExecuteCalldata(call, this.cairoVersion);
        const signature = await this.signer.signTransaction(call, signerDetails);
        return {
          contractAddress: this.address,
          calldata,
          signature
        };
      }
      async execute(calls, abis = void 0, transactionsDetail = {}) {
        const transactions = Array.isArray(calls) ? calls : [calls];
        const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());
        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(
          { type: "INVOKE_FUNCTION", payload: calls },
          transactionsDetail
        );
        const version2 = toBigInt(transactionVersion);
        const chainId = await this.getChainId();
        const signerDetails = {
          walletAddress: this.address,
          nonce,
          maxFee,
          version: version2,
          chainId,
          cairoVersion: this.cairoVersion
        };
        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);
        const calldata = getExecuteCalldata(transactions, this.cairoVersion);
        return this.invokeFunction(
          { contractAddress: this.address, calldata, signature },
          {
            nonce,
            maxFee,
            version: version2
          }
        );
      }
      /**
       * First check if contract is already declared, if not declare it
       * If contract already declared returned transaction_hash is ''.
       * Method will pass even if contract is already declared
       * @param payload DeclareContractPayload
       * @param transactionsDetail (optional) InvocationsDetails = \{\}
       * @returns DeclareContractResponse
       */
      async declareIfNot(payload, transactionsDetail = {}) {
        const declareContractPayload = extractContractHashes(payload);
        try {
          await this.getClassByHash(declareContractPayload.classHash);
        } catch (error) {
          return this.declare(payload, transactionsDetail);
        }
        return {
          transaction_hash: "",
          class_hash: declareContractPayload.classHash
        };
      }
      async declare(payload, transactionsDetail = {}) {
        const declareContractPayload = extractContractHashes(payload);
        const details = {};
        details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());
        details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(
          {
            type: "DECLARE",
            payload: declareContractPayload
          },
          transactionsDetail
        );
        details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;
        details.chainId = await this.getChainId();
        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {
          ...details,
          walletAddress: this.address,
          cairoVersion: this.cairoVersion
        });
        return this.declareContract(declareContractTransaction, details);
      }
      async deploy(payload, details) {
        const params = [].concat(payload).map((it) => {
          const {
            classHash,
            salt,
            unique = true,
            constructorCalldata = []
          } = it;
          const compiledConstructorCallData = CallData.compile(constructorCalldata);
          const deploySalt = salt ?? randomAddress();
          return {
            call: {
              contractAddress: UDC.ADDRESS,
              entrypoint: UDC.ENTRYPOINT,
              calldata: [
                classHash,
                deploySalt,
                toCairoBool(unique),
                compiledConstructorCallData.length,
                ...compiledConstructorCallData
              ]
            },
            address: calculateContractAddressFromHash(
              unique ? starkCurve.pedersen(this.address, deploySalt) : deploySalt,
              classHash,
              compiledConstructorCallData,
              unique ? UDC.ADDRESS : 0
            )
          };
        });
        const calls = params.map((it) => it.call);
        const addresses = params.map((it) => it.address);
        const invokeResponse = await this.execute(calls, void 0, details);
        return {
          ...invokeResponse,
          contract_address: addresses
        };
      }
      async deployContract(payload, details) {
        const deployTx = await this.deploy(payload, details);
        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);
        return parseUDCEvent(txReceipt);
      }
      async declareAndDeploy(payload, details) {
        const { constructorCalldata, salt, unique } = payload;
        let declare = await this.declareIfNot(payload, details);
        if (declare.transaction_hash !== "") {
          const tx = await this.waitForTransaction(declare.transaction_hash);
          declare = { ...declare, ...tx };
        }
        const deploy = await this.deployContract(
          { classHash: declare.class_hash, salt, unique, constructorCalldata },
          details
        );
        return { declare: { ...declare }, deploy };
      }
      async deployAccount({
        classHash,
        constructorCalldata = [],
        addressSalt = 0,
        contractAddress: providedContractAddress
      }, transactionsDetail = {}) {
        const version2 = toBigInt(transactionVersion);
        const nonce = ZERO;
        const chainId = await this.getChainId();
        const compiledCalldata = CallData.compile(constructorCalldata);
        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(
          {
            type: "DEPLOY_ACCOUNT",
            payload: {
              classHash,
              constructorCalldata: compiledCalldata,
              addressSalt,
              contractAddress
            }
          },
          transactionsDetail
        );
        const signature = await this.signer.signDeployAccountTransaction({
          classHash,
          constructorCalldata: compiledCalldata,
          contractAddress,
          addressSalt,
          chainId,
          maxFee,
          version: version2,
          nonce
        });
        return this.deployAccountContract(
          { classHash, addressSalt, constructorCalldata, signature },
          {
            nonce,
            maxFee,
            version: version2
          }
        );
      }
      async signMessage(typedData2) {
        return this.signer.signMessage(typedData2, this.address);
      }
      async hashMessage(typedData2) {
        return getMessageHash(typedData2, this.address);
      }
      async verifyMessageHash(hash3, signature) {
        try {
          await this.callContract({
            contractAddress: this.address,
            entrypoint: "isValidSignature",
            calldata: CallData.compile({
              hash: toBigInt(hash3).toString(),
              signature: formatSignature(signature)
            })
          });
          return true;
        } catch {
          return false;
        }
      }
      async verifyMessage(typedData2, signature) {
        const hash3 = await this.hashMessage(typedData2);
        return this.verifyMessageHash(hash3, signature);
      }
      async getSuggestedMaxFee({ type, payload }, details) {
        let feeEstimate;
        switch (type) {
          case "INVOKE_FUNCTION":
            feeEstimate = await this.estimateInvokeFee(payload, details);
            break;
          case "DECLARE":
            feeEstimate = await this.estimateDeclareFee(payload, details);
            break;
          case "DEPLOY_ACCOUNT":
            feeEstimate = await this.estimateAccountDeployFee(payload, details);
            break;
          case "DEPLOY":
            feeEstimate = await this.estimateDeployFee(payload, details);
            break;
          default:
            feeEstimate = { suggestedMaxFee: ZERO, overall_fee: ZERO };
            break;
        }
        return feeEstimate.suggestedMaxFee;
      }
      /**
       * will be renamed to buildDeclareContractTransaction
       */
      async buildDeclarePayload(payload, { nonce, chainId, version: version2, walletAddress, maxFee }) {
        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);
        const compressedCompiledContract = parseContract(contract);
        const signature = await this.signer.signDeclareTransaction({
          classHash,
          compiledClassHash,
          senderAddress: walletAddress,
          chainId,
          maxFee,
          version: version2,
          nonce
        });
        return {
          senderAddress: walletAddress,
          signature,
          contract: compressedCompiledContract,
          compiledClassHash
        };
      }
      async buildAccountDeployPayload({
        classHash,
        addressSalt = 0,
        constructorCalldata = [],
        contractAddress: providedContractAddress
      }, { nonce, chainId, version: version2, maxFee }) {
        const compiledCalldata = CallData.compile(constructorCalldata);
        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
        const signature = await this.signer.signDeployAccountTransaction({
          classHash,
          contractAddress,
          chainId,
          maxFee,
          version: version2,
          nonce,
          addressSalt,
          constructorCalldata: compiledCalldata
        });
        return {
          classHash,
          addressSalt,
          constructorCalldata: compiledCalldata,
          signature
        };
      }
      buildUDCContractPayload(payload) {
        const calls = [].concat(payload).map((it) => {
          const {
            classHash,
            salt = "0",
            unique = true,
            constructorCalldata = []
          } = it;
          const compiledConstructorCallData = CallData.compile(constructorCalldata);
          return {
            contractAddress: UDC.ADDRESS,
            entrypoint: UDC.ENTRYPOINT,
            calldata: [
              classHash,
              salt,
              toCairoBool(unique),
              compiledConstructorCallData.length,
              ...compiledConstructorCallData
            ]
          };
        });
        return calls;
      }
      async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {
        const accountInvocations = await this.accountInvocationsFactory(invocations, {
          versions: [transactionVersion, transactionVersion_2],
          nonce,
          blockIdentifier
        });
        return super.getSimulateTransaction(accountInvocations, {
          blockIdentifier,
          skipValidate,
          skipExecute
        });
      }
      async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {
        const version2 = versions[0];
        const safeNonce = await this.getNonceSafe(nonce);
        const chainId = await this.getChainId();
        return Promise.all(
          [].concat(invocations).map(async (transaction2, index) => {
            const signerDetails = {
              walletAddress: this.address,
              nonce: toBigInt(Number(safeNonce) + index),
              maxFee: ZERO,
              version: version2,
              chainId,
              cairoVersion: this.cairoVersion
            };
            const txPayload = "payload" in transaction2 ? transaction2.payload : transaction2;
            const common = {
              type: transaction2.type,
              version: version2,
              nonce: toBigInt(Number(safeNonce) + index),
              blockIdentifier
            };
            if (transaction2.type === "INVOKE_FUNCTION") {
              const payload = await this.buildInvocation(
                [].concat(txPayload),
                signerDetails
              );
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DECLARE") {
              signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);
              const payload = await this.buildDeclarePayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload,
                version: signerDetails.version
              };
            }
            if (transaction2.type === "DEPLOY_ACCOUNT") {
              const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DEPLOY") {
              const calls = this.buildUDCContractPayload(txPayload);
              const payload = await this.buildInvocation(calls, signerDetails);
              return {
                ...common,
                ...payload,
                type: "INVOKE_FUNCTION"
                /* INVOKE */
              };
            }
            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction2}`);
          })
        );
      }
      async getStarkName(address = this.address, StarknetIdContract2) {
        return super.getStarkName(address, StarknetIdContract2);
      }
    };
    var ProviderInterface = class {
    };
    var defaultProvider = new Provider();
    var AccountInterface = class extends ProviderInterface {
    };
    var events_exports = {};
    __export2(events_exports, {
      getAbiEvents: () => getAbiEvents,
      parseEvents: () => parseEvents
    });
    function getAbiEvents(abi) {
      return abi.filter((abiEntry) => abiEntry.type === "event" && (abiEntry.size || abiEntry.kind !== "enum")).reduce((acc, abiEntry) => {
        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(":") + 1);
        const abiEntryMod = { ...abiEntry };
        abiEntryMod.name = entryName;
        return {
          ...acc,
          [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod
        };
      }, {});
    }
    function parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {
      const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {
        var _a, _b;
        const abiEvent = abiEvents[recEvent.keys[0]];
        if (!abiEvent) {
          return acc;
        }
        const parsedEvent = {};
        parsedEvent[abiEvent.name] = {};
        recEvent.keys.shift();
        const keysIter = recEvent.keys[Symbol.iterator]();
        const dataIter = recEvent.data[Symbol.iterator]();
        const abiEventKeys = ((_a = abiEvent.members) == null ? void 0 : _a.filter((it) => it.kind === "key")) || abiEvent.keys;
        const abiEventData = ((_b = abiEvent.members) == null ? void 0 : _b.filter((it) => it.kind === "data")) || abiEvent.data;
        abiEventKeys.forEach((key) => {
          parsedEvent[abiEvent.name][key.name] = responseParser(
            keysIter,
            key,
            abiStructs,
            abiEnums,
            parsedEvent[abiEvent.name]
          );
        });
        abiEventData.forEach((data) => {
          parsedEvent[abiEvent.name][data.name] = responseParser(
            dataIter,
            data,
            abiStructs,
            abiEnums,
            parsedEvent[abiEvent.name]
          );
        });
        acc.push(parsedEvent);
        return acc;
      }, []);
      return ret;
    }
    var splitArgsAndOptions = (args) => {
      const options = [
        "blockIdentifier",
        "parseRequest",
        "parseResponse",
        "formatResponse",
        "maxFee",
        "nonce",
        "signature",
        "addressSalt"
      ];
      const lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && options.some((x) => x in lastArg)) {
        return { args, options: args.pop() };
      }
      return { args };
    };
    function buildCall(contract, functionAbi) {
      return async function(...args) {
        const params = splitArgsAndOptions(args);
        return contract.call(functionAbi.name, params.args, {
          parseRequest: true,
          parseResponse: true,
          ...params.options
        });
      };
    }
    function buildInvoke(contract, functionAbi) {
      return async function(...args) {
        const params = splitArgsAndOptions(args);
        return contract.invoke(functionAbi.name, params.args, {
          parseRequest: true,
          ...params.options
        });
      };
    }
    function buildDefault(contract, functionAbi) {
      if (functionAbi.stateMutability === "view" || functionAbi.state_mutability === "view") {
        return buildCall(contract, functionAbi);
      }
      return buildInvoke(contract, functionAbi);
    }
    function buildPopulate(contract, functionAbi) {
      return function(...args) {
        return contract.populate(functionAbi.name, args);
      };
    }
    function buildEstimate(contract, functionAbi) {
      return function(...args) {
        return contract.estimate(functionAbi.name, args);
      };
    }
    function getCalldata(args, callback) {
      if (Array.isArray(args) && "__compiled__" in args)
        return args;
      if (Array.isArray(args) && Array.isArray(args[0]) && "__compiled__" in args[0])
        return args[0];
      return callback();
    }
    var Contract = class {
      /**
       * Contract class to handle contract methods
       *
       * @param abi - Abi of the contract object
       * @param address (optional) - address to connect to
       * @param providerOrAccount (optional) - Provider or Account to attach to
       */
      constructor(abi, address, providerOrAccount = defaultProvider) {
        this.address = address && address.toLowerCase();
        this.providerOrAccount = providerOrAccount;
        this.callData = new CallData(abi);
        this.structs = CallData.getAbiStruct(abi);
        this.events = getAbiEvents(abi);
        const parser = createAbiParser(abi);
        this.abi = parser.getLegacyFormat();
        const options = { enumerable: true, value: {}, writable: false };
        Object.defineProperties(this, {
          functions: { enumerable: true, value: {}, writable: false },
          callStatic: { enumerable: true, value: {}, writable: false },
          populateTransaction: { enumerable: true, value: {}, writable: false },
          estimateFee: { enumerable: true, value: {}, writable: false }
        });
        this.abi.forEach((abiElement) => {
          if (abiElement.type !== "function")
            return;
          const signature = abiElement.name;
          if (!this[signature]) {
            Object.defineProperty(this, signature, {
              ...options,
              value: buildDefault(this, abiElement)
            });
          }
          if (!this.functions[signature]) {
            Object.defineProperty(this.functions, signature, {
              ...options,
              value: buildDefault(this, abiElement)
            });
          }
          if (!this.callStatic[signature]) {
            Object.defineProperty(this.callStatic, signature, {
              ...options,
              value: buildCall(this, abiElement)
            });
          }
          if (!this.populateTransaction[signature]) {
            Object.defineProperty(this.populateTransaction, signature, {
              ...options,
              value: buildPopulate(this, abiElement)
            });
          }
          if (!this.estimateFee[signature]) {
            Object.defineProperty(this.estimateFee, signature, {
              ...options,
              value: buildEstimate(this, abiElement)
            });
          }
        });
      }
      attach(address) {
        this.address = address;
      }
      connect(providerOrAccount) {
        this.providerOrAccount = providerOrAccount;
      }
      async deployed() {
        if (this.deployTransactionHash) {
          await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);
          this.deployTransactionHash = void 0;
        }
        return this;
      }
      async call(method, args = [], {
        parseRequest = true,
        parseResponse = true,
        formatResponse = void 0,
        blockIdentifier = void 0
      } = {}) {
        assert(this.address !== null, "contract is not connected to an address");
        const calldata = getCalldata(args, () => {
          if (parseRequest) {
            this.callData.validate("CALL", method, args);
            return this.callData.compile(method, args);
          }
          console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
          return args;
        });
        return this.providerOrAccount.callContract(
          {
            contractAddress: this.address,
            calldata,
            entrypoint: method
          },
          blockIdentifier
        ).then((x) => {
          if (!parseResponse) {
            return x.result;
          }
          if (formatResponse) {
            return this.callData.format(method, x.result, formatResponse);
          }
          return this.callData.parse(method, x.result);
        });
      }
      invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {
        assert(this.address !== null, "contract is not connected to an address");
        const calldata = getCalldata(args, () => {
          if (parseRequest) {
            this.callData.validate("INVOKE", method, args);
            return this.callData.compile(method, args);
          }
          console.warn("Invoke skipped parsing but provided rawArgs, possible malfunction request");
          return args;
        });
        const invocation = {
          contractAddress: this.address,
          calldata,
          entrypoint: method
        };
        if ("execute" in this.providerOrAccount) {
          return this.providerOrAccount.execute(invocation, void 0, {
            maxFee,
            nonce
          });
        }
        if (!nonce)
          throw new Error(`Nonce is required when invoking a function without an account`);
        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);
        return this.providerOrAccount.invokeFunction(
          {
            ...invocation,
            signature
          },
          {
            nonce
          }
        );
      }
      async estimate(method, args = []) {
        assert(this.address !== null, "contract is not connected to an address");
        if (!getCalldata(args, () => false)) {
          this.callData.validate("INVOKE", method, args);
        }
        const invocation = this.populate(method, args);
        if ("estimateInvokeFee" in this.providerOrAccount) {
          return this.providerOrAccount.estimateInvokeFee(invocation);
        }
        throw Error("Contract must be connected to the account contract to estimate");
      }
      populate(method, args = []) {
        const calldata = getCalldata(args, () => this.callData.compile(method, args));
        return {
          contractAddress: this.address,
          entrypoint: method,
          calldata
        };
      }
      parseEvents(receipt) {
        var _a;
        return parseEvents(
          ((_a = receipt.events) == null ? void 0 : _a.filter(
            (event) => cleanHex(event.from_address) === cleanHex(this.address),
            []
          )) || [],
          this.events,
          this.structs,
          CallData.getAbiEnum(this.abi)
        );
      }
      isCairo1() {
        return cairo_exports.isCairo1Abi(this.abi);
      }
      typed(tAbi) {
        return this;
      }
    };
    var ContractInterface = class {
    };
    var ContractFactory = class {
      /**
       * @param params CFParams
       *  - compiledContract: CompiledContract;
       *  - account: AccountInterface;
       *  - casm?: CairoAssembly;
       *  - classHash?: string;
       *  - compiledClassHash?: string;
       *  - abi?: Abi;
       */
      constructor(params) {
        this.compiledContract = params.compiledContract;
        this.account = params.account;
        this.casm = params.casm;
        this.abi = params.abi ?? params.compiledContract.abi;
        this.classHash = params.classHash;
        this.compiledClassHash = params.compiledClassHash;
        this.CallData = new CallData(this.abi);
      }
      /**
       * Deploys contract and returns new instance of the Contract
       * If contract is not declared it will first declare it, and then deploy
       *
       * @param args - Array of the constructor arguments for deployment
       * @param options (optional) Object - parseRequest, parseResponse, addressSalt
       * @returns deployed Contract
       */
      async deploy(...args) {
        const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);
        const constructorCalldata = getCalldata(param, () => {
          if (options.parseRequest) {
            this.CallData.validate("DEPLOY", "constructor", param);
            return this.CallData.compile("constructor", param);
          }
          console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
          return param;
        });
        const {
          deploy: { contract_address, transaction_hash }
        } = await this.account.declareAndDeploy({
          contract: this.compiledContract,
          casm: this.casm,
          classHash: this.classHash,
          compiledClassHash: this.compiledClassHash,
          constructorCalldata,
          salt: options.addressSalt
        });
        assert(Boolean(contract_address), "Deployment of the contract failed");
        const contractInstance = new Contract(
          this.compiledContract.abi,
          contract_address,
          this.account
        );
        contractInstance.deployTransactionHash = transaction_hash;
        return contractInstance;
      }
      /**
       * Attaches to new Account
       *
       * @param account - new Provider or Account to attach to
       * @returns ContractFactory
       */
      connect(account) {
        this.account = account;
        return this;
      }
      /**
       * Attaches current abi and account to the new address
       *
       * @param address - Contract address
       * @returns Contract
       */
      attach(address) {
        return new Contract(this.abi, address, this.account);
      }
      // ethers.js' getDeployTransaction cant be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation
    };
    var import_utils4 = require_utils3();
    function addAddressPadding(address) {
      return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, "0"));
    }
    function validateAndParseAddress(address) {
      assertInRange(address, ZERO, MASK_251, "Starknet Address");
      const result = addAddressPadding(address);
      if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
        throw new Error("Invalid Address Format");
      }
      return result;
    }
    function getChecksumAddress(address) {
      const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split("");
      const hex = removeHexPrefix(keccakBn(address));
      const hashed = (0, import_utils4.hexToBytes)(hex.padStart(64, "0"));
      for (let i = 0; i < chars.length; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
          chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 15) >= 8) {
          chars[i + 1] = chars[i + 1].toUpperCase();
        }
      }
      return addHexPrefix(chars.join(""));
    }
    function validateChecksumAddress(address) {
      return getChecksumAddress(address) === address;
    }
    var number = num_exports;
  }
});

// node_modules/@starknet-react/core/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@starknet-react/core/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedAccountInterfaceError = exports.UserNotConnectedError = exports.UserRejectedRequestError = exports.ConnectorNotFoundError = exports.ConnectorNotConnectedError = exports.ConnectorAlreadyConnectedError = void 0;
    var ConnectorAlreadyConnectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorAlreadyConnectedError";
        this.message = "Connector already connected";
      }
    };
    exports.ConnectorAlreadyConnectedError = ConnectorAlreadyConnectedError;
    var ConnectorNotConnectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorNotConnectedError";
        this.message = "Connector not connected";
      }
    };
    exports.ConnectorNotConnectedError = ConnectorNotConnectedError;
    var ConnectorNotFoundError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorNotFoundError";
        this.message = "Connector not found";
      }
    };
    exports.ConnectorNotFoundError = ConnectorNotFoundError;
    var UserRejectedRequestError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "UserRejectedRequestError";
        this.message = "User rejected request";
      }
    };
    exports.UserRejectedRequestError = UserRejectedRequestError;
    var UserNotConnectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "UserNotConnectedError";
        this.message = "User not connected";
      }
    };
    exports.UserNotConnectedError = UserNotConnectedError;
    var UnsupportedAccountInterfaceError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "UnsupportedAccountInterfaceError";
        this.message = "Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface";
      }
    };
    exports.UnsupportedAccountInterfaceError = UnsupportedAccountInterfaceError;
  }
});

// node_modules/@starknet-react/core/dist/providers/starknet.js
var require_starknet = __commonJS({
  "node_modules/@starknet-react/core/dist/providers/starknet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarknetProvider = exports.useStarknet = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_query_1 = require_lib2();
    var react_1 = require_react();
    var starknet_1 = require_dist();
    var errors_1 = require_errors();
    var customDefaultProvider = new starknet_1.Provider({
      sequencer: {
        network: starknet_1.constants.NetworkName.SN_MAIN
      }
    });
    var STARKNET_INITIAL_STATE = {
      account: void 0,
      connect: () => void 0,
      disconnect: () => void 0,
      library: customDefaultProvider,
      connectors: []
    };
    var StarknetContext = (0, react_1.createContext)(STARKNET_INITIAL_STATE);
    function useStarknet() {
      return (0, react_1.useContext)(StarknetContext);
    }
    exports.useStarknet = useStarknet;
    function reducer(state, action) {
      switch (action.type) {
        case "set_account": {
          return { ...state, account: action.account };
        }
        case "set_provider": {
          return { ...state, library: action.provider ?? customDefaultProvider };
        }
        case "set_connector": {
          return { ...state, connector: action.connector };
        }
        case "set_error": {
          return { ...state, error: action.error };
        }
        default: {
          return state;
        }
      }
    }
    function useStarknetManager({ defaultProvider: userDefaultProvider, connectors: userConnectors, autoConnect }) {
      const connectors = userConnectors ?? [];
      const [state, dispatch] = (0, react_1.useReducer)(reducer, {
        library: userDefaultProvider ? userDefaultProvider : customDefaultProvider,
        connectors
      });
      const { account, library, error } = state;
      const connect = (0, react_1.useCallback)((connector) => {
        connector.connect().then((account2) => {
          dispatch({ type: "set_account", account: account2.address });
          dispatch({ type: "set_provider", provider: account2 });
          dispatch({ type: "set_connector", connector });
          if (autoConnect) {
            localStorage.setItem("lastUsedConnector", connector.id);
          }
        }, (err) => {
          console.error(err);
          dispatch({ type: "set_error", error: new errors_1.ConnectorNotFoundError() });
        });
      }, [autoConnect]);
      const disconnect = (0, react_1.useCallback)(() => {
        dispatch({ type: "set_account", account: void 0 });
        dispatch({
          type: "set_provider",
          provider: userDefaultProvider ? userDefaultProvider : customDefaultProvider
        });
        dispatch({ type: "set_connector", connector: void 0 });
        if (autoConnect) {
          localStorage.removeItem("lastUsedConnector");
        }
        if (!state.connector)
          return;
        state.connector.removeEventListener(handleAccountChanged);
        state.connector.disconnect().catch((err) => {
          console.error(err);
          dispatch({ type: "set_error", error: new errors_1.ConnectorNotFoundError() });
        });
      }, [autoConnect, state.connector, userDefaultProvider]);
      const handleAccountChanged = (0, react_1.useCallback)(() => {
        disconnect();
        if (state.connector) {
          connect(state.connector);
        }
      }, [state.connector, connect, disconnect]);
      (0, react_1.useEffect)(() => {
        var _a;
        if (state.connector) {
          (_a = state.connector) == null ? void 0 : _a.initEventListener(handleAccountChanged);
        }
      }, [state.connector, handleAccountChanged]);
      (0, react_1.useEffect)(() => {
        async function tryAutoConnect(connectors2) {
          const lastConnectedConnectorId = localStorage.getItem("lastUsedConnector");
          if (lastConnectedConnectorId === null) {
            return;
          }
          const lastConnectedConnector = connectors2.find((connector) => connector.id === lastConnectedConnectorId);
          if (lastConnectedConnector === void 0) {
            return;
          }
          try {
            if (!await lastConnectedConnector.ready()) {
              return;
            }
            connect(lastConnectedConnector);
          } catch {
          }
        }
        if (autoConnect && !account) {
          tryAutoConnect(connectors);
        }
      }, []);
      return { account, connect, disconnect, connectors, library, error };
    }
    function StarknetProvider({ children, defaultProvider, connectors, autoConnect, queryClient }) {
      const state = useStarknetManager({ defaultProvider, connectors, autoConnect });
      return (0, jsx_runtime_1.jsx)(react_query_1.QueryClientProvider, { client: queryClient ?? new react_query_1.QueryClient(), children: (0, jsx_runtime_1.jsx)(StarknetContext.Provider, { value: state, children }) });
    }
    exports.StarknetProvider = StarknetProvider;
  }
});

// node_modules/immutable/dist/immutable.es.js
var immutable_es_exports = {};
__export(immutable_es_exports, {
  Collection: () => Collection,
  Iterable: () => Iterable,
  List: () => List,
  Map: () => Map2,
  OrderedMap: () => OrderedMap,
  OrderedSet: () => OrderedSet,
  PairSorting: () => PairSorting,
  Range: () => Range,
  Record: () => Record,
  Repeat: () => Repeat,
  Seq: () => Seq,
  Set: () => Set2,
  Stack: () => Stack,
  default: () => immutable_es_default,
  fromJS: () => fromJS,
  get: () => get,
  getIn: () => getIn$1,
  has: () => has,
  hasIn: () => hasIn$1,
  hash: () => hash2,
  is: () => is,
  isAssociative: () => isAssociative,
  isCollection: () => isCollection,
  isImmutable: () => isImmutable,
  isIndexed: () => isIndexed,
  isKeyed: () => isKeyed,
  isList: () => isList,
  isMap: () => isMap,
  isOrdered: () => isOrdered,
  isOrderedMap: () => isOrderedMap,
  isOrderedSet: () => isOrderedSet,
  isPlainObject: () => isPlainObject,
  isRecord: () => isRecord,
  isSeq: () => isSeq,
  isSet: () => isSet,
  isStack: () => isStack,
  isValueObject: () => isValueObject,
  merge: () => merge,
  mergeDeep: () => mergeDeep$1,
  mergeDeepWith: () => mergeDeepWith$1,
  mergeWith: () => mergeWith,
  remove: () => remove,
  removeIn: () => removeIn,
  set: () => set,
  setIn: () => setIn$1,
  update: () => update$1,
  updateIn: () => updateIn$1,
  version: () => version
});
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    value.hasOwnProperty(value.length - 1)
  ));
}
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
function hash2(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash3 = n | 0;
  if (hash3 !== n) {
    hash3 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash3 ^= n;
  }
  return smi(hash3);
}
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v, k) {
        return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i : i++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context) {
  var groups = Map2().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function(a) {
      return a + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map2()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function(a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v, k) {
    groups[predicate.call(context, v, k, collection) ? 1 : 0].push(
      isKeyedIter ? [k, v] : v
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v, k) {
    return [k, v, index++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries3.sort(function(a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(
    isKeyedCollection ? function(v, i) {
      entries3[i].length = 2;
    } : function(v, i) {
      entries3[i] = v[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}
function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i) {
    return i.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i) {
        return i = Collection(i), getIterator(reverse3 ? i.reverse() : i);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i) {
          return i.next();
        });
        isDone = zipAll2 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s) {
            return s.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
  if (a === void 0 && b === void 0) {
    return 0;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a > b ? 1 : a < b ? -1 : 0;
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function merge(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0)
    sources[len] = arguments[len + 1];
  return mergeWithSources(collection, sources);
}
function mergeWith(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0)
    sources[len] = arguments[len + 2];
  return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0)
    sources[len] = arguments[len + 1];
  return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0)
    sources[len] = arguments[len + 2];
  return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i = 0; i < sources.length; i++) {
    Collection3(sources[i]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root, ownerID, hash3) {
  var map2 = Object.create(MapPrototype);
  map2.size = size;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash3;
  map2.__altered = false;
  return map2;
}
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  var newRoot;
  var newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map2._root,
      map2.__ownerID,
      0,
      void 0,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash2(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash3) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash3;
  list.__altered = false;
  return list;
}
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
function makeOrderedMap(map2, list, ownerID, hash3) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map2 ? map2.size : 0;
  omap._map = map2;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash3;
  omap.__altered = false;
  return omap;
}
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map2 = omap._map;
  var list = omap._list;
  var i = map2.get(k);
  var has5 = i !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map2.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map2.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
    }
  } else if (has5) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map2;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map2.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
function makeStack(size, head, ownerID, hash3) {
  var map2 = Object.create(StackPrototype);
  map2.size = size;
  map2._head = head;
  map2.__ownerID = ownerID;
  map2.__hash = hash3;
  map2.__altered = false;
  return map2;
}
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!isCollection(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }
  if (a.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a);
  if (isOrdered(a)) {
    var entries3 = a.entries();
    return b.every(function(v, k) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a.size === void 0) {
    if (b.size === void 0) {
      if (typeof a.cacheResult === "function") {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a.size === bSize;
}
function mixin(ctor, methods2) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods2[key];
  };
  Object.keys(methods2).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods2).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map2, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
function reduce(collection, reducer, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed ? ordered ? function(v, k) {
      h = 31 * h + hashMerge(hash2(v), hash2(k)) | 0;
    } : function(v, k) {
      h = h + hashMerge(hash2(v), hash2(k)) | 0;
    } : ordered ? function(v) {
      h = 31 * h + hash2(v) | 0;
    } : function(v) {
      h = h + hash2(v) | 0;
    }
  );
  return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
function makeOrderedSet(map2, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k) {
    return [k, record.get(k)];
  }));
}
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value);
      }
    });
  } catch (error) {
  }
}
function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    "",
    converter && converter.length > 2 ? [] : void 0,
    { "": value }
  );
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  if (typeof value !== "string" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject(value))) {
    if (~stack.indexOf(value)) {
      throw new TypeError("Cannot convert circular structure to Immutable");
    }
    stack.push(value);
    keyPath && key !== "" && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      Seq(value).map(
        function(v, k) {
          return fromJSWith(stack, converter, v, k, keyPath, value);
        }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}
function defaultConverter(k, v) {
  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
}
var DELETE, SHIFT, SIZE, MASK, NOT_SET, IS_COLLECTION_SYMBOL, IS_KEYED_SYMBOL, IS_INDEXED_SYMBOL, Collection, KeyedCollection, IndexedCollection, SetCollection, IS_SEQ_SYMBOL, IS_RECORD_SYMBOL, IS_ORDERED_SYMBOL, ITERATE_KEYS, ITERATE_VALUES, ITERATE_ENTRIES, REAL_ITERATOR_SYMBOL, FAUX_ITERATOR_SYMBOL, ITERATOR_SYMBOL, Iterator, hasOwnProperty, Seq, KeyedSeq, IndexedSeq, SetSeq, ArraySeq, ObjectSeq, CollectionSeq, EMPTY_SEQ, IS_MAP_SYMBOL, imul, defaultValueOf, isExtensible, canDefineProperty, usingWeakMap, weakMap, symbolMap, _objHashUID, UID_HASH_KEY, STRING_HASH_CACHE_MIN_STRLEN, STRING_HASH_CACHE_MAX_SIZE, STRING_HASH_CACHE_SIZE, stringHashCache, ToKeyedSequence, ToIndexedSequence, ToSetSequence, FromEntriesSequence, toString2, Map2, MapPrototype, ArrayMapNode, BitmapIndexedNode, HashArrayMapNode, HashCollisionNode, ValueNode, MapIterator, EMPTY_MAP, MAX_ARRAY_MAP_SIZE, MAX_BITMAP_INDEXED_SIZE, MIN_HASH_ARRAY_MAP_SIZE, IS_LIST_SYMBOL, List, ListPrototype, VNode, DONE, EMPTY_LIST, OrderedMap, EMPTY_ORDERED_MAP, IS_STACK_SYMBOL, Stack, StackPrototype, EMPTY_STACK, IS_SET_SYMBOL, Set2, SetPrototype, EMPTY_SET, Range, EMPTY_RANGE, CollectionPrototype, KeyedCollectionPrototype, IndexedCollectionPrototype, SetCollectionPrototype, OrderedSet, OrderedSetPrototype, EMPTY_ORDERED_SET, PairSorting, Record, RecordPrototype, Repeat, EMPTY_REPEAT, version, Immutable, Iterable, immutable_es_default;
var init_immutable_es = __esm({
  "node_modules/immutable/dist/immutable.es.js"() {
    DELETE = "delete";
    SHIFT = 5;
    SIZE = 1 << SHIFT;
    MASK = SIZE - 1;
    NOT_SET = {};
    IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
    IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
    IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
    Collection = function Collection2(value) {
      return isCollection(value) ? value : Seq(value);
    };
    KeyedCollection = function(Collection3) {
      function KeyedCollection2(value) {
        return isKeyed(value) ? value : KeyedSeq(value);
      }
      if (Collection3)
        KeyedCollection2.__proto__ = Collection3;
      KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      KeyedCollection2.prototype.constructor = KeyedCollection2;
      return KeyedCollection2;
    }(Collection);
    IndexedCollection = function(Collection3) {
      function IndexedCollection2(value) {
        return isIndexed(value) ? value : IndexedSeq(value);
      }
      if (Collection3)
        IndexedCollection2.__proto__ = Collection3;
      IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      IndexedCollection2.prototype.constructor = IndexedCollection2;
      return IndexedCollection2;
    }(Collection);
    SetCollection = function(Collection3) {
      function SetCollection2(value) {
        return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
      }
      if (Collection3)
        SetCollection2.__proto__ = Collection3;
      SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      SetCollection2.prototype.constructor = SetCollection2;
      return SetCollection2;
    }(Collection);
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
    IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
    IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
    ITERATE_KEYS = 0;
    ITERATE_VALUES = 1;
    ITERATE_ENTRIES = 2;
    REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    FAUX_ITERATOR_SYMBOL = "@@iterator";
    ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    Iterator = function Iterator2(next) {
      this.next = next;
    };
    Iterator.prototype.toString = function toString() {
      return "[Iterator]";
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function() {
      return this;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    Seq = function(Collection3) {
      function Seq2(value) {
        return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
      }
      if (Collection3)
        Seq2.__proto__ = Collection3;
      Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
      Seq2.prototype.constructor = Seq2;
      Seq2.prototype.toSeq = function toSeq3() {
        return this;
      };
      Seq2.prototype.toString = function toString5() {
        return this.__toString("Seq {", "}");
      };
      Seq2.prototype.cacheResult = function cacheResult() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };
      Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          while (i !== size) {
            var entry = cache[reverse3 ? size - ++i : i++];
            if (fn(entry[1], entry[0], this) === false) {
              break;
            }
          }
          return i;
        }
        return this.__iterateUncached(fn, reverse3);
      };
      Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          return new Iterator(function() {
            if (i === size) {
              return iteratorDone();
            }
            var entry = cache[reverse3 ? size - ++i : i++];
            return iteratorValue(type, entry[0], entry[1]);
          });
        }
        return this.__iteratorUncached(type, reverse3);
      };
      return Seq2;
    }(Collection);
    KeyedSeq = function(Seq2) {
      function KeyedSeq2(value) {
        return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
      }
      if (Seq2)
        KeyedSeq2.__proto__ = Seq2;
      KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      KeyedSeq2.prototype.constructor = KeyedSeq2;
      KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
        return this;
      };
      return KeyedSeq2;
    }(Seq);
    IndexedSeq = function(Seq2) {
      function IndexedSeq2(value) {
        return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
      }
      if (Seq2)
        IndexedSeq2.__proto__ = Seq2;
      IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      IndexedSeq2.prototype.constructor = IndexedSeq2;
      IndexedSeq2.of = function of() {
        return IndexedSeq2(arguments);
      };
      IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
        return this;
      };
      IndexedSeq2.prototype.toString = function toString5() {
        return this.__toString("Seq [", "]");
      };
      return IndexedSeq2;
    }(Seq);
    SetSeq = function(Seq2) {
      function SetSeq2(value) {
        return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
      }
      if (Seq2)
        SetSeq2.__proto__ = Seq2;
      SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      SetSeq2.prototype.constructor = SetSeq2;
      SetSeq2.of = function of() {
        return SetSeq2(arguments);
      };
      SetSeq2.prototype.toSetSeq = function toSetSeq2() {
        return this;
      };
      return SetSeq2;
    }(Seq);
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    Seq.prototype[IS_SEQ_SYMBOL] = true;
    ArraySeq = function(IndexedSeq2) {
      function ArraySeq2(array) {
        this._array = array;
        this.size = array.length;
      }
      if (IndexedSeq2)
        ArraySeq2.__proto__ = IndexedSeq2;
      ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ArraySeq2.prototype.constructor = ArraySeq2;
      ArraySeq2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
      };
      ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        while (i !== size) {
          var ii = reverse3 ? size - ++i : i++;
          if (fn(array[ii], ii, this) === false) {
            break;
          }
        }
        return i;
      };
      ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var ii = reverse3 ? size - ++i : i++;
          return iteratorValue(type, ii, array[ii]);
        });
      };
      return ArraySeq2;
    }(IndexedSeq);
    ObjectSeq = function(KeyedSeq2) {
      function ObjectSeq2(object) {
        var keys2 = Object.keys(object).concat(
          Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
        );
        this._object = object;
        this._keys = keys2;
        this.size = keys2.length;
      }
      if (KeyedSeq2)
        ObjectSeq2.__proto__ = KeyedSeq2;
      ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ObjectSeq2.prototype.constructor = ObjectSeq2;
      ObjectSeq2.prototype.get = function get11(key, notSetValue) {
        if (notSetValue !== void 0 && !this.has(key)) {
          return notSetValue;
        }
        return this._object[key];
      };
      ObjectSeq2.prototype.has = function has5(key) {
        return hasOwnProperty.call(this._object, key);
      };
      ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        while (i !== size) {
          var key = keys2[reverse3 ? size - ++i : i++];
          if (fn(object[key], key, this) === false) {
            break;
          }
        }
        return i;
      };
      ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var key = keys2[reverse3 ? size - ++i : i++];
          return iteratorValue(type, key, object[key]);
        });
      };
      return ObjectSeq2;
    }(KeyedSeq);
    ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
    CollectionSeq = function(IndexedSeq2) {
      function CollectionSeq2(collection) {
        this._collection = collection;
        this.size = collection.length || collection.size;
      }
      if (IndexedSeq2)
        CollectionSeq2.__proto__ = IndexedSeq2;
      CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      CollectionSeq2.prototype.constructor = CollectionSeq2;
      CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        var iterations = 0;
        if (isIterator(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };
      CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        if (!isIterator(iterator)) {
          return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, iterations++, step.value);
        });
      };
      return CollectionSeq2;
    }(IndexedSeq);
    IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
    imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
      a |= 0;
      b |= 0;
      var c = a & 65535;
      var d = b & 65535;
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
    };
    defaultValueOf = Object.prototype.valueOf;
    isExtensible = Object.isExtensible;
    canDefineProperty = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e) {
        return false;
      }
    }();
    usingWeakMap = typeof WeakMap === "function";
    if (usingWeakMap) {
      weakMap = /* @__PURE__ */ new WeakMap();
    }
    symbolMap = /* @__PURE__ */ Object.create(null);
    _objHashUID = 0;
    UID_HASH_KEY = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    STRING_HASH_CACHE_MIN_STRLEN = 16;
    STRING_HASH_CACHE_MAX_SIZE = 255;
    STRING_HASH_CACHE_SIZE = 0;
    stringHashCache = {};
    ToKeyedSequence = function(KeyedSeq2) {
      function ToKeyedSequence2(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }
      if (KeyedSeq2)
        ToKeyedSequence2.__proto__ = KeyedSeq2;
      ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
      ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
        return this._iter.get(key, notSetValue);
      };
      ToKeyedSequence2.prototype.has = function has5(key) {
        return this._iter.has(key);
      };
      ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
        return this._iter.valueSeq();
      };
      ToKeyedSequence2.prototype.reverse = function reverse3() {
        var this$1$1 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().reverse();
          };
        }
        return reversedSequence;
      };
      ToKeyedSequence2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var mappedSequence = mapFactory(this, mapper, context);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().map(mapper, context);
          };
        }
        return mappedSequence;
      };
      ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v, k) {
          return fn(v, k, this$1$1);
        }, reverse3);
      };
      ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._iter.__iterator(type, reverse3);
      };
      return ToKeyedSequence2;
    }(KeyedSeq);
    ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
    ToIndexedSequence = function(IndexedSeq2) {
      function ToIndexedSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (IndexedSeq2)
        ToIndexedSequence2.__proto__ = IndexedSeq2;
      ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
      ToIndexedSequence2.prototype.includes = function includes3(value) {
        return this._iter.includes(value);
      };
      ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var i = 0;
        reverse3 && ensureSize(this);
        return this._iter.__iterate(
          function(v) {
            return fn(v, reverse3 ? this$1$1.size - ++i : i++, this$1$1);
          },
          reverse3
        );
      };
      ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        var i = 0;
        reverse3 && ensureSize(this);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(
            type,
            reverse3 ? this$1$1.size - ++i : i++,
            step.value,
            step
          );
        });
      };
      return ToIndexedSequence2;
    }(IndexedSeq);
    ToSetSequence = function(SetSeq2) {
      function ToSetSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (SetSeq2)
        ToSetSequence2.__proto__ = SetSeq2;
      ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
      ToSetSequence2.prototype.constructor = ToSetSequence2;
      ToSetSequence2.prototype.has = function has5(key) {
        return this._iter.includes(key);
      };
      ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v) {
          return fn(v, v, this$1$1);
        }, reverse3);
      };
      ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, step.value, step.value, step);
        });
      };
      return ToSetSequence2;
    }(SetSeq);
    FromEntriesSequence = function(KeyedSeq2) {
      function FromEntriesSequence2(entries3) {
        this._iter = entries3;
        this.size = entries3.size;
      }
      if (KeyedSeq2)
        FromEntriesSequence2.__proto__ = KeyedSeq2;
      FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
      FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
        return this._iter.toSeq();
      };
      FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(entry) {
          if (entry) {
            validateEntry(entry);
            var indexedCollection = isCollection(entry);
            return fn(
              indexedCollection ? entry.get(1) : entry[1],
              indexedCollection ? entry.get(0) : entry[0],
              this$1$1
            );
          }
        }, reverse3);
      };
      FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            if (entry) {
              validateEntry(entry);
              var indexedCollection = isCollection(entry);
              return iteratorValue(
                type,
                indexedCollection ? entry.get(0) : entry[0],
                indexedCollection ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };
      return FromEntriesSequence2;
    }(KeyedSeq);
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    toString2 = Object.prototype.toString;
    Map2 = function(KeyedCollection2) {
      function Map3(value) {
        return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map2) {
          var iter = KeyedCollection2(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (KeyedCollection2)
        Map3.__proto__ = KeyedCollection2;
      Map3.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
      Map3.prototype.constructor = Map3;
      Map3.of = function of() {
        var keyValues = [], len = arguments.length;
        while (len--)
          keyValues[len] = arguments[len];
        return emptyMap().withMutations(function(map2) {
          for (var i = 0; i < keyValues.length; i += 2) {
            if (i + 1 >= keyValues.length) {
              throw new Error("Missing value for key: " + keyValues[i]);
            }
            map2.set(keyValues[i], keyValues[i + 1]);
          }
        });
      };
      Map3.prototype.toString = function toString5() {
        return this.__toString("Map {", "}");
      };
      Map3.prototype.get = function get11(k, notSetValue) {
        return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
      };
      Map3.prototype.set = function set3(k, v) {
        return updateMap(this, k, v);
      };
      Map3.prototype.remove = function remove3(k) {
        return updateMap(this, k, NOT_SET);
      };
      Map3.prototype.deleteAll = function deleteAll(keys2) {
        var collection = Collection(keys2);
        if (collection.size === 0) {
          return this;
        }
        return this.withMutations(function(map2) {
          collection.forEach(function(key) {
            return map2.remove(key);
          });
        });
      };
      Map3.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyMap();
      };
      Map3.prototype.sort = function sort2(comparator) {
        return OrderedMap(sortFactory(this, comparator));
      };
      Map3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedMap(sortFactory(this, comparator, mapper));
      };
      Map3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(map3) {
          map3.forEach(function(value, key) {
            map3.set(key, mapper.call(context, value, key, this$1$1));
          });
        });
      };
      Map3.prototype.__iterator = function __iterator2(type, reverse3) {
        return new MapIterator(this, type, reverse3);
      };
      Map3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1$1);
        }, reverse3);
        return iterations;
      };
      Map3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
      };
      return Map3;
    }(KeyedCollection);
    Map2.isMap = isMap;
    MapPrototype = Map2.prototype;
    MapPrototype[IS_MAP_SYMBOL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeAll = MapPrototype.deleteAll;
    MapPrototype.setIn = setIn;
    MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
    MapPrototype.update = update;
    MapPrototype.updateIn = updateIn;
    MapPrototype.merge = MapPrototype.concat = merge$1;
    MapPrototype.mergeWith = mergeWith$1;
    MapPrototype.mergeDeep = mergeDeep;
    MapPrototype.mergeDeepWith = mergeDeepWith;
    MapPrototype.mergeIn = mergeIn;
    MapPrototype.mergeDeepIn = mergeDeepIn;
    MapPrototype.withMutations = withMutations;
    MapPrototype.wasAltered = wasAltered;
    MapPrototype.asImmutable = asImmutable;
    MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
    MapPrototype["@@transducer/step"] = function(result, arr) {
      return result.set(arr[0], arr[1]);
    };
    MapPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
      this.ownerID = ownerID;
      this.entries = entries3;
    };
    ArrayMapNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries3.length === 1) {
        return;
      }
      if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries3, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    };
    BitmapIndexedNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
    };
    BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
      this.ownerID = ownerID;
      this.count = count2;
      this.nodes = nodes;
    };
    HashArrayMapNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setAt(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries3;
    };
    HashCollisionNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var removed = value === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    ValueNode = function ValueNode2(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    };
    ValueNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash2(key), [key, value]);
    };
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
      var entries3 = this.entries;
      for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse3 ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse3) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function(fn, reverse3) {
      return fn(this.entry);
    };
    MapIterator = function(Iterator3) {
      function MapIterator2(map2, type, reverse3) {
        this._type = type;
        this._reverse = reverse3;
        this._stack = map2._root && mapIteratorFrame(map2._root);
      }
      if (Iterator3)
        MapIterator2.__proto__ = Iterator3;
      MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
      MapIterator2.prototype.constructor = MapIterator2;
      MapIterator2.prototype.next = function next() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex = void 0;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue(type, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue(
                type,
                node.entries[this._reverse ? maxIndex - index : index]
              );
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue(type, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
      };
      return MapIterator2;
    }(Iterator);
    MAX_ARRAY_MAP_SIZE = SIZE / 4;
    MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
    List = function(IndexedCollection2) {
      function List2(value) {
        var empty = emptyList();
        if (value === void 0 || value === null) {
          return empty;
        }
        if (isList(value)) {
          return value;
        }
        var iter = IndexedCollection2(value);
        var size = iter.size;
        if (size === 0) {
          return empty;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
          return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty.withMutations(function(list) {
          list.setSize(size);
          iter.forEach(function(v, i) {
            return list.set(i, v);
          });
        });
      }
      if (IndexedCollection2)
        List2.__proto__ = IndexedCollection2;
      List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      List2.prototype.constructor = List2;
      List2.of = function of() {
        return this(arguments);
      };
      List2.prototype.toString = function toString5() {
        return this.__toString("List [", "]");
      };
      List2.prototype.get = function get11(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor(this, index);
          return node && node.array[index & MASK];
        }
        return notSetValue;
      };
      List2.prototype.set = function set3(index, value) {
        return updateList(this, index, value);
      };
      List2.prototype.remove = function remove3(index) {
        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
      };
      List2.prototype.insert = function insert(index, value) {
        return this.splice(index, 0, value);
      };
      List2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT;
          this._root = this._tail = this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyList();
      };
      List2.prototype.push = function push() {
        var values2 = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list) {
          setListBounds(list, 0, oldSize + values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(oldSize + ii, values2[ii]);
          }
        });
      };
      List2.prototype.pop = function pop() {
        return setListBounds(this, 0, -1);
      };
      List2.prototype.unshift = function unshift() {
        var values2 = arguments;
        return this.withMutations(function(list) {
          setListBounds(list, -values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(ii, values2[ii]);
          }
        });
      };
      List2.prototype.shift = function shift() {
        return setListBounds(this, 1);
      };
      List2.prototype.concat = function concat2() {
        var arguments$1 = arguments;
        var seqs = [];
        for (var i = 0; i < arguments.length; i++) {
          var argument = arguments$1[i];
          var seq = IndexedCollection2(
            typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
          );
          if (seq.size !== 0) {
            seqs.push(seq);
          }
        }
        if (seqs.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
          return this.constructor(seqs[0]);
        }
        return this.withMutations(function(list) {
          seqs.forEach(function(seq2) {
            return seq2.forEach(function(value) {
              return list.push(value);
            });
          });
        });
      };
      List2.prototype.setSize = function setSize(size) {
        return setListBounds(this, 0, size);
      };
      List2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(list) {
          for (var i = 0; i < this$1$1.size; i++) {
            list.set(i, mapper.call(context, list.get(i), i, this$1$1));
          }
        });
      };
      List2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
          return this;
        }
        return setListBounds(
          this,
          resolveBegin(begin, size),
          resolveEnd(end, size)
        );
      };
      List2.prototype.__iterator = function __iterator2(type, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        return new Iterator(function() {
          var value = values2();
          return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
        });
      };
      List2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        var value;
        while ((value = values2()) !== DONE) {
          if (fn(value, reverse3 ? --index : index++, this) === false) {
            break;
          }
        }
        return index;
      };
      List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyList();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeList(
          this._origin,
          this._capacity,
          this._level,
          this._root,
          this._tail,
          ownerID,
          this.__hash
        );
      };
      return List2;
    }(IndexedCollection);
    List.isList = isList;
    ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SYMBOL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.merge = ListPrototype.concat;
    ListPrototype.setIn = setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
    ListPrototype.update = update;
    ListPrototype.updateIn = updateIn;
    ListPrototype.mergeIn = mergeIn;
    ListPrototype.mergeDeepIn = mergeDeepIn;
    ListPrototype.withMutations = withMutations;
    ListPrototype.wasAltered = wasAltered;
    ListPrototype.asImmutable = asImmutable;
    ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
    ListPrototype["@@transducer/step"] = function(result, arr) {
      return result.push(arr);
    };
    ListPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    VNode = function VNode2(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    };
    VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
      if (index === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    DONE = {};
    OrderedMap = function(Map3) {
      function OrderedMap2(value) {
        return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map2) {
          var iter = KeyedCollection(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (Map3)
        OrderedMap2.__proto__ = Map3;
      OrderedMap2.prototype = Object.create(Map3 && Map3.prototype);
      OrderedMap2.prototype.constructor = OrderedMap2;
      OrderedMap2.of = function of() {
        return this(arguments);
      };
      OrderedMap2.prototype.toString = function toString5() {
        return this.__toString("OrderedMap {", "}");
      };
      OrderedMap2.prototype.get = function get11(k, notSetValue) {
        var index = this._map.get(k);
        return index !== void 0 ? this._list.get(index)[1] : notSetValue;
      };
      OrderedMap2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          this.__altered = true;
          return this;
        }
        return emptyOrderedMap();
      };
      OrderedMap2.prototype.set = function set3(k, v) {
        return updateOrderedMap(this, k, v);
      };
      OrderedMap2.prototype.remove = function remove3(k) {
        return updateOrderedMap(this, k, NOT_SET);
      };
      OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._list.__iterate(
          function(entry) {
            return entry && fn(entry[1], entry[0], this$1$1);
          },
          reverse3
        );
      };
      OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._list.fromEntrySeq().__iterator(type, reverse3);
      };
      OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return emptyOrderedMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
      };
      return OrderedMap2;
    }(Map2);
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
    Stack = function(IndexedCollection2) {
      function Stack2(value) {
        return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
      }
      if (IndexedCollection2)
        Stack2.__proto__ = IndexedCollection2;
      Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      Stack2.prototype.constructor = Stack2;
      Stack2.of = function of() {
        return this(arguments);
      };
      Stack2.prototype.toString = function toString5() {
        return this.__toString("Stack [", "]");
      };
      Stack2.prototype.get = function get11(index, notSetValue) {
        var head = this._head;
        index = wrapIndex(this, index);
        while (head && index--) {
          head = head.next;
        }
        return head ? head.value : notSetValue;
      };
      Stack2.prototype.peek = function peek() {
        return this._head && this._head.value;
      };
      Stack2.prototype.push = function push() {
        var arguments$1 = arguments;
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head = {
            value: arguments$1[ii],
            next: head
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pushAll = function pushAll(iter) {
        iter = IndexedCollection2(iter);
        if (iter.size === 0) {
          return this;
        }
        if (this.size === 0 && isStack(iter)) {
          return iter;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.__iterate(
          function(value) {
            newSize++;
            head = {
              value,
              next: head
            };
          },
          /* reverse */
          true
        );
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pop = function pop() {
        return this.slice(1);
      };
      Stack2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = void 0;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyStack();
      };
      Stack2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
          return IndexedCollection2.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
          head = head.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyStack();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
      };
      Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterate(
            function(v, k) {
              return fn(v, k, this$1$1);
            },
            reverse3
          );
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };
      Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterator(type, reverse3);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function() {
          if (node) {
            var value = node.value;
            node = node.next;
            return iteratorValue(type, iterations++, value);
          }
          return iteratorDone();
        });
      };
      return Stack2;
    }(IndexedCollection);
    Stack.isStack = isStack;
    StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SYMBOL] = true;
    StackPrototype.shift = StackPrototype.pop;
    StackPrototype.unshift = StackPrototype.push;
    StackPrototype.unshiftAll = StackPrototype.pushAll;
    StackPrototype.withMutations = withMutations;
    StackPrototype.wasAltered = wasAltered;
    StackPrototype.asImmutable = asImmutable;
    StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
    StackPrototype["@@transducer/step"] = function(result, arr) {
      return result.unshift(arr);
    };
    StackPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
    Set2 = function(SetCollection2) {
      function Set3(value) {
        return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
          var iter = SetCollection2(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (SetCollection2)
        Set3.__proto__ = SetCollection2;
      Set3.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
      Set3.prototype.constructor = Set3;
      Set3.of = function of() {
        return this(arguments);
      };
      Set3.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
      };
      Set3.intersect = function intersect(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.intersect.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.union = function union(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.union.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.prototype.toString = function toString5() {
        return this.__toString("Set {", "}");
      };
      Set3.prototype.has = function has5(value) {
        return this._map.has(value);
      };
      Set3.prototype.add = function add(value) {
        return updateSet(this, this._map.set(value, value));
      };
      Set3.prototype.remove = function remove3(value) {
        return updateSet(this, this._map.remove(value));
      };
      Set3.prototype.clear = function clear2() {
        return updateSet(this, this._map.clear());
      };
      Set3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var didChanges = false;
        var newMap = updateSet(
          this,
          this._map.mapEntries(function(ref) {
            var v = ref[1];
            var mapped = mapper.call(context, v, v, this$1$1);
            if (mapped !== v) {
              didChanges = true;
            }
            return [mapped, mapped];
          }, context)
        );
        return didChanges ? newMap : this;
      };
      Set3.prototype.union = function union() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        iters = iters.filter(function(x) {
          return x.size !== 0;
        });
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set3) {
          for (var ii = 0; ii < iters.length; ii++) {
            if (typeof iters[ii] === "string") {
              set3.add(iters[ii]);
            } else {
              SetCollection2(iters[ii]).forEach(function(value) {
                return set3.add(value);
              });
            }
          }
        });
      };
      Set3.prototype.intersect = function intersect() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            toRemove.push(value);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value) {
            set3.remove(value);
          });
        });
      };
      Set3.prototype.subtract = function subtract() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            toRemove.push(value);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value) {
            set3.remove(value);
          });
        });
      };
      Set3.prototype.sort = function sort2(comparator) {
        return OrderedSet(sortFactory(this, comparator));
      };
      Set3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedSet(sortFactory(this, comparator, mapper));
      };
      Set3.prototype.wasAltered = function wasAltered3() {
        return this._map.wasAltered();
      };
      Set3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._map.__iterate(function(k) {
          return fn(k, k, this$1$1);
        }, reverse3);
      };
      Set3.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._map.__iterator(type, reverse3);
      };
      Set3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return this.__empty();
          }
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };
      return Set3;
    }(SetCollection);
    Set2.isSet = isSet;
    SetPrototype = Set2.prototype;
    SetPrototype[IS_SET_SYMBOL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
    SetPrototype.withMutations = withMutations;
    SetPrototype.asImmutable = asImmutable;
    SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
    SetPrototype["@@transducer/step"] = function(result, arr) {
      return result.add(arr);
    };
    SetPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    Range = function(IndexedSeq2) {
      function Range2(start, end, step) {
        if (!(this instanceof Range2)) {
          return new Range2(start, end, step);
        }
        invariant(step !== 0, "Cannot step a Range by 0");
        start = start || 0;
        if (end === void 0) {
          end = Infinity;
        }
        step = step === void 0 ? 1 : Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE) {
            return EMPTY_RANGE;
          }
          EMPTY_RANGE = this;
        }
      }
      if (IndexedSeq2)
        Range2.__proto__ = IndexedSeq2;
      Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Range2.prototype.constructor = Range2;
      Range2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Range []";
        }
        return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
      };
      Range2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
      };
      Range2.prototype.includes = function includes3(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
      };
      Range2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
          return new Range2(0, 0);
        }
        return new Range2(
          this.get(begin, this._end),
          this.get(end, this._end),
          this._step
        );
      };
      Range2.prototype.indexOf = function indexOf2(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index;
          }
        }
        return -1;
      };
      Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        return this.indexOf(searchValue);
      };
      Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var step = this._step;
        var value = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        while (i !== size) {
          if (fn(value, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
          value += reverse3 ? -step : step;
        }
        return i;
      };
      Range2.prototype.__iterator = function __iterator2(type, reverse3) {
        var size = this.size;
        var step = this._step;
        var value = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var v = value;
          value += reverse3 ? -step : step;
          return iteratorValue(type, reverse3 ? size - ++i : i++, v);
        });
      };
      Range2.prototype.equals = function equals3(other) {
        return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
      };
      return Range2;
    }(IndexedSeq);
    Collection.isIterable = isCollection;
    Collection.isKeyed = isKeyed;
    Collection.isIndexed = isIndexed;
    Collection.isAssociative = isAssociative;
    Collection.isOrdered = isOrdered;
    Collection.Iterator = Iterator;
    mixin(Collection, {
      // ### Conversion to other types
      toArray: function toArray() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        var useTuples = isKeyed(this);
        var i = 0;
        this.__iterate(function(v, k) {
          array[i++] = useTuples ? [k, v] : v;
        });
        return array;
      },
      toIndexedSeq: function toIndexedSeq() {
        return new ToIndexedSequence(this);
      },
      toJS: function toJS$1() {
        return toJS(this);
      },
      toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function toMap() {
        return Map2(this.toKeyedSeq());
      },
      toObject,
      toOrderedMap: function toOrderedMap() {
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function toOrderedSet() {
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function toSet() {
        return Set2(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function toSetSeq() {
        return new ToSetSequence(this);
      },
      toSeq: function toSeq() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function toStack() {
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function toList() {
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      // ### Common JavaScript methods and properties
      toString: function toString3() {
        return "[Collection]";
      },
      __toString: function __toString(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      concat: function concat() {
        var values2 = [], len = arguments.length;
        while (len--)
          values2[len] = arguments[len];
        return reify(this, concatFactory(this, values2));
      },
      includes: function includes(searchValue) {
        return this.some(function(value) {
          return is(value, searchValue);
        });
      },
      entries: function entries() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function every(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },
      partition: function partition(predicate, context) {
        return partitionFactory(this, predicate, context);
      },
      find: function find(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      forEach: function forEach(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function join(separator) {
        assertNotInfinite(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== void 0 ? v.toString() : "";
        });
        return joined;
      },
      keys: function keys() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function map(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },
      reduce: function reduce$1(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          false
        );
      },
      reduceRight: function reduceRight(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          true
        );
      },
      reverse: function reverse() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function some(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = false;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            returnValue = true;
            return false;
          }
        });
        return returnValue;
      },
      sort: function sort(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function values() {
        return this.__iterator(ITERATE_VALUES);
      },
      // ### More sequential methods
      butLast: function butLast() {
        return this.slice(0, -1);
      },
      isEmpty: function isEmpty() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function count(predicate, context) {
        return ensureSize(
          predicate ? this.toSeq().filter(predicate, context) : this
        );
      },
      countBy: function countBy(grouper, context) {
        return countByFactory(this, grouper, context);
      },
      equals: function equals(other) {
        return deepEqual(this, other);
      },
      entrySeq: function entrySeq() {
        var collection = this;
        if (collection._cache) {
          return new ArraySeq(collection._cache);
        }
        var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return collection.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function filterNot(predicate, context) {
        return this.filter(not(predicate), context);
      },
      findEntry: function findEntry(predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findKey: function findKey(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLast: function findLast(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      findLastEntry: function findLastEntry(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
      },
      findLastKey: function findLastKey(predicate, context) {
        return this.toKeyedSeq().reverse().findKey(predicate, context);
      },
      first: function first(notSetValue) {
        return this.find(returnTrue, null, notSetValue);
      },
      flatMap: function flatMap(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },
      flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function fromEntrySeq() {
        return new FromEntriesSequence(this);
      },
      get: function get7(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn,
      groupBy: function groupBy(grouper, context) {
        return groupByFactory(this, grouper, context);
      },
      has: function has2(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn,
      isSubset: function isSubset(iter) {
        iter = typeof iter.includes === "function" ? iter : Collection(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function isSuperset(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
        return iter.isSubset(this);
      },
      keyOf: function keyOf(searchValue) {
        return this.findKey(function(value) {
          return is(value, searchValue);
        });
      },
      keySeq: function keySeq() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function last(notSetValue) {
        return this.toSeq().reverse().first(notSetValue);
      },
      lastKeyOf: function lastKeyOf(searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },
      max: function max(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function maxBy(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function min(comparator) {
        return maxFactory(
          this,
          comparator ? neg(comparator) : defaultNegComparator
        );
      },
      minBy: function minBy(mapper, comparator) {
        return maxFactory(
          this,
          comparator ? neg(comparator) : defaultNegComparator,
          mapper
        );
      },
      rest: function rest() {
        return this.slice(1);
      },
      skip: function skip(amount) {
        return amount === 0 ? this : this.slice(Math.max(0, amount));
      },
      skipLast: function skipLast(amount) {
        return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
      },
      skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },
      skipUntil: function skipUntil(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },
      sortBy: function sortBy(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function take(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function takeLast(amount) {
        return this.slice(-Math.max(0, amount));
      },
      takeWhile: function takeWhile(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },
      takeUntil: function takeUntil(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },
      update: function update7(fn) {
        return fn(this);
      },
      valueSeq: function valueSeq() {
        return this.toIndexedSeq();
      },
      // ### Hashable Object
      hashCode: function hashCode() {
        return this.__hash || (this.__hash = hashCollection(this));
      }
      // ### Internal
      // abstract __iterate(fn, reverse)
      // abstract __iterator(type, reverse)
    });
    CollectionPrototype = Collection.prototype;
    CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
    CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
    CollectionPrototype.toJSON = CollectionPrototype.toArray;
    CollectionPrototype.__toStringMapper = quoteString;
    CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
      return this.toString();
    };
    CollectionPrototype.chain = CollectionPrototype.flatMap;
    CollectionPrototype.contains = CollectionPrototype.includes;
    mixin(KeyedCollection, {
      // ### More sequential methods
      flip: function flip() {
        return reify(this, flipFactory(this));
      },
      mapEntries: function mapEntries(mapper, context) {
        var this$1$1 = this;
        var iterations = 0;
        return reify(
          this,
          this.toSeq().map(function(v, k) {
            return mapper.call(context, [k, v], iterations++, this$1$1);
          }).fromEntrySeq()
        );
      },
      mapKeys: function mapKeys(mapper, context) {
        var this$1$1 = this;
        return reify(
          this,
          this.toSeq().flip().map(function(k, v) {
            return mapper.call(context, k, v, this$1$1);
          }).flip()
        );
      }
    });
    KeyedCollectionPrototype = KeyedCollection.prototype;
    KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
    KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
    KeyedCollectionPrototype.toJSON = toObject;
    KeyedCollectionPrototype.__toStringMapper = function(v, k) {
      return quoteString(k) + ": " + quoteString(v);
    };
    mixin(IndexedCollection, {
      // ### Conversion to other types
      toKeyedSeq: function toKeyedSeq2() {
        return new ToKeyedSequence(this, false);
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      filter: function filter2(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },
      findIndex: function findIndex(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function indexOf(searchValue) {
        var key = this.keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function lastIndexOf(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function reverse2() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function slice2(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function splice(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum || 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(
          this,
          numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
        );
      },
      // ### More collection methods
      findLastIndex: function findLastIndex(predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      first: function first2(notSetValue) {
        return this.get(0, notSetValue);
      },
      flatten: function flatten2(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function get8(index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, void 0, notSetValue);
      },
      has: function has3(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function interpose(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function interleave() {
        var collections = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * collections.length;
        }
        return reify(this, interleaved);
      },
      keySeq: function keySeq2() {
        return Range(0, this.size);
      },
      last: function last2(notSetValue) {
        return this.get(-1, notSetValue);
      },
      skipWhile: function skipWhile2(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },
      zip: function zip() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections));
      },
      zipAll: function zipAll() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections, true));
      },
      zipWith: function zipWith(zipper) {
        var collections = arrCopy(arguments);
        collections[0] = this;
        return reify(this, zipWithFactory(this, zipper, collections));
      }
    });
    IndexedCollectionPrototype = IndexedCollection.prototype;
    IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
    IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
    mixin(SetCollection, {
      // ### ES6 Collection methods (ES6 Array and Map)
      get: function get9(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function includes2(value) {
        return this.has(value);
      },
      // ### More sequential methods
      keySeq: function keySeq3() {
        return this.valueSeq();
      }
    });
    SetCollectionPrototype = SetCollection.prototype;
    SetCollectionPrototype.has = CollectionPrototype.includes;
    SetCollectionPrototype.contains = SetCollectionPrototype.includes;
    SetCollectionPrototype.keys = SetCollectionPrototype.values;
    mixin(KeyedSeq, KeyedCollectionPrototype);
    mixin(IndexedSeq, IndexedCollectionPrototype);
    mixin(SetSeq, SetCollectionPrototype);
    OrderedSet = function(Set3) {
      function OrderedSet2(value) {
        return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
          var iter = SetCollection(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (Set3)
        OrderedSet2.__proto__ = Set3;
      OrderedSet2.prototype = Object.create(Set3 && Set3.prototype);
      OrderedSet2.prototype.constructor = OrderedSet2;
      OrderedSet2.of = function of() {
        return this(arguments);
      };
      OrderedSet2.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
      };
      OrderedSet2.prototype.toString = function toString5() {
        return this.__toString("OrderedSet {", "}");
      };
      return OrderedSet2;
    }(Set2);
    OrderedSet.isOrderedSet = isOrderedSet;
    OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
    OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
    OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
    OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    PairSorting = {
      LeftThenRight: -1,
      RightThenLeft: 1
    };
    Record = function Record2(defaultValues, name) {
      var hasInitialized;
      throwOnInvalidDefaultValues(defaultValues);
      var RecordType = function Record3(values2) {
        var this$1$1 = this;
        if (values2 instanceof RecordType) {
          return values2;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values2);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys2 = Object.keys(defaultValues);
          var indices = RecordTypePrototype._indices = {};
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys2;
          RecordTypePrototype._defaultValues = defaultValues;
          for (var i = 0; i < keys2.length; i++) {
            var propName = keys2[i];
            indices[propName] = i;
            if (RecordTypePrototype[propName]) {
              typeof console === "object" && console.warn && console.warn(
                "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
              );
            } else {
              setProp(RecordTypePrototype, propName);
            }
          }
        }
        this.__ownerID = void 0;
        this._values = List().withMutations(function(l) {
          l.setSize(this$1$1._keys.length);
          KeyedCollection(values2).forEach(function(v, k) {
            l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
          });
        });
        return this;
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      if (name) {
        RecordType.displayName = name;
      }
      return RecordType;
    };
    Record.prototype.toString = function toString4() {
      var str = recordName(this) + " { ";
      var keys2 = this._keys;
      var k;
      for (var i = 0, l = keys2.length; i !== l; i++) {
        k = keys2[i];
        str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
      }
      return str + " }";
    };
    Record.prototype.equals = function equals2(other) {
      return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
    };
    Record.prototype.hashCode = function hashCode2() {
      return recordSeq(this).hashCode();
    };
    Record.prototype.has = function has4(k) {
      return this._indices.hasOwnProperty(k);
    };
    Record.prototype.get = function get10(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var index = this._indices[k];
      var value = this._values.get(index);
      return value === void 0 ? this._defaultValues[k] : value;
    };
    Record.prototype.set = function set2(k, v) {
      if (this.has(k)) {
        var newValues = this._values.set(
          this._indices[k],
          v === this._defaultValues[k] ? void 0 : v
        );
        if (newValues !== this._values && !this.__ownerID) {
          return makeRecord(this, newValues);
        }
      }
      return this;
    };
    Record.prototype.remove = function remove2(k) {
      return this.set(k);
    };
    Record.prototype.clear = function clear() {
      var newValues = this._values.clear().setSize(this._keys.length);
      return this.__ownerID ? this : makeRecord(this, newValues);
    };
    Record.prototype.wasAltered = function wasAltered2() {
      return this._values.wasAltered();
    };
    Record.prototype.toSeq = function toSeq2() {
      return recordSeq(this);
    };
    Record.prototype.toJS = function toJS$12() {
      return toJS(this);
    };
    Record.prototype.entries = function entries2() {
      return this.__iterator(ITERATE_ENTRIES);
    };
    Record.prototype.__iterator = function __iterator(type, reverse3) {
      return recordSeq(this).__iterator(type, reverse3);
    };
    Record.prototype.__iterate = function __iterate(fn, reverse3) {
      return recordSeq(this).__iterate(fn, reverse3);
    };
    Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newValues = this._values.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._values = newValues;
        return this;
      }
      return makeRecord(this, newValues, ownerID);
    };
    Record.isRecord = isRecord;
    Record.getDescriptiveName = recordName;
    RecordPrototype = Record.prototype;
    RecordPrototype[IS_RECORD_SYMBOL] = true;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
    RecordPrototype.getIn = getIn;
    RecordPrototype.hasIn = CollectionPrototype.hasIn;
    RecordPrototype.merge = merge$1;
    RecordPrototype.mergeWith = mergeWith$1;
    RecordPrototype.mergeIn = mergeIn;
    RecordPrototype.mergeDeep = mergeDeep;
    RecordPrototype.mergeDeepWith = mergeDeepWith;
    RecordPrototype.mergeDeepIn = mergeDeepIn;
    RecordPrototype.setIn = setIn;
    RecordPrototype.update = update;
    RecordPrototype.updateIn = updateIn;
    RecordPrototype.withMutations = withMutations;
    RecordPrototype.asMutable = asMutable;
    RecordPrototype.asImmutable = asImmutable;
    RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
    RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
    RecordPrototype.inspect = RecordPrototype.toSource = function() {
      return this.toString();
    };
    Repeat = function(IndexedSeq2) {
      function Repeat2(value, times) {
        if (!(this instanceof Repeat2)) {
          return new Repeat2(value, times);
        }
        this._value = value;
        this.size = times === void 0 ? Infinity : Math.max(0, times);
        if (this.size === 0) {
          if (EMPTY_REPEAT) {
            return EMPTY_REPEAT;
          }
          EMPTY_REPEAT = this;
        }
      }
      if (IndexedSeq2)
        Repeat2.__proto__ = IndexedSeq2;
      Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Repeat2.prototype.constructor = Repeat2;
      Repeat2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Repeat []";
        }
        return "Repeat [ " + this._value + " " + this.size + " times ]";
      };
      Repeat2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };
      Repeat2.prototype.includes = function includes3(searchValue) {
        return is(this._value, searchValue);
      };
      Repeat2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size) ? this : new Repeat2(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
      };
      Repeat2.prototype.reverse = function reverse3() {
        return this;
      };
      Repeat2.prototype.indexOf = function indexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };
      Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };
      Repeat2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var i = 0;
        while (i !== size) {
          if (fn(this._value, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
        }
        return i;
      };
      Repeat2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var size = this.size;
        var i = 0;
        return new Iterator(
          function() {
            return i === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i : i++, this$1$1._value);
          }
        );
      };
      Repeat2.prototype.equals = function equals3(other) {
        return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual(other);
      };
      return Repeat2;
    }(IndexedSeq);
    version = "4.3.4";
    Immutable = {
      version,
      Collection,
      // Note: Iterable is deprecated
      Iterable: Collection,
      Seq,
      Map: Map2,
      OrderedMap,
      List,
      Stack,
      Set: Set2,
      OrderedSet,
      PairSorting,
      Record,
      Range,
      Repeat,
      is,
      fromJS,
      hash: hash2,
      isImmutable,
      isCollection,
      isKeyed,
      isIndexed,
      isAssociative,
      isOrdered,
      isValueObject,
      isPlainObject,
      isSeq,
      isList,
      isMap,
      isOrderedMap,
      isStack,
      isSet,
      isOrderedSet,
      isRecord,
      get,
      getIn: getIn$1,
      has,
      hasIn: hasIn$1,
      merge,
      mergeDeep: mergeDeep$1,
      mergeWith,
      mergeDeepWith: mergeDeepWith$1,
      remove,
      removeIn,
      set,
      setIn: setIn$1,
      update: update$1,
      updateIn: updateIn$1
    };
    Iterable = Collection;
    immutable_es_default = Immutable;
  }
});

// node_modules/@starknet-react/core/dist/providers/transaction.js
var require_transaction = __commonJS({
  "node_modules/@starknet-react/core/dist/providers/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionManagerProvider = exports.useTransactionManager = exports.TransactionManagerContext = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var immutable_1 = (init_immutable_es(), __toCommonJS(immutable_es_exports));
    exports.TransactionManagerContext = (0, react_1.createContext)({
      transactions: [],
      hashes: [],
      addTransaction: ({ hash: _hash, metadata: _metadata }) => void 0,
      removeTransaction: ({ hash: _hash }) => void 0
    });
    function useTransactionManager() {
      const context = (0, react_1.useContext)(exports.TransactionManagerContext);
      if (!context) {
        throw new Error("useTransactionManager must be used inside TransactionManagerProvider");
      }
      return context;
    }
    exports.useTransactionManager = useTransactionManager;
    function TransactionManagerProvider({ children }) {
      const [state, dispatch] = (0, react_1.useReducer)(reducer, {
        hashes: (0, immutable_1.OrderedSet)(),
        transactions: (0, immutable_1.OrderedMap)()
      });
      const addTransaction = (0, react_1.useCallback)(({ hash: hash3, metadata }) => {
        dispatch({ type: "add_transaction", hash: hash3, metadata });
      }, [dispatch]);
      const removeTransaction = (0, react_1.useCallback)(({ hash: hash3 }) => {
        dispatch({ type: "remove_transaction", hash: hash3 });
      }, [dispatch]);
      const Provider = exports.TransactionManagerContext.Provider;
      const transactions = state.transactions;
      return (0, jsx_runtime_1.jsx)(Provider, { value: {
        transactions: transactions.valueSeq().toArray(),
        hashes: transactions.keySeq().toArray(),
        addTransaction,
        removeTransaction
      }, children });
    }
    exports.TransactionManagerProvider = TransactionManagerProvider;
    function reducer(state, action) {
      switch (action.type) {
        case "add_transaction": {
          const hashes = state.hashes.add(action.hash);
          const transactions = state.transactions.set(action.hash, {
            hash: action.hash,
            metadata: action.metadata
          });
          return { ...state, hashes, transactions };
        }
        case "remove_transaction": {
          const hashes = state.hashes.remove(action.hash);
          const transactions = state.transactions.delete(action.hash);
          return { ...state, hashes, transactions };
        }
        default: {
          return state;
        }
      }
    }
  }
});

// node_modules/@starknet-react/core/dist/providers/index.js
var require_providers = __commonJS({
  "node_modules/@starknet-react/core/dist/providers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarknetConfig = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var starknet_1 = require_starknet();
    var transaction_1 = require_transaction();
    __exportStar(require_starknet(), exports);
    __exportStar(require_transaction(), exports);
    function StarknetConfig({ children, ...config }) {
      return (0, jsx_runtime_1.jsx)(starknet_1.StarknetProvider, { ...config, children: (0, jsx_runtime_1.jsx)(transaction_1.TransactionManagerProvider, { children }) });
    }
    exports.StarknetConfig = StarknetConfig;
  }
});

// node_modules/@starknet-react/core/dist/hooks/connectors.js
var require_connectors = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/connectors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useConnectors = void 0;
    var react_1 = require_react();
    var providers_1 = require_providers();
    function useConnectors() {
      const { connectors, connect, disconnect } = (0, providers_1.useStarknet)();
      const [available, setAvailable] = (0, react_1.useState)([]);
      const [isLoading, setIsLoading] = (0, react_1.useState)(true);
      (0, react_1.useEffect)(() => {
        setAvailable(connectors.filter((conn) => conn.available()));
        setIsLoading(false);
      }, [connectors, setAvailable]);
      const refresh = (0, react_1.useCallback)(() => {
        setAvailable(connectors.filter((conn) => conn.available()));
        setIsLoading(false);
      }, [connectors, setAvailable, setIsLoading]);
      return { available, connectors, connect, disconnect, refresh, isLoading };
    }
    exports.useConnectors = useConnectors;
  }
});

// node_modules/@starknet-react/core/dist/hooks/account.js
var require_account = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAccount = void 0;
    var react_1 = require_react();
    var connectors_1 = require_connectors();
    var providers_1 = require_providers();
    function useAccount({ onConnect, onDisconnect } = {}) {
      const { account: connectedAccount } = (0, providers_1.useStarknet)();
      const { connectors } = (0, connectors_1.useConnectors)();
      const [state, setState] = (0, react_1.useState)({ status: "disconnected" });
      const refreshState = (0, react_1.useCallback)(async () => {
        if (!connectedAccount) {
          if (!state.isDisconnected && onDisconnect !== void 0) {
            onDisconnect();
          }
          return setState({
            status: "disconnected",
            isDisconnected: true,
            isConnected: false,
            isConnecting: false,
            isReconnecting: false
          });
        }
        for (const connector of connectors) {
          if (!connector.available())
            continue;
          const connAccount = await connector.account();
          if (connAccount && (connAccount == null ? void 0 : connAccount.address) === connectedAccount) {
            if (state.isDisconnected && onConnect !== void 0) {
              onConnect({ address: connectedAccount, connector });
            }
            return setState({
              connector,
              account: connAccount,
              address: connectedAccount,
              status: "connected",
              isConnected: true,
              isConnecting: false,
              isDisconnected: false,
              isReconnecting: false
            });
          }
        }
      }, [setState, connectedAccount, connectors, onConnect, onDisconnect, state.isDisconnected]);
      (0, react_1.useEffect)(() => {
        refreshState();
      }, [refreshState]);
      return state;
    }
    exports.useAccount = useAccount;
  }
});

// node_modules/@starknet-react/core/dist/hooks/block.js
var require_block = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useBlockNumber = exports.useBlock = void 0;
    var react_query_1 = require_lib2();
    var providers_1 = require_providers();
    function useBlock({ refetchInterval, onSuccess, blockIdentifier = "latest" } = {}) {
      const { library } = (0, providers_1.useStarknet)();
      const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)(["block", blockIdentifier], fetchBlock({ library, args: { blockIdentifier } }), {
        refetchInterval,
        useErrorBoundary: true,
        onSuccess: (block) => {
          if (block && onSuccess)
            onSuccess(block);
        }
      });
      return {
        data,
        error,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useBlock = useBlock;
    function fetchBlock({ library, args }) {
      return async () => {
        return await library.getBlock(args.blockIdentifier);
      };
    }
    function useBlockNumber({ refetchInterval, onSuccess } = {}) {
      const { library } = (0, providers_1.useStarknet)();
      const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)(["block", "latest"], fetchBlock({ library, args: { blockIdentifier: "latest" } }), {
        refetchInterval,
        useErrorBoundary: true,
        onSuccess: (block) => {
          if (block && onSuccess)
            onSuccess(block.block_number);
        }
      });
      return {
        data: data == null ? void 0 : data.block_number,
        error,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useBlockNumber = useBlockNumber;
  }
});

// node_modules/@starknet-react/core/dist/hooks/invalidate.js
var require_invalidate = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/invalidate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInvalidateOnBlock = void 0;
    var react_query_1 = require_lib2();
    var react_1 = require_react();
    var block_1 = require_block();
    function useInvalidateOnBlock({ enabled, queryKey }) {
      const queryClient = (0, react_query_1.useQueryClient)();
      const [previousHash, setPreviousHash] = (0, react_1.useState)(void 0);
      (0, block_1.useBlock)({
        refetchInterval: 5e3,
        onSuccess: enabled ? async (block) => {
          if (block.block_hash !== previousHash) {
            await queryClient.invalidateQueries(queryKey, { refetchType: "all" });
            setPreviousHash(block.block_hash);
          }
        } : void 0
      });
    }
    exports.useInvalidateOnBlock = useInvalidateOnBlock;
  }
});

// node_modules/zod/lib/helpers/util.js
var require_util = __commonJS({
  "node_modules/zod/lib/helpers/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys2 = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys2.push(key);
          }
        }
        return keys2;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util = exports.util || (exports.util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first3, second) => {
        return {
          ...first3,
          ...second
        };
      };
    })(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
    exports.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType;
  }
});

// node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
  "node_modules/zod/lib/ZodError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
    var util_1 = require_util();
    exports.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports.quotelessJson = quotelessJson;
    var ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
  "node_modules/zod/lib/locales/en.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports.default = errorMap;
  }
});

// node_modules/zod/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/zod/lib/errors.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports.defaultErrorMap = en_1.default;
    var overrideErrorMap = en_1.default;
    function setErrorMap(map2) {
      overrideErrorMap = map2;
    }
    exports.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    exports.getErrorMap = getErrorMap;
  }
});

// node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
  "node_modules/zod/lib/helpers/parseUtil.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
    var errors_1 = require_errors2();
    var en_1 = __importDefault(require_en());
    var makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    exports.makeIssue = makeIssue;
    exports.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          (0, errors_1.getErrorMap)(),
          en_1.default
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports.addIssueToContext = addIssueToContext;
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports.ParseStatus = ParseStatus;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports.isValid = isValid;
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports.isAsync = isAsync;
  }
});

// node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
  "node_modules/zod/lib/helpers/typeAliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
  "node_modules/zod/lib/helpers/errorUtil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
  }
});

// node_modules/zod/lib/types.js
var require_types = __commonJS({
  "node_modules/zod/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
    exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
    var errors_1 = require_errors2();
    var errorUtil_1 = require_errorUtil();
    var parseUtil_1 = require_parseUtil();
    var util_1 = require_util();
    var ZodError_1 = require_ZodError();
    var ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports.ZodType = ZodType;
    exports.Schema = ZodType;
    exports.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[a-z][a-z0-9]*$/;
    var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
    var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var emailRegex = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
    var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class _ZodString extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil_1.errorUtil.errToObj(message));
        this.trim = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
        this.toLowerCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
        this.toUpperCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    exports.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          } else if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    };
    exports.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2;
      }
    };
    exports.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min2 === null || ch.value > min2)
              min2 = ch.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max2 === null || ch.value < max2)
              max2 = ch.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    };
    exports.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    };
    exports.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        });
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys2 = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys: keys2 };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    };
    exports.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports.ZodUnion = ZodUnion;
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest2 = this._def.rest;
        if (!rest2 && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest2) {
        return new _ZodTuple({
          ...this._def,
          rest: rest2
        });
      }
    };
    exports.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first3, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first3,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first3,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values2, params) {
      return new ZodEnum({
        values: values2,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values2) {
        return _ZodEnum.create(values2);
      }
      exclude(values2) {
        return _ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
      }
    };
    exports.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values2, params) => {
      return new ZodNativeEnum({
        values: values2,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_1.isValid)(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    };
    exports.ZodEffects = ZodEffects;
    exports.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if ((0, parseUtil_1.isValid)(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    };
    exports.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    var custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    exports.custom = custom;
    exports.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => (0, exports.custom)((data) => data instanceof cls, params);
    exports.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports.string = stringType;
    var numberType = ZodNumber.create;
    exports.number = numberType;
    var nanType = ZodNaN.create;
    exports.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports.boolean = booleanType;
    var dateType = ZodDate.create;
    exports.date = dateType;
    var symbolType = ZodSymbol.create;
    exports.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports.null = nullType;
    var anyType = ZodAny.create;
    exports.any = anyType;
    var unknownType = ZodUnknown.create;
    exports.unknown = unknownType;
    var neverType = ZodNever.create;
    exports.never = neverType;
    var voidType = ZodVoid.create;
    exports.void = voidType;
    var arrayType = ZodArray.create;
    exports.array = arrayType;
    var objectType = ZodObject.create;
    exports.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports.record = recordType;
    var mapType = ZodMap.create;
    exports.map = mapType;
    var setType = ZodSet.create;
    exports.set = setType;
    var functionType = ZodFunction.create;
    exports.function = functionType;
    var lazyType = ZodLazy.create;
    exports.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports.literal = literalType;
    var enumType = ZodEnum.create;
    exports.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports.effect = effectsType;
    exports.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports.ostring = ostring;
    var onumber = () => numberType().optional();
    exports.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports.oboolean = oboolean;
    exports.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    exports.NEVER = parseUtil_1.INVALID;
  }
});

// node_modules/zod/lib/external.js
var require_external = __commonJS({
  "node_modules/zod/lib/external.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors2(), exports);
    __exportStar(require_parseUtil(), exports);
    __exportStar(require_typeAliases(), exports);
    __exportStar(require_util(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_ZodError(), exports);
  }
});

// node_modules/zod/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/zod/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    var z = __importStar(require_external());
    exports.z = z;
    __exportStar(require_external(), exports);
    exports.default = z;
  }
});

// node_modules/@starknet-react/core/dist/hooks/balanceSchema.js
var require_balanceSchema = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/balanceSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.balanceSchema = exports.symbolSchema = exports.decimalsSchema = exports.uint256Schema = void 0;
    var zod_1 = require_lib4();
    exports.uint256Schema = zod_1.z.object({
      low: zod_1.z.bigint(),
      high: zod_1.z.bigint()
    });
    exports.decimalsSchema = zod_1.z.object({
      decimals: zod_1.z.bigint()
    });
    exports.symbolSchema = zod_1.z.object({
      symbol: zod_1.z.bigint()
    });
    exports.balanceSchema = zod_1.z.object({
      balance: exports.uint256Schema
    });
  }
});

// node_modules/@starknet-react/core/dist/hooks/balance.js
var require_balance = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/balance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useBalance = void 0;
    var starknet_1 = require_dist();
    var react_1 = require_react();
    var react_query_1 = require_lib2();
    var invalidate_1 = require_invalidate();
    var __1 = require_dist2();
    var balanceSchema_1 = require_balanceSchema();
    var ETHTokenAddress = "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";
    var balanceABIFragment = [
      {
        members: [
          {
            name: "low",
            offset: 0,
            type: "felt"
          },
          {
            name: "high",
            offset: 1,
            type: "felt"
          }
        ],
        name: "Uint256",
        size: 2,
        type: "struct"
      },
      {
        name: "balanceOf",
        type: "function",
        inputs: [
          {
            name: "account",
            type: "felt"
          }
        ],
        outputs: [
          {
            name: "balance",
            type: "Uint256"
          }
        ],
        stateMutability: "view"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            name: "symbol",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            name: "decimals",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    function useBalance({ token = ETHTokenAddress, address, formatUnits, watch = false, blockIdentifier = "pending" }) {
      const { chain } = (0, __1.useNetwork)();
      const { contract } = (0, __1.useContract)({ abi: balanceABIFragment, address: token });
      const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, args: { contract, address, blockIdentifier } }), [chain, contract, address, blockIdentifier]);
      const { data: contractData, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)(queryKey_, readContract({ args: { contract, address, blockIdentifier } }), {
        enabled: !!address
      });
      (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
      const data = (0, react_1.useMemo)(() => {
        if (!contractData) {
          return void 0;
        }
        const { decimals: { decimals: contractDecimals }, balance: { balance: balanceUint256 }, symbol: { symbol } } = contractData;
        const decimals = Number(contractDecimals);
        const balanceAsBN = starknet_1.uint256.uint256ToBN(balanceUint256);
        const formatted = (Number(balanceAsBN.toString()) / 10 ** (formatUnits || decimals)).toString();
        const formattedSymbol = starknet_1.shortString.decodeShortString(starknet_1.num.toHex(symbol));
        return {
          decimals,
          formatted,
          symbol: formattedSymbol,
          value: balanceAsBN
        };
      }, [contractData, formatUnits]);
      return {
        data,
        error: error ?? void 0,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useBalance = useBalance;
    function readContract({ args }) {
      return async () => {
        if (!args.address || !args.contract)
          return null;
        try {
          const [balance, symbol, decimals] = await Promise.all([
            args.contract.call("balanceOf", [args.address], {
              parseResponse: true
            }),
            args.contract.call("symbol", []),
            args.contract.call("decimals", [])
          ]);
          const parsedBalance = balanceSchema_1.balanceSchema.parse(balance);
          const parsedSymbol = balanceSchema_1.symbolSchema.parse(symbol);
          const parsedDecimals = balanceSchema_1.decimalsSchema.parse(decimals);
          return { balance: parsedBalance, symbol: parsedSymbol, decimals: parsedDecimals };
        } catch {
          return null;
        }
      };
    }
    function queryKey({ chain, args }) {
      const { contract, address: callArgs, blockIdentifier } = args;
      return [
        {
          entity: "balance",
          chainId: chain == null ? void 0 : chain.id,
          contract: contract == null ? void 0 : contract.address,
          args: callArgs,
          blockIdentifier
        }
      ];
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/contract.js
var require_contract = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useContractFactory = exports.useContract = void 0;
    var react_1 = require_react();
    var starknet_1 = require_dist();
    var providers_1 = require_providers();
    function useContract({ abi, address }) {
      const { library } = (0, providers_1.useStarknet)();
      const contract = (0, react_1.useMemo)(() => {
        if (abi && address && library) {
          return new starknet_1.Contract(abi, address, library);
        }
      }, [abi, address, library]);
      return { contract };
    }
    exports.useContract = useContract;
    function useContractFactory({ compiledContract, classHash, abi, account }) {
      const contractFactory = (0, react_1.useMemo)(() => {
        if (compiledContract && account && classHash) {
          return new starknet_1.ContractFactory(compiledContract, classHash, account, abi);
        }
      }, [compiledContract, classHash, account, abi]);
      return { contractFactory };
    }
    exports.useContractFactory = useContractFactory;
  }
});

// node_modules/@starknet-react/core/dist/network.js
var require_network = __commonJS({
  "node_modules/@starknet-react/core/dist/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainById = void 0;
    var starknet_1 = require_dist();
    function chainById(chainId) {
      return KNOWN_CHAINS[chainId];
    }
    exports.chainById = chainById;
    var KNOWN_CHAINS = {
      [starknet_1.constants.StarknetChainId.SN_MAIN]: {
        id: starknet_1.constants.StarknetChainId.SN_MAIN,
        name: "Starknet Mainnet",
        testnet: false
      },
      [starknet_1.constants.StarknetChainId.SN_GOERLI]: {
        id: starknet_1.constants.StarknetChainId.SN_GOERLI,
        name: "Starknet Grli"
      },
      [starknet_1.constants.StarknetChainId.SN_GOERLI2]: {
        id: starknet_1.constants.StarknetChainId.SN_GOERLI2,
        name: "Starknet Grli 2"
      }
    };
  }
});

// node_modules/@starknet-react/core/dist/hooks/network.js
var require_network2 = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useNetwork = void 0;
    var react_1 = require_react();
    var providers_1 = require_providers();
    var network_1 = require_network();
    function useNetwork() {
      const { library } = (0, providers_1.useStarknet)();
      const [chain, setChain] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (library) {
          library.getChainId().then((chainId) => setChain((0, network_1.chainById)(chainId)));
        } else {
          setChain(void 0);
        }
      }, [library]);
      return { chain };
    }
    exports.useNetwork = useNetwork;
  }
});

// node_modules/@starknet-react/core/dist/hooks/call.js
var require_call = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useContractRead = void 0;
    var react_query_1 = require_lib2();
    var react_1 = require_react();
    var contract_1 = require_contract();
    var invalidate_1 = require_invalidate();
    var network_1 = require_network2();
    function useContractRead({ abi, address, functionName, args, watch = false, blockIdentifier = "pending" }) {
      const { chain } = (0, network_1.useNetwork)();
      const { contract } = (0, contract_1.useContract)({ abi, address });
      const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, args: { contract, functionName, args, blockIdentifier } }), [chain, contract, functionName, args, blockIdentifier]);
      const {
        data,
        error,
        isStale: isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } = (0, react_query_1.useQuery)(queryKey_, readContract({ args: { contract, functionName, args, blockIdentifier } }));
      (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
      return {
        data,
        error: error ?? void 0,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useContractRead = useContractRead;
    function readContract({ args }) {
      return async () => {
        if (!args.args || !args.contract || !args.functionName)
          return null;
        const canCall = args.contract && args.functionName;
        if (!canCall)
          return null;
        const call = args.contract[args.functionName];
        if (!call)
          throw new Error(`Function ${args.functionName} not found on contract`);
        return await call(...args.args, {
          blockIdentifier: args.blockIdentifier
        });
      };
    }
    function queryKey({ chain, args }) {
      const { contract, functionName, args: callArgs, blockIdentifier } = args;
      return [
        {
          entity: "readContract",
          chain,
          contract: contract == null ? void 0 : contract.address,
          functionName,
          args: callArgs,
          blockIdentifier
        }
      ];
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/deploy.js
var require_deploy = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/deploy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDeploy = void 0;
    var react_query_1 = require_lib2();
    var starknet_1 = require_dist();
    function useDeploy({ contractFactory, constructorCalldata, addressSalt }) {
      const { data, isLoading, error, reset, mutateAsync, mutate, isError, isIdle, isSuccess, status } = (0, react_query_1.useMutation)(deployContract({ contractFactory, constructorCalldata, addressSalt }));
      return {
        data,
        isLoading,
        error: error ?? void 0,
        reset,
        deploy: mutate,
        deployAsync: mutateAsync,
        isError,
        isIdle,
        isSuccess,
        status
      };
    }
    exports.useDeploy = useDeploy;
    function deployContract({ contractFactory, constructorCalldata, addressSalt }) {
      return async () => {
        if (contractFactory === void 0) {
          throw new Error("No contract factory defined");
        }
        return await contractFactory.deploy(starknet_1.CallData.toCalldata(constructorCalldata), { addressSalt });
      };
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/execute.js
var require_execute = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/execute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useContractWrite = void 0;
    var react_query_1 = require_lib2();
    var account_1 = require_account();
    function useContractWrite({ calls, metadata }) {
      const { account } = (0, account_1.useAccount)();
      const { data, isLoading, error, reset, mutate, mutateAsync, isIdle, isSuccess, status, isError } = (0, react_query_1.useMutation)(writeContract({ account, args: { calls, metadata } }));
      return {
        data,
        error: error ?? void 0,
        reset,
        write: mutate,
        writeAsync: mutateAsync,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        status
      };
    }
    exports.useContractWrite = useContractWrite;
    function writeContract({ account, args }) {
      return async () => {
        const { calls, metadata } = args;
        if (account === void 0) {
          throw new Error("No connector connected");
        }
        if (calls === void 0) {
          throw new Error("No calls specified");
        }
        const response = await account.execute(calls);
        console.warn(`TODO: ignoring metadata`, metadata);
        return response;
      };
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/library.js
var require_library = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/library.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useProvider = void 0;
    var providers_1 = require_providers();
    function useProvider() {
      const { library: provider2 } = (0, providers_1.useStarknet)();
      return { provider: provider2 };
    }
    exports.useProvider = useProvider;
  }
});

// node_modules/@starknet-react/core/dist/hooks/sign.js
var require_sign = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/sign.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSignTypedData = void 0;
    var starknet_1 = require_dist();
    var react_1 = require_react();
    var account_1 = require_account();
    var connectors_1 = require_connectors();
    function starknetSignReducer(state, action) {
      if (action.type === "start_signing") {
        return {
          ...state,
          isLoading: true
        };
      } else if (action.type === "set_signature") {
        return {
          ...state,
          data: starknet_1.stark.formatSignature(action.data),
          isLoading: false
        };
      } else if (action.type === "set_error") {
        return {
          ...state,
          error: action.error,
          isLoading: false
        };
      } else if (action.type === "reset") {
        return {
          ...state,
          data: void 0,
          error: void 0,
          isLoading: false
        };
      }
      return state;
    }
    function useSignTypedData(typedData2) {
      const [state, dispatch] = (0, react_1.useReducer)(starknetSignReducer, {
        isLoading: false
      });
      const { address: accountAddress } = (0, account_1.useAccount)();
      const { connectors } = (0, connectors_1.useConnectors)();
      const reset = (0, react_1.useCallback)(() => {
        dispatch({ type: "reset" });
      }, [dispatch]);
      const { data, error, isLoading } = state;
      const signTypedData = (0, react_1.useCallback)(async () => {
        dispatch({ type: "reset" });
        dispatch({ type: "start_signing" });
        try {
          let accountInterface = null;
          const availableConnectors = connectors.filter((conn) => conn.available());
          for (const connector of availableConnectors) {
            const account = await connector.account();
            if (account && account.address === accountAddress) {
              accountInterface = account;
              break;
            }
          }
          if (!accountInterface) {
            throw new Error(`No connector for address ${accountAddress}`);
          }
          const response = await accountInterface.signMessage(typedData2);
          dispatch({ type: "set_signature", data: response });
          return response;
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : String(err);
          dispatch({ type: "set_error", error: errorMessage });
          console.error(err);
        }
      }, [accountAddress, connectors, typedData2]);
      return {
        data,
        error,
        isLoading,
        isError: error ? true : false,
        signTypedData,
        reset
      };
    }
    exports.useSignTypedData = useSignTypedData;
  }
});

// node_modules/@starknet-react/core/dist/hooks/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTransactions = exports.useTransaction = void 0;
    var react_query_1 = require_lib2();
    var providers_1 = require_providers();
    var invalidate_1 = require_invalidate();
    var network_1 = require_network2();
    function useTransaction({ hash: hash3, watch = false }) {
      const { library } = (0, providers_1.useStarknet)();
      const { chain } = (0, network_1.useNetwork)();
      const queryKey_ = queryKey({ chain, hash: hash3 });
      const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)(queryKey_, fetchTransaction({
        library,
        hash: hash3
      }));
      (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
      return {
        data,
        error: error ?? void 0,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useTransaction = useTransaction;
    function useTransactions({ hashes, watch = false }) {
      const { library } = (0, providers_1.useStarknet)();
      const { chain } = (0, network_1.useNetwork)();
      const result = (0, react_query_1.useQueries)({
        queries: hashes.map((hash3) => ({
          queryKey: queryKey({ chain, hash: hash3 }),
          queryFn: fetchTransaction({
            library,
            hash: hash3
          })
        }))
      });
      (0, invalidate_1.useInvalidateOnBlock)({
        enabled: watch,
        queryKey: [{ entity: "transaction", chainId: chain == null ? void 0 : chain.id }]
      });
      return result.map(({ data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status }) => ({
        data,
        error: error ?? void 0,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      }));
    }
    exports.useTransactions = useTransactions;
    function queryKey({ chain, hash: hash3 }) {
      return [
        {
          entity: "transaction",
          chainId: chain == null ? void 0 : chain.id,
          hash: hash3
        }
      ];
    }
    function fetchTransaction({ library, hash: hash3 }) {
      return async () => {
        if (!hash3)
          throw new Error("hash is required");
        return await library.getTransaction(hash3);
      };
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/receipt.js
var require_receipt = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/receipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWaitForTransaction = void 0;
    var react_query_1 = require_lib2();
    var react_1 = require_react();
    var providers_1 = require_providers();
    var invalidate_1 = require_invalidate();
    var network_1 = require_network2();
    function useWaitForTransaction({ hash: hash3, watch, onAcceptedOnL1, onAcceptedOnL2, onNotReceived, onPending, onReceived, onRejected }) {
      const { library } = (0, providers_1.useStarknet)();
      const { chain } = (0, network_1.useNetwork)();
      const queryKey_ = (0, react_1.useMemo)(() => queryKey({ chain, hash: hash3 }), [chain, hash3]);
      const { data, error, isStale: isIdle, isLoading, isFetching, isSuccess, isError, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)(queryKey_, fetchTransactionReceipt({ library, hash: hash3 }), {
        enabled: !!hash3,
        refetchInterval: (data2, _query) => watch ? refetchInterval(data2) : false,
        onSuccess: (data2) => {
          const { status: status2 } = data2;
          switch (status2) {
            case "ACCEPTED_ON_L1":
              if (onAcceptedOnL1) {
                onAcceptedOnL1(data2);
              }
              break;
            case "ACCEPTED_ON_L2":
              if (onAcceptedOnL2) {
                onAcceptedOnL2(data2);
              }
              break;
            case "NOT_RECEIVED":
              if (onNotReceived) {
                onNotReceived(data2);
              }
              break;
            case "PENDING":
              if (onPending) {
                onPending(data2);
              }
              break;
            case "RECEIVED":
              if (onReceived) {
                onReceived(data2);
              }
              break;
            case "REJECTED":
              if (onRejected) {
                onRejected(data2);
              }
              break;
          }
        }
      });
      (0, invalidate_1.useInvalidateOnBlock)({ enabled: watch, queryKey: queryKey_ });
      return {
        data,
        error: error ?? void 0,
        isIdle,
        isLoading,
        isFetching,
        isSuccess,
        isError,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useWaitForTransaction = useWaitForTransaction;
    function queryKey({ chain, hash: hash3 }) {
      return [{ entity: "transactionReceipt", chainId: chain == null ? void 0 : chain.id, hash: hash3 }];
    }
    function fetchTransactionReceipt({ library, hash: hash3 }) {
      return async () => {
        if (!hash3)
          throw new Error("hash is required");
        return await library.getTransactionReceipt(hash3);
      };
    }
    function refetchInterval(data) {
      if (!data)
        return false;
      const { status } = data;
      switch (status) {
        case "ACCEPTED_ON_L1":
          return false;
        case "ACCEPTED_ON_L2":
          return 6e4;
        case "NOT_RECEIVED":
          return 500;
        case "PENDING":
          return 5e3;
        case "RECEIVED":
          return 5e3;
        case "REJECTED":
          return false;
        default:
          return false;
      }
    }
  }
});

// node_modules/@starknet-react/core/dist/hooks/starknetid.js
var require_starknetid = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/starknetid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAddressFromStarkName = exports.useStarkName = void 0;
    var react_query_1 = require_lib2();
    var starknet_1 = require_dist();
    var providers_1 = require_providers();
    function useStarkName({ address, contract }) {
      const { library } = (0, providers_1.useStarknet)();
      const { data, isLoading, isSuccess, isError, error, isFetching, isStale: isIdle, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)({
        queryKey: ["starkName"],
        queryFn: async () => {
          const provider2 = new starknet_1.Provider(library);
          console.log("lookup ", address, " on ", contract);
          const result = provider2.getStarkName(address, contract);
          console.log("result", result);
          if (result instanceof Error)
            throw new Error(result.message);
          return result;
        }
      });
      return {
        data,
        isLoading,
        isSuccess,
        isError,
        error,
        isIdle,
        isFetching,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useStarkName = useStarkName;
    function useAddressFromStarkName({ name, contract }) {
      const { library } = (0, providers_1.useStarknet)();
      const { data, isLoading, isSuccess, isError, error, isFetching, isStale: isIdle, isFetched, isFetchedAfterMount, isRefetching, refetch, status } = (0, react_query_1.useQuery)({
        queryKey: ["addressFromStarkName"],
        queryFn: async () => {
          const provider2 = new starknet_1.Provider(library);
          const result = provider2.getAddressFromStarkName(name, contract);
          if (result instanceof Error)
            throw new Error(result.message);
          return result;
        }
      });
      return {
        data,
        isLoading,
        isSuccess,
        isError,
        error,
        isIdle,
        isFetching,
        isFetched,
        isFetchedAfterMount,
        isRefetching,
        refetch,
        status
      };
    }
    exports.useAddressFromStarkName = useAddressFromStarkName;
  }
});

// node_modules/@starknet-react/core/dist/hooks/index.js
var require_hooks = __commonJS({
  "node_modules/@starknet-react/core/dist/hooks/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_account(), exports);
    __exportStar(require_balance(), exports);
    __exportStar(require_block(), exports);
    __exportStar(require_call(), exports);
    __exportStar(require_connectors(), exports);
    __exportStar(require_contract(), exports);
    __exportStar(require_deploy(), exports);
    __exportStar(require_execute(), exports);
    __exportStar(require_library(), exports);
    __exportStar(require_network2(), exports);
    __exportStar(require_sign(), exports);
    __exportStar(require_transaction2(), exports);
    __exportStar(require_receipt(), exports);
    __exportStar(require_starknetid(), exports);
  }
});

// node_modules/@starknet-react/core/dist/connectors/base.js
var require_base = __commonJS({
  "node_modules/@starknet-react/core/dist/connectors/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connector = void 0;
    var Connector = class {
      constructor({ options }) {
        this.options = options;
      }
    };
    exports.Connector = Connector;
  }
});

// node_modules/get-starknet-core/dist/core.umd.cjs
var require_core_umd = __commonJS({
  "node_modules/get-starknet-core/dist/core.umd.cjs"(exports, module) {
    var E = Object.defineProperty;
    var v = (e, g2, D) => g2 in e ? E(e, g2, { enumerable: true, configurable: true, writable: true, value: D }) : e[g2] = D;
    var f = (e, g2, D) => (v(e, typeof g2 != "symbol" ? g2 + "" : g2, D), D);
    var S = (e, g2, D) => {
      if (!g2.has(e))
        throw TypeError("Cannot " + D);
    };
    var z = (e, g2, D) => (S(e, g2, "read from private field"), D ? D.call(e) : g2.get(e));
    var C = (e, g2, D) => {
      if (g2.has(e))
        throw TypeError("Cannot add the same private member more than once");
      g2 instanceof WeakSet ? g2.add(e) : g2.set(e, D);
    };
    var s = (e, g2, D, r) => (S(e, g2, "write to private field"), r ? r.call(e, D) : g2.set(e, D), D);
    var y = (e, g2, D) => (S(e, g2, "access private method"), D);
    (function(e, g2) {
      typeof exports == "object" && typeof module < "u" ? g2(exports) : typeof define == "function" && define.amd ? define(["exports"], g2) : (e = typeof globalThis < "u" ? globalThis : e || self, g2(e.core = {}));
    })(exports, function(e) {
      var n, u, a, o, Q, l, O;
      "use strict";
      const g2 = [{ id: "argentX", name: "Argent X", icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=", downloads: { chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb", firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x" } }, { id: "braavos", name: "Braavos", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+", downloads: { chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma", firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet", edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc" } }], D = () => `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, r = (I) => {
        for (let M = I.length - 1; M > 0; M--) {
          const N = Math.floor(Math.random() * (M + 1));
          [I[M], I[N]] = [I[N], I[M]];
        }
        return I;
      };
      function d(...I) {
        return (M) => I.reduce((N, i) => N.then(i), Promise.resolve(M));
      }
      class Y {
        constructor(M) {
          C(this, o);
          C(this, l);
          C(this, n, false);
          C(this, u, void 0);
          C(this, a, void 0);
          f(this, "value");
          s(this, a, M), y(this, l, O).call(this);
        }
        set(M) {
          return !z(this, n) && !y(this, l, O).call(this) ? false : (this.delete(), this.value = M, M && (s(this, u, `${z(this, a)}-${D()}`), localStorage.setItem(z(this, u), M)), true);
        }
        get() {
          return y(this, o, Q).call(this), this.value;
        }
        delete() {
          return !z(this, n) && !y(this, l, O).call(this) ? false : (this.value = null, z(this, u) && localStorage.removeItem(z(this, u)), true);
        }
      }
      n = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakSet(), Q = function() {
        this.value && this.set(this.value);
      }, l = /* @__PURE__ */ new WeakSet(), O = function() {
        try {
          !z(this, n) && typeof window < "u" && (s(this, u, Object.keys(localStorage).find((M) => M.startsWith(z(this, a)))), s(this, n, true), z(this, u) && this.set(localStorage.getItem(z(this, u))));
        } catch (M) {
          console.warn(M);
        }
        return z(this, n);
      };
      function T(I, M) {
        var N, i;
        if ((N = M == null ? void 0 : M.include) != null && N.length) {
          const j = new Set(M.include);
          return I.filter((t) => j.has(t.id));
        }
        if ((i = M == null ? void 0 : M.exclude) != null && i.length) {
          const j = new Set(M.exclude);
          return I.filter((t) => !j.has(t.id));
        }
        return I;
      }
      const x = async (I) => {
        const M = await Promise.all(I.map((N) => N.isPreauthorized().catch(() => false)));
        return I.filter((N, i) => M[i]);
      }, U = (I) => {
        try {
          return I && ["request", "isConnected", "provider", "enable", "isPreauthorized", "on", "off", "version", "id", "name", "icon"].every((M) => M in I);
        } catch {
        }
        return false;
      };
      function L(I, M) {
        return Object.values(Object.getOwnPropertyNames(I).reduce((N, i) => {
          if (i.startsWith("starknet")) {
            const j = I[i];
            M(j) && !N[j.id] && (N[j.id] = j);
          }
          return N;
        }, {}));
      }
      const w = (I, M) => {
        if (M && Array.isArray(M)) {
          I.sort((i, j) => M.indexOf(i.id) - M.indexOf(j.id));
          const N = I.length - M.length;
          return [...I.slice(N), ...r(I.slice(0, N))];
        } else
          return r(I);
      }, m = { windowObject: typeof window < "u" ? window : {}, isWalletObject: U, storageFactoryImplementation: (I) => new Y(I) };
      function k(I = {}) {
        const { storageFactoryImplementation: M, windowObject: N, isWalletObject: i } = { ...m, ...I }, j = M("gsw-last");
        return { getAvailableWallets: async (t = {}) => {
          const c = L(N, i);
          return d((A) => T(A, t), (A) => w(A, t.sort))(c);
        }, getPreAuthorizedWallets: async (t = {}) => {
          const c = L(N, i);
          return d((A) => x(A), (A) => T(A, t), (A) => w(A, t.sort))(c);
        }, getDiscoveryWallets: async (t = {}) => d((c) => T(c, t), (c) => w(c, t.sort))(g2), getLastConnectedWallet: async () => {
          const t = j.get(), A = L(N, i).find((W) => W.id === t), [h] = await x(A ? [A] : []);
          return h || (j.delete(), null);
        }, enable: async (t, c) => {
          if (await t.enable(c != null ? c : { starknetVersion: "v5" }), !t.isConnected)
            throw new Error("Failed to connect to wallet");
          return j.set(t.id), t;
        }, disconnect: async ({ clearLastWallet: t } = {}) => {
          t && j.delete();
        } };
      }
      const b = k();
      e.default = b, e.getStarknet = k, Object.defineProperties(e, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});

// node_modules/@starknet-react/core/dist/connectors/injected.js
var require_injected = __commonJS({
  "node_modules/@starknet-react/core/dist/connectors/injected.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InjectedConnector = void 0;
    var base_1 = require_base();
    var errors_1 = require_errors();
    var get_starknet_core_1 = require_core_umd();
    var InjectedConnector = class extends base_1.Connector {
      constructor({ options }) {
        super({ options });
      }
      available() {
        this.ensureWallet();
        return this._wallet !== void 0;
      }
      async ready() {
        await this.ensureWallet();
        if (!this._wallet)
          return false;
        return await this._wallet.isPreauthorized();
      }
      async connect() {
        await this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotFoundError();
        }
        try {
          await this._wallet.enable({ starknetVersion: "v5" });
        } catch {
          throw new errors_1.UserRejectedRequestError();
        }
        if (!this._wallet.isConnected) {
          throw new errors_1.UserRejectedRequestError();
        }
        return this._wallet.account;
      }
      async disconnect() {
        var _a;
        await this.ensureWallet();
        if (!this.available()) {
          throw new errors_1.ConnectorNotFoundError();
        }
        if (!((_a = this._wallet) == null ? void 0 : _a.isConnected)) {
          throw new errors_1.UserNotConnectedError();
        }
      }
      async account() {
        await this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotConnectedError();
        }
        if (!this._wallet.account) {
          return null;
        }
        return this._wallet.account;
      }
      get id() {
        return this.options.id;
      }
      get name() {
        this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotConnectedError();
        }
        return this._wallet.name;
      }
      get icon() {
        this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotConnectedError();
        }
        return this._wallet.icon;
      }
      async initEventListener(accountChangeCb) {
        await this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotConnectedError();
        }
        this._wallet.on("accountsChanged", accountChangeCb);
      }
      async removeEventListener(accountChangeCb) {
        await this.ensureWallet();
        if (!this._wallet) {
          throw new errors_1.ConnectorNotConnectedError();
        }
        this._wallet.off("accountsChanged", accountChangeCb);
      }
      async ensureWallet() {
        const starknet = (0, get_starknet_core_1.getStarknet)();
        const installed = await starknet.getAvailableWallets();
        const wallet = installed.filter((w) => w.id === this.options.id)[0];
        if (wallet) {
          this._wallet = wallet;
        }
      }
    };
    exports.InjectedConnector = InjectedConnector;
  }
});

// node_modules/@starknet-react/core/dist/connectors/index.js
var require_connectors2 = __commonJS({
  "node_modules/@starknet-react/core/dist/connectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InjectedConnector = exports.Connector = void 0;
    var base_1 = require_base();
    Object.defineProperty(exports, "Connector", { enumerable: true, get: function() {
      return base_1.Connector;
    } });
    var injected_1 = require_injected();
    Object.defineProperty(exports, "InjectedConnector", { enumerable: true, get: function() {
      return injected_1.InjectedConnector;
    } });
  }
});

// node_modules/@starknet-react/core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@starknet-react/core/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTransactionManager = exports.StarknetConfig = void 0;
    var providers_1 = require_providers();
    Object.defineProperty(exports, "StarknetConfig", { enumerable: true, get: function() {
      return providers_1.StarknetConfig;
    } });
    Object.defineProperty(exports, "useTransactionManager", { enumerable: true, get: function() {
      return providers_1.useTransactionManager;
    } });
    __exportStar(require_hooks(), exports);
    __exportStar(require_connectors2(), exports);
    __exportStar(require_network(), exports);
  }
});
export default require_dist2();
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/poseidon.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@starknet-react_core.js.map
